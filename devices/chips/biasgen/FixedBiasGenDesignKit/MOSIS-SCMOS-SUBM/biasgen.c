/*******************************************************************************
 $Id: biasgen.c,v 1.3 2004/07/22 17:23:44 tobi Exp $
 
 Copyright 2004 Tobi Delbruck (tobi@ini.phys.ethz.ch, http://www.ini.unizh.ch/~tobi)
 Inst. of Neuroinformatics, ETH/Univ. Zurich, Switzerland.
 
 See http://www.ini.unizh.ch/~tobi/biasgen for extensive documentation.
 
 
 (see end of file for CVS log)
 
 * Macro Name: biasgen
 * Creator  : $Author: tobi $ 
 * 8 Jul 2003	Generated by L-Edit
 
    This is part of biasgen, a compiler of reference currents.
    Copyright (C) 2003 T. Delbruck

    This program is free software; you can redistribute it and/or modify
    it under the terms of the GNU General Public License as published by
    the Free Software Foundation; either version 2 of the License, or
    (at your option) any later version.

    This program is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    GNU General Public License for more details.

    You should have received a copy of the GNU General Public License
    along with this program; if not, write to the Free Software
    Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA

 *******************************************************************************/
 
 /* 
 parameters for biasgen.biases are written in the biasgen.sp netlist using 
 parameterizable cells .biasParameters in the schematic.
 lines take the form, 
 *BIASCOMPILE name=[biasname no spaces] type=[N_CURRENT|P_CURRENT|N_CASCODE|P_CASCODE] I=[current in amps scientific] W=[w in lambda] L=[L in lambda] M=[copies]

(order doesn't matter, delimiters are spaces or tabs)
e.g.
*BIASCOMPILE name=follBias type=N_CURRENT I=1e-6 W=24 L=6 M=1


In addition, a single instance of another cell .biasProcess in s-edit will write a line 
in the netlist specifying some and operating parameters and process parameters obtained from mosis run data:

*BIASPROCESS Kprime=[mu*Cox/2 in A/V^2] Temperature=[temperature in deg C]


Functions generally return 0 if they are successful; any other return signifies error.

 */
 
 
module biasgen_macro_module
{

// set true to show layout updates during execution
#define DISPLAY true

// source libary layout (this is the only #define that changes between technology versions of this code)
#define CHIPLIB "biasgen-scmos-subm.tdb"
// netlist to read parameters from
#define NETLIST "biasgen.sp"
// name of resulting schematic for LVS vs layout. This netlist has individual bias transistors connected to proper
// splitter output written to it.
#define NETLIST_FOR_LVS "biasgen-lvs.sp"

// max input line length
#define MAX_LINE 512
// max length of bias name
#define MAX_NAME 64
#define MAX_TYPE MAX_NAME
// max number of biases
#define MAX_BIASES 100
// max number of splitter cells
#define MAX_SPLITTERS 100

#define PORT_SIZE 20 // port size in lambda for informational ports

//////////////////////////////////////////////////////////////
// user shouldn't have to change anything below this line....

// bias type ints
#define BIAS_TYPE_N_CURRENT 1
#define BIAS_TYPE_P_CURRENT 2
#define BIAS_TYPE_N_CASCODE 3
#define BIAS_TYPE_P_CASCODE 4

// the ratio between each splitter cell current
#define SPLITTER_RATIO 2.0

// gain around masterbias current mirrors. this is just M*(W/L ratios)
#define MASTER_BIAS_GAIN (6*(120./6.)/(24./6.))

// master bias W/L of output nfet
#define MASTER_BIAS_W_OVER_L 24/6

/* leader for parameters for process */
#define BIASPROCESS "*BIASPROCESS" 	

/* leader for bias generator bias parameters in schematic netlist */
#define BIASCOMPILE "*BIASCOMPILE"

#include <stdlib.h>
#include <stdarg.h>
#include <stdio.h>
#include <string.h>
#include <ctype.h>
//#include <time.h>
#include <math.h>
#include <malloc.h>
#include "ldata.h"
/* Begin -- Remove this block if you are not using L-Comp. */
#include "lcomp.h"
/* End */

FILE *logFile;
FILE *testdataFile;//PDZ		
bool logFileOpened=false;
 // the name of the logfile
#define LOGFILE "biasgen-log.txt" 

FILE *schematicFile=NULL, *lvsSchematicFile=NULL; // the original schematic, along with the one that can be LVS'ed vs layout

/** the structure that holds an individual bias */
typedef struct biasStruct{
	char name[MAX_NAME];				// name of bias, used to make ports and cell instance name
	char typeString[MAX_TYPE];		// the type of bias "N", "P", 
	int typeInt;						// type as one of int defs above
	double current;					// the *desired* current in amps
	float width;						// width in lambda of users fet with specified current
	float length;						// length in lambda
	int multiplier;					// number of copies of current
	int splitterNumber;				// the number of the splitter output to use starting from 0, which gives a current master/2 when using octave splitter
	int location;						// location numbered from 0 closest to the masterbias
	int busNumber;				// the number of the bus segment (bus segments could be reused if multiple biases use same splitter output)
	double actualCurrent;			//	the actual current from splitter
	double actualToDesiredCurrentRatio;		// ratio actual/desired current
//	biasStruct *next;
//	biasStruct *previous;
} biasStruct;

void writeBiasFet(int number, char *drain, char *gate, char *source, char *bulk, char *model, biasStruct *bias);//PDZ
void refresh();//PDZ
void cleanup();//PDZ
void writeTestBench();//PDZ
void routeBiasToSplitter(int n, int typeInt);//PDZ
void writeSplitterSchematic();//PDZ
/** logs string to log file with \n appended
@param s char string
*/
void logger(char *s){
	if(!logFileOpened){
		logFile=fopen(LOGFILE,"w");
		if(logFile==NULL){
			LDialog_AlertBox(LFormat("couldn't open logger file %s",LOGFILE));
		}else{
			fprintf(logFile,"biasgen compiler log\n\n");
			logFileOpened=true;
		}
	}
	fprintf(logFile,"%s\n",s);
	LStatusBar_SetMsg(s);
	//LDialog_MsgBox(s);
}

// alert function
void alert(char *s){
	if(!logFileOpened){
		logFile=fopen(LOGFILE,"w");
		if(logFile==NULL){
			LDialog_AlertBox(LFormat("couldn't open logger file %s",LOGFILE));
		}else{
			fprintf(logFile,"biasgen compiler log\n\n");
			logFileOpened=true;
		}
	}
	fprintf(logFile,"ALERT: %s\n",s);
	LDialog_AlertBox(s);
}

///** the structure that holds an individual bias */
//typedef struct biasStruct{
//	char name[MAX_NAME];				// name of bias, used to make ports and cell instance name
//	char typeString[MAX_TYPE];		// the type of bias "N", "P", 
//	int typeInt;						// type as one of int defs above
//	double current;					// the *desired* current in amps
//	float width;						// width in lambda of users fet with specified current
//	float length;						// length in lambda
//	int multiplier;					// number of copies of current
//	int splitterNumber;				// the number of the splitter output to use starting from 0, which gives a current master/2 when using octave splitter
//	int location;						// location numbered from 0 closest to the masterbias
//	int busNumber;				// the number of the bus segment (bus segments could be reused if multiple biases use same splitter output)
//	double actualCurrent;			//	the actual current from splitter
//	double actualToDesiredCurrentRatio;		// ratio actual/desired current
////	biasStruct *next;
////	biasStruct *previous;
//} biasStruct;
//
/** holds general information about bias generator */
struct {	
	int numBiases;
	biasStruct *biases[MAX_BIASES];
} biasgen;

/** the current in each splitter */
double splitterCurrents[MAX_SPLITTERS];

/** holds info about master bias current generator */
struct {
	double current;
	double resistanceSubThreshold;
	double resistanceAboveThreshold;
	double maxResistance; // this is computed as min of above.
									// it is best estimate of required resistance since real bias current
									// is larger than that estimated by either resistance
} masterBias;

/** holds information about range of bias currents and about current splitters */
struct{
	double maxBiasCurrent;
	double minBiasCurrent;	// these are computed after parsing biasgen.biases
	double maxToMinRatio;
	double log2MaxToMinRatio;
	int numSplitters;		// the number of splitters
	bool splitterUsed[MAX_BIASES];	// true if the splitter output is actually used.  
												// used for the construction of the bus
	int numSplittersUsed; // number of splitter outputs actually used
	int splitterToBusMap[MAX_SPLITTERS]; // records which bus segment each splitter output goes to
	int busToSplitterMap[MAX_SPLITTERS];	// records which splitter each bus segment is for
} biasRange;

/** process and operating parameters */
struct {
	double kprime;		// mu*Cox/2
	double temperature; // operating temperature
	double ut; // thermal voltage
} process;

int fetNumber=1000; // starting number for new transistors written to output schematic

/** shows information about a particular bias */	
void logBias(biasStruct* bias){
	
	logger(LFormat("Individual bias with name=%s",bias->name));
	logger(LFormat("type=%s",bias->typeString));
	logger(LFormat("width/length=%g/%g, M=%d",bias->width,bias->length,bias->multiplier));
	logger(LFormat("splitter=%d, busNumber=%d",
			bias->splitterNumber,
			bias->busNumber
		)
	);
	logger(LFormat("desired current=%g, actual current=%g, ratio actual/desired=%g",
			bias->current,
			bias->actualCurrent,
			bias->actualToDesiredCurrentRatio
		)
	);
	logger("");
}

/** initializes a bias structure to default values.  used just after memory is allocated */
void initBiasDefaults(biasStruct *bias){
	strcpy(bias->name,"");
	bias->current=0.0;
	bias->actualCurrent=0.0;
	bias->actualToDesiredCurrentRatio=1;
	strcpy(bias->typeString,"");
	bias->width=24;
	bias->length=6;
	bias->multiplier=1;
	int i;
}

/** place all variable initialization here. 
This is necesary for repeat runs because variables are persistent across invocations of a macro. 
*/
void initVariables(){
	int i;
	logger("initVariables()");
	
	// process parameters
	process.kprime=0;	// force user to set this, this is mu*Cox/2
	process.temperature=25;  // in celsius
	process.ut=0.0254;	// in volts
	
	// bias range
	biasRange.maxBiasCurrent=-1e12;
	biasRange.minBiasCurrent=1e12;
	biasRange.numSplitters=0;
	
	// biasgen
	biasgen.numBiases=0;

	// masterbias
	masterBias.current=0;
	masterBias.resistanceSubThreshold=0;
	masterBias.resistanceAboveThreshold=0;

	// splitter bus
	for(i=0;i<MAX_BIASES;i++){
		biasRange.splitterUsed[i]=false;
		biasRange.splitterToBusMap[i]=-1;
		biasRange.busToSplitterMap[i]=-1;
	}

}

/** the library of cells */	
	LFile library;

	
/** the main routine */
void buildBiasgen( void )
{
	LCell cell;
	LC_InitializeState();

	LUpi_SetUpdateDisplayMode(1); //update during execution

//	LC_Trace(1);
//	LC_TraceFile("compiler-output.txt");
	
// following open doesn't work, chiplib must already be open

	LStatusBar_SetMsg("opening library of cells \n");

	library=LFile_Open(CHIPLIB,LTdbFile);
	if(library==NULL){
		LDialog_AlertBox(LFormat("can't open library %s",CHIPLIB));
		return;
	}
	
	// set library to be the open layout file
	if((library=LFile_GetVisible())==0){
		alert("make the biasgen layout library window visible and run macro again");
		return;
	}

	cell=LCell_Find(library, "biasgen");
	if(cell!=NULL){
		LCell_Delete(cell);
	}
	cell=LCell_New(library, "biasgen");
	
//	LFile_OpenCell(library,"biasgen");

//	cell=LCell_Find(library,"biasgen");
	LCell_MakeVisible(cell);
		
	
/*
	// do cursory check to see if correct library is open
	if(LC_CellExists("biasgen")==0){
		alert("biasgen doesn't exist, something's wrong");
		return;
	}
*/	
	
	LStatusBar_SetMsg("making biasgen");
	// makeBiasgen returns nonzero if it finds some error
	// there seems to be no way to simply abort the macro...
	if(makeBiasgen()!=0){
		alert("error making biasgen");
		cleanup();
		return;
	}
		
	if(LFile_OpenCell(library,"biasgen")==0){
		alert("can't open cell biasgen in library");
	}
	
	cleanup();
	
	LWindow_LoadTextFile( "biasgen-log.txt", TEXT );

	LCell_HomeView(LCell_Find(library,"biasgen"));
	
	refresh();
	
	return;
	
}

// comment to speed up
void refresh(){
	if(DISPLAY) {
		LCell_HomeView(LCell_Find(library,"biasgen"));
		LDisplay_Refresh();
	}
}
	
/** closes files, free bias memory */
void cleanup(){
		int i;
		logger("cleaning up");
		for(i=0;i<biasgen.numBiases;i++){
			free(biasgen.biases[i]);
		}
		closeOutputSchematicFile();
//PDZ		fcloseall();
		//if(schematicFile!=NULL) fclose(schematicFile);	
		if(logFile!=NULL) fclose(logFile);
		
}

/** makes the bias generator. calls all other functions.
@return 0 if no error
 */
int makeBiasgen(){
	int qq=2000;//PDZ
	// init bias gen vars here explicitly
	initVariables();
	if(parseSchematic()!=0) return -1;
	if(computeBiasRange()!=0) return -1;
	if(computeMasterBias()!=0) return -1;
	if(computeSplitterCells()!=0) return -1;
	if(doLayout()!=0) return -1;
	writeSplitterSchematic();
	if(writeReport()!=0) return -1;
	writeTestBench();
	
	return 0;
}

/** writes summary report into log file and opens it.
@return 0 if no error
*/
int writeReport(){
	int i;
	LStatusBar_SetMsg("writing report\n");
	//alert("writeReport");
	logger("****************************************************************");
	logger("summary report");
	logger("");
	logger(LFormat("Process parameters kprime(mu*Cox/2)=%g, temperature(degC)=%g, UT(V)=%g",process.kprime,process.temperature,process.ut));
	logger(LFormat("Master bias current %gA with Rx=%.3g ohms (Rx=%.3g ohms (above threshold) Rx=%.3g ohms (subthreshold))",
		masterBias.current, 
		masterBias.maxResistance,
		masterBias.resistanceAboveThreshold, 
		masterBias.resistanceSubThreshold));
	logger("");
	logger(LFormat("%d splitter cells + 1 termination cell\nsplitter\tcurrent",biasRange.numSplitters));
	for(i=0;i<biasRange.numSplitters;i++){
		logger(LFormat("%d\t%g",i,masterBias.current/pow(SPLITTER_RATIO,i+1)));
	}
	logger("");
	logger("Individual biases");

	logger(
		LFormat(
			"Max/Min bias currents=%g/%g (%.2g octaves, %.2g decades)",
			biasRange.maxBiasCurrent,
			biasRange.minBiasCurrent,
			biasRange.log2MaxToMinRatio,
			biasRange.log2MaxToMinRatio/log(10)*log(2)
		)
	);

	logger("");
	for(i=0;i<biasgen.numBiases;i++){
		biasStruct *bias=biasgen.biases[i];
		logBias(bias);
		//alert(LFormat("bias %s, actual current %g",bias->name, bias->actualCurrent));
		logger("");
	}
	
	logger("\n\nConnection table (make these connections in schematic)");
	for(i=0;i<biasgen.numBiases;i++){
		biasStruct *bias=biasgen.biases[i];
		logger(LFormat("%s -> nb%d", bias->name, bias->splitterNumber));
		//alert(LFormat("bias %s, actual current %g",bias->name, bias->actualCurrent));
	}
	
	logger("\n\nDon't forget to change the W/L of the individual bias transistors manually");

	logger("\n\nend of summary report\n***************************************************************");
	return 0;
	
}

void writeTestBench(){
	int i;
	FILE *f=fopen("biasgen-print.sp","w");
	LStatusBar_SetMsg("writing SPICE test bench \n");
	if(f==NULL){
		alert("couldn't open testbench spice deck biasgen-print.sp for output");
		return;
	}

	// write test fet for masterbias current
			fprintf(f,"Mmasterbias_test mid BiasGenNBias gnd gnd nmos W=24 L=6 as=100 ad=100 ps=24 pd=24\n");
			fprintf(f,"Mmasterbias_testCascode Vdd BiasGenNCasc mid gnd nmos W=24 L=6 as=100 ad=100 ps=24 pd=24\n");
			fprintf(f,".print tran i(Mmasterbias_test)\n");
			fprintf(f,".print dc i(Mmasterbias_test)\n");
	

	
	// write test fets for splitter
	for(i=0;i<biasRange.numSplitters;i++){
			fprintf(f,"%s\n",LFormat("MspliterTest%d Vdd nb%d gnd gnd nmos W=24 L=6 as=100 ad=100 ps=24 pd=24\n",i,i));
			fprintf(f,"%s\n",LFormat(".print tran i(MspliterTest%d)\n",i));
			fprintf(f,"%s\n",LFormat(".print dc i(MspliterTest%d)\n",i));
	}	
	
	
	//write test fets
	for(i=0;i<biasgen.numBiases;i++){
		biasStruct *bias=biasgen.biases[i];
			// write the test fet statement.  as, pd, etc are not important and come from a w=24 fet approximately. they obviate excess warnings from tspice.
			fprintf(f,"%s\n",LFormat("Mtest_%s Vdd nb%d gnd gnd nmos W=24 L=6 as=100 ad=100 ps=24 pd=24\n",bias->name,bias->splitterNumber));
			fprintf(f,"%s\n",LFormat(".print tran i(Mtest_%s)\n",bias->name));
			fprintf(f,"%s\n",LFormat(".print dc i(Mtest_%s)\n",bias->name));
	}
}

/** does the layout of the circuit.
1. place the masterbias.
2. place the current splitters to the left and the terminator
3. go back to the masterbias placement
4. place a bus for each bias above the current splitters tapping from the correct splitter
	4.1 place an array of routing cells above the splitters sans connections with height of routing (number of channels)
	equal to number of biases.
	4.2 for each bias place a cell connecting that bias to the correct routing channel.
5. creates individual bias cells from prototypes and aligns them to left of current splitters, wiring each up to 
	correct splitter.
	
@return 0 if no error
*/
int doLayout(){
	int i,j;
	LInstance inst;
	LCell cell;
	LPort port;
	LRect rect;
	LTransform transform;
	
//	alert("starting doLayout");
	
	LC_CellOpen("biasgen");


	
	LC_SetAbutmentType(ABUT);
	LC_SetXYPlacementPosition(0,0);
	LC_SetCompositionDirection(RIGHT);
	LC_SetReferencePoint(LL);
	
	// put down masterbias
	
	LC_Instance("masterbias","masterbias");
	
	// find the rx port and put a label on it in biasgen cell showing the required resistance
	
	LCell masterBiasCell=LCell_Find(library,"masterbias");
	LPort rxPort=LPort_Find( masterBiasCell,"rx");
	LRect rxRect=LPort_GetRect(rxPort);
	
	LInstance masterBiasInstance=LInstance_Find(masterBiasCell, "masterbias");
	LTransform masterBiasTransform=LInstance_GetTransform(masterBiasInstance);

	LRect portRect=LRect_Transform(rxRect,masterBiasTransform);
	LCell biasgenCell=LCell_Find(library,"biasgen");
	
	// make the port
	LPort rxValuePort=LPort_New(biasgenCell,LLayer_Find(library,"Cell Outline Layer"),
		LFormat("rx=%.0f ohms",masterBias.maxResistance),portRect.x0,portRect.y0,portRect.x1,portRect.y1);
	LPort_SetTextAlignment(rxValuePort,PORT_TEXT_MIDDLE|PORT_TEXT_TOP|PORT_TEXT_VERTICAL);
	LPort_SetTextSize(rxValuePort,LC_Lambda(PORT_SIZE));

	refresh();
	
	// instance splitter cells
	
	LC_SetAbutmentType(ABUT);
	LC_SetReferencePoint(LL);
	LC_SetCompositionDirection(LEFT);

	// we instance numSplitters splitters, instance names numbered from 0 to numSplitters-1
	for(i=0;i<biasRange.numSplitters;i++){
		LC_InstanceAlign("biasSplitterOctave",LFormat("splitter%d",i));
		refresh();
	}
	// terminate with the termination splitter cell.  this leaves us (numSplitters) + (1 termination) cells.
	LC_InstanceAlign("biasSplitterOctaveTerminate","splitterTermination");
	
	LC_Push(); // save this to append biases
		
	// set the reference point to the lower right corner for newly placed cells
	LC_SetReferencePoint(LR);
	
	// set the position for the splitter routing cells
	LC_SetXYPlacementPosition(0,LC_GetElementHeight("biasSplitterOctave"));
	
	
	//logger(LFormat("set height %g um",LC_InMicrons(LC_GetYPlacementPosition())));
	
	// iterate and align routing, pop back to start, increment height, push
	
/*
	// push this position on stack
	LC_Push();
	LC_SetCompositionDirection(LEFT);
*/
	
//	alert(LFormat("doLayout: placing %d x %d splitter bus cells",biasRange.numSplitters,biasgen.numBiases));
	logger(LFormat("doLayout: placing %d x %d splitter bus cells",biasRange.numSplitters,biasgen.numBiases));
	
	// we set our position relative to the origin, which is the LL corner of the masterbias and the LR corner of the splitter
	// array. we put the point at the UR corner of the splitter array
	LC_SetXYPlacementPosition(
		0,
		LC_GetElementHeight("biasSplitterOctave")
	);
	
	// set the reference point for placing the array at the LR corner of the array. the LR corner of the array
	// should go at the XY placement position
	LC_SetReferencePoint(LOWER+RIGHT);

	// use the built in function for creating arrays
	// this function is not documented in the PDF but exists in lcomp.h
	inst=LC_Create2DArray(biasRange.numSplitters+2,biasRange.numSplittersUsed,"biasSplitterRouteUDLR");
	
	// set the name of this routing cell array
	LCell biasRoutingCell=LCell_Find(library,"biasSplitterRouteUDLR");
	LInstance_SetName(biasRoutingCell,inst,"biasRouting");
	
	
	/*
// now we put down splitter bus cells to make effectively an array of splitter bus routing cells.
// these are just horizontal wire segments.  for some reason arrays are not possible in ledit 11+
// because the LInstance_Set function has been obsoleted. I can't figure out how to put down a simple array
// of cells any more.
	LC_Push();
	for(i=0;i<biasgen.numBiases;i++){
		for(j=0;j<biasRange.numSplitters+1;j++){
			LC_Align("biasSplitterRouteUDLR");
		}
		LC_Pop();
		LC_IncrementYPlacementPosition(LC_GetElementHeight("biasSplitterRouteUDLR"));
		LC_Push();
	}	
	
	*/
	
	
/*	

	// put down instance of routing and make an array out of it
	inst=LC_Instance("biasSplitterRouteUDLR","biasRouting");
	// inst is the splitter routing cell

	// make an array out of it with the same location but number of rows equal to number of splitters used
	// and number of columns equal to number of splitter cells
	// termination cell is exactly double the width of the normal splitter cell so we add 2 columns for it.
	LInstance_Set_Ex99(
		LCell_Find(library,"biasSplitterRouteUDLR"),
		inst,
		LInstance_GetTransform(inst),
		LPoint_Set(biasRange.numSplitters+2 , biasRange.numSplittersUsed ), // add 2 for the double-width termination
		LPoint_Set(-LC_GetElementWidth("biasSplitterRouteUDLR"),LC_GetElementHeight("biasSplitterRouteUDLR"))
	);
*/

	refresh();
	
	logger(LFormat("doLayout: placing splitter routing connection cells"));
//	alert(LFormat("doLayout: placing splitter routing connection cells"));

	LPoint point1,point2;
	
	// put down routing connections on top of array of routing cells over splitters. these connect
	// the splitter outputs to the horizontal buses of the splitter outputs.
	// the bus line that is wired to is given by biasRange.splitterToBusMap[]
	for(i=0;i<biasRange.numSplitters;i++){
		if(!biasRange.splitterUsed[i]) continue;
		LC_SetXYPlacementPosition(
			-LC_GetElementWidth("biasSplitterRouteUDLR")*(i),
			LC_GetElementHeight("biasSplitterOctave")  +   biasRange.splitterToBusMap[i]*LC_GetElementHeight("biasSplitterRouteUDLR")
		);
		LC_SetReferencePoint(LR);
		LC_SetCompositionDirection(NONE);
		LC_Position("biasSplitterRouteConnect");
		
		// put down a port there to show splitter
		LC_SetReferencePoint(CENTER);
		point1=LC_GetXYPlacementPosition();
		point2.x=point1.x-LC_GetElementWidth("biasSplitterRouteConnect");
		point2.y=point1.y+LC_GetElementHeight("biasSplitterRouteConnect");
		port=LC_CreatePort("Metal2",point1, point2 ,LFormat("splitter%d",i));
		LPort_SetTextAlignment(port,PORT_TEXT_MIDDLE|PORT_TEXT_CENTER);

		refresh();
	}
	
	
	// put down individual biases
	// if any individual bias cell already exists, give the option to overwrite it.
	// (the user may have already sized the transistor correctly)
	// this will then overwrite all of the bias cells
	
//	alert("starting indiv biases");
	
	logger("placing individual biases");
	LC_Pop(); // go back to end of splitters
	LC_SetReferencePoint(LR);
	LC_SetCompositionDirection(LEFT);
	
	LC_Push(); // push state just before putting down bias cells
	
	for(i=0;i<biasgen.numBiases;i++){
		logger(LFormat("making bias %d",i));
		//alert(LFormat("making bias %d",i));
		biasStruct *bias=biasgen.biases[i];

		if(makeBiasCell(bias)<0) return -1;		
		
		// route from bias cell to splitter bus
		routeBiasToSplitter(i,bias->typeInt);
		
		refresh();
	}
	
	LC_Pop();

	//finally, place the license string under the entire biasgen and centered
	rect=LCell_GetMbbAll(biasgenCell);
	LC_SetXYPlacementPosition( (rect.x0+rect.x1)/2, (rect.y0)-(rect.y0+rect.y1) );
	LC_SetCompositionDirection(NONE);
	LC_SetReferencePoint(CENTER);
	inst=LC_Instance(".license","license");
//	transform=LInstance_GetTransform(inst);

	return 0;
}


bool overwriteBiasCellsEnabled=true;  // set this to true in order to make new cells
bool overwriteQuestionAsked=false;

/** makes an individual bias cell from the bias given
@param bias pointer to biasStruct
@return 0 if no error
*/
int makeBiasCell(biasStruct *bias){
	char cellName[MAX_NAME];
	LInstance inst;
	LCell cell;
	LPort port;
	
	cellName[0]=0;

	int type=bias->typeInt;
	cellName[0]=0;
	
	strcat(cellName,"biasCell_");
	strcat(cellName,bias->name);

	logger(LFormat("making bias cell named %s",cellName));
//	alert(LFormat("making bias cell named %s",cellName));
	
	cell=LCell_Find(library, cellName);
	if(cell!=NULL && overwriteQuestionAsked==false){
		overwriteQuestionAsked=true;
		int answer=LDialog_YesNoBox(LFormat("Individual bias cell %s already exists, overwrite bias cells?\nIf you answer yes, you may lose edits you have made to the W/L of the individual biases.",
			cellName));
		if(answer==LYES){
			overwriteBiasCellsEnabled=true;
			logger("overwriting previous bias cells");
		}else{
			overwriteBiasCellsEnabled=false;
			logger("not overwriting previous bias bias cells");
		}
	}
	
	switch(type){
	case BIAS_TYPE_N_CURRENT:
		if(overwriteBiasCellsEnabled) LCell_Copy(library, LCell_Find(library,"biasgenNCurrentBias"), library, cellName);
		inst=LC_InstanceAlign(cellName,bias->name);
		break;
	case BIAS_TYPE_N_CASCODE:
		if(overwriteBiasCellsEnabled) LCell_Copy(library, LCell_Find(library,"biasgenNCascodeBias"), library, cellName);
		inst=LC_InstanceAlign(cellName,bias->name);
		break;
	case BIAS_TYPE_P_CURRENT:
		if(overwriteBiasCellsEnabled) LCell_Copy(library, LCell_Find(library,"biasgenPCurrentBias"), library, cellName);
		inst=LC_InstanceAlign(cellName,bias->name);
		break;
	case BIAS_TYPE_P_CASCODE:
		if(overwriteBiasCellsEnabled) LCell_Copy(library, LCell_Find(library,"biasgenPCascodeBias"), library, cellName);
		inst=LC_InstanceAlign(cellName,bias->name);
		break;
	default:
		alert(LFormat("unknown bias type %s for bias %s",bias->typeString,bias->name));
		return -1;
	}
	
	// set the bias names to be the bias name
	
	cell=LCell_Find(library,cellName);
	port=LPort_Find(cell,"bias");
	LPort_SetText(cell,port,bias->name,LC_Lambda(PORT_SIZE));
	port=LPort_FindNext(port,"bias");
	LPort_SetText(cell,port,bias->name,LC_Lambda(PORT_SIZE));
	
	
	// set the transistor port to be the W/L of the required fet
	port=LPort_Find(cell,"modify here");
	LPort_SetText(cell,port,LFormat("make %.1f/%.1f M=%d",bias->width,bias->length,bias->multiplier),LC_Lambda(PORT_SIZE/3));
	LPort_SetTextAlignment(port,PORT_TEXT_HORIZONTAL|PORT_TEXT_MIDDLE|PORT_TEXT_CENTER);
	
	
	// place a summary port on the cell showing desired current, actual current, and ratio
	LC_Push();
	port=LPort_Find(cell,"summary");
	LPort_SetText(cell, port, LFormat("I=%.3g (%.4g)", bias->actualCurrent, bias->actualToDesiredCurrentRatio), LC_Lambda(PORT_SIZE/3));
	LPort_SetTextAlignment(port, PORT_TEXT_HORIZONTAL|PORT_TEXT_MIDDLE|PORT_TEXT_CENTER);
	LC_Pop();
	
	writeIndividualBiasSchematic(bias);
		
}


/** writes the schematics for an individual bias to the LVS schematic output file
@return 0 if successful
*/

int writeIndividualBiasSchematic(biasStruct *bias){
	int midNode1, midNode2;  // shared nodes
	
	if(lvsSchematicFile==NULL) {
		logger("output schematic not opened, not writing individual bias");
		return; //make sure we are outputting
	}
	
	//int type=bias->typeInt;
	//bias->width,bias->length,bias->multiplier;
	
	fprintf(lvsSchematicFile,"* circuit for individual bias %s\n",bias->name);
//	alert(LFormat("writing schematic for bias %s",bias->name));
	
	switch(bias->typeInt){
	case BIAS_TYPE_N_CURRENT:

		//N current has biassource mirror, and W/L nfet
		midNode1=fetNumber;
		midNode2=fetNumber+1;
		
		// copy of splitter output and fancy cascoded mirror
		fprintf(lvsSchematicFile,"Xbiassource_%d nb%d BiasGenNCasc %s Gnd Vdd biassource\n",
			fetNumber++, bias->splitterNumber, bias->name);

		// W/L nfet
		//alert("writing bias fet");
		writeBiasFet(fetNumber++, bias->name, bias->name, "Gnd", "Gnd", "nmos", bias);


	
		break;
	case BIAS_TYPE_N_CASCODE:
		//N cascode has biassource mirror, and W/L nfet for cascode and W/L nfet for dummy load
		midNode1=fetNumber;
		midNode2=fetNumber+1;
		
		// copy of splitter output and fancy cascoded mirror
		fprintf(lvsSchematicFile,"Xbiassource_%d nb%d BiasGenNCasc %s Gnd Vdd biassource\n",
			fetNumber++, bias->splitterNumber, bias->name);

		// W/L nfet cascode source
		//alert("writing n cascode fet");
		writeBiasFet(fetNumber++, bias->name, bias->name, LFormat("N%d", midNode1), "Gnd", "nmos", bias);

		// W/L nfet dummy load
		//alert("writing n cascode dummy");
		writeBiasFet(fetNumber++, LFormat("N%d", midNode1), LFormat("N%d", midNode1), "Gnd", "Gnd", "nmos", bias);

		break;
	case BIAS_TYPE_P_CURRENT:
		// P current has N splitter output, N cascode, and W/L Pfet

		//MN3_1 N1 nb0 Gnd Gnd nmos L=6 W=24 AD='(24*3)+36' PD='24+6+6' AS='(24*3)+36' PS='24+6+6' M=1
		//MN3_8 RecepPuGen BiasGenNCasc N1 Gnd nmos L=6 W=24 AD='(24*3)+36' PD='24+6+6' AS='(24*3)+36' PS='24+6+6' M=1

//		alert("writing p type bias");
		midNode1=fetNumber;
		midNode2=fetNumber+1;
		
		
		// splitter copy
//		alert("1st fet");
		fprintf(lvsSchematicFile,
			"M%d Nmid%d nb%d Gnd Gnd nmos L=6 W=24 AD='(24*3)+36' PD='24+6+6' AS='(24*3)+36' PS='24+6+6' M=1\n",
			fetNumber++, midNode1, bias->splitterNumber);
		// cascode
//		alert("2nd fet");
		fprintf(lvsSchematicFile,
			"M%d %s BiasGenNCasc Nmid%d Gnd nmos L=6 W=24 AD='(24*3)+36' PD='24+6+6' AS='(24*3)+36' PS='24+6+6' M=1\n",
			fetNumber++, bias->name, midNode1);
		
		// W/L pfet
		//alert("writing bias fet");
		writeBiasFet(fetNumber++, "Vdd", bias->name, bias->name, "Vdd", "pmos", bias);
		
		break;
	case BIAS_TYPE_P_CASCODE:
		// P cascode has N splitter output, N cascode, and p cascode fet and W/L Pfet dummy load

		//MN3_1 N1 nb0 Gnd Gnd nmos L=6 W=24 AD='(24*3)+36' PD='24+6+6' AS='(24*3)+36' PS='24+6+6' M=1
		//MN3_8 RecepPuGen BiasGenNCasc N1 Gnd nmos L=6 W=24 AD='(24*3)+36' PD='24+6+6' AS='(24*3)+36' PS='24+6+6' M=1

//		alert("writing p type bias");
		midNode1=fetNumber;
		midNode2=fetNumber+1;
		
		
		// splitter copy
//		alert("1st fet");
		fprintf(lvsSchematicFile,
			"M%d Nmid%d nb%d Gnd Gnd nmos L=6 W=24 AD='(24*3)+36' PD='24+6+6' AS='(24*3)+36' PS='24+6+6' M=1\n",
			fetNumber++, midNode1, bias->splitterNumber);
		// cascode
//		alert("2nd fet");
		fprintf(lvsSchematicFile,
			"M%d %s BiasGenNCasc Nmid%d Gnd nmos L=6 W=24 AD='(24*3)+36' PD='24+6+6' AS='(24*3)+36' PS='24+6+6' M=1\n",
			fetNumber++, bias->name, midNode1);
		
		// W/L cascode pfet
		//alert("writing cascode p fet");
		writeBiasFet(fetNumber++, bias->name, bias->name, LFormat("N%d",midNode1), "Vdd", "pmos", bias);
		
		// W/L pfet
		//alert("writing cascode load fet");
		writeBiasFet(fetNumber++, "Vdd", LFormat("N%d",midNode1), LFormat("N%d",midNode1), "Vdd", "pmos", bias);
		
		break;
	default:
		alert(LFormat("unknown bias type %s for bias %s",bias->typeString,bias->name));
		return -1;
		}
		return 0;
}

void writeBiasFet(int number, char *drain, char *gate, char *source, char *bulk, char *model, biasStruct *bias){
		//alert(LFormat("l=%g w=%g", bias->length,bias->width));
		fprintf(lvsSchematicFile,"M%d ",number);
		fprintf(lvsSchematicFile,"%s %s %s ",drain,gate,source);
		fprintf(lvsSchematicFile,"%s ",bulk);
		fprintf(lvsSchematicFile,"%s ",model);
		fprintf(lvsSchematicFile,"L=%g W=%g ",bias->length,bias->width);
		fprintf(lvsSchematicFile,"AD='%g*3+12' PD='%g+12' ",bias->width,bias->width);
		fprintf(lvsSchematicFile,"AS='(%g*3)+36' PS='%g+12' M=%d\n",bias->width,bias->width,bias->multiplier);
}

void writeSplitterSchematic(){
	int i, splitterNode;
	splitterNode=2000;
	
	// import subcircuits for splitter cell and splitter termination cell
	// these are taken directly from schematic netlists that must have been exported
	fprintf(lvsSchematicFile,"\n.include biasSplitterOctave.sp\n");
	fprintf(lvsSchematicFile,".include biasSplitterOctaveTerminate.sp\n\n");

	if(lvsSchematicFile==NULL) return; // don't bother
	//alert("writing splitters to schematic");
	// splitter connected to masterbias
	fprintf(lvsSchematicFile,
		"XbiasSplitterOctave_0 masterOut nb0 N%d BiasGenNBias Gnd Vdd biasSplitterOctave\n",
		splitterNode
		);
	// rest of splitters. note how printfs with more than 3 args are split to let them work with interpreter.
	for(i=1;i<biasRange.numSplitters;i++){
			fprintf(lvsSchematicFile,
				"XbiasSplitterOctave_%d N%d nb%d ",
				i, splitterNode++, i
				);
			fprintf(lvsSchematicFile,
				" N%d BiasGenNBias Gnd Vdd biasSplitterOctave\n",
				splitterNode);
	}
	// termination
	fprintf(lvsSchematicFile,"XbiasSplitterOctaveTerminate_1 N%d nbTerm BiasGenNBias Gnd Vdd biasSplitterOctaveTerminate\n",
		splitterNode);	

}

/** routes from bias cell to splitter bus. pushes/pops context.
also creates route from bias to bias bus.
@param n the n'th bias 
@param type 'N' for N-type, 'P' for P-type bias
*/
void routeBiasToSplitter(int n, int typeInt){
	char routeCell[MAX_NAME], connectCell[MAX_NAME], biasConnectCell[MAX_NAME];
	char type;
	int i;
	LPoint point1, point2;
	LPort port;
	biasStruct *bias=biasgen.biases[n];
	// save context just before and then restore
	LC_Push();
	
	
	// we need to choose the correct routing and connect cell.
	// add more types here for bias cells with different pitch.
	if(typeInt==BIAS_TYPE_N_CURRENT || typeInt==BIAS_TYPE_N_CASCODE) type='N';
	if(typeInt==BIAS_TYPE_P_CURRENT || typeInt==BIAS_TYPE_P_CASCODE) type='P';
	
	
	// generate the routing cell names, e.g. biasCellNTypeRoute
	strcpy(routeCell,LFormat("biasCell%cTypeRoute",type));
	strcpy(connectCell,LFormat("biasCell%cTypeSplitterConnect",type));
	strcpy(biasConnectCell,LFormat("biasCell%cTypeBiasConnect",type));
	
	logger(LFormat("routing bias #%d of type %c using cells %s, %s, and %s",n,type,routeCell,connectCell,biasConnectCell));
	
	LC_SetCompositionDirection(UP);
	
	// last placed bias cell left us at LL of that cell
	LC_SetReferencePoint(LL);
	
	// go to top UL of last placed bias cell
	LC_IncrementYPlacementPosition(LC_GetElementHeight("biasgenNCurrentBias"));
	
	// place the routes and connect. Number of bus lines is number of splitters that are used.
	for(i=0;i<biasRange.numSplittersUsed;i++){
		// put down a port there to show splitter number
		LC_Push();
		LC_SetReferencePoint(CENTER);
		LC_SetCompositionDirection(NONE);
		point1=LC_GetXYPlacementPosition();
		point1.y=point1.y+LC_GetElementHeight("biasSplitterRouteUDLR")/2; // go 1/2 way to get port over metal wire
		point2.x=point1.x;
		point2.y=point1.y+LC_GetElementHeight("biasSplitterRouteUDLR")/2;
		port=LC_CreatePort("Metal2",point1, point2 ,LFormat("splitter%d",biasRange.busToSplitterMap[i]));
		LPort_SetTextAlignment(port,PORT_TEXT_MIDDLE|PORT_TEXT_CENTER);
		LC_Pop();

		// put down the routing or connect cell
		LC_SetCompositionDirection(UP);
		if(bias->busNumber==i){
			LC_Position(connectCell);
		}else{
			LC_Position(routeCell);
		}
	}
	

	// now put down bus for routing bias out to top left/right
	LC_Push();
	for(i=0;i<biasgen.numBiases;i++){
		// put down a port to show bias name
		LC_Push();
		LC_SetReferencePoint(CENTER);
		LC_SetCompositionDirection(NONE);
		point1=LC_GetXYPlacementPosition();
		point1.y=point1.y+LC_GetElementHeight("biasSplitterRouteUDLR")/2; // go 1/2 way to get port over metal wire
		point2.x=point1.x;
		point2.y=point1.y+LC_GetElementHeight("biasSplitterRouteUDLR")/2;
		port=LC_CreatePort("Metal2",point1, point2 ,LFormat("%s",(biasgen.biases[i])->name) );
		LPort_SetTextAlignment(port,PORT_TEXT_MIDDLE|PORT_TEXT_CENTER);
		LC_Pop();

		// put down the routing or connect cell
		LC_SetCompositionDirection(UP);
		if(i==n){
			LC_Position(biasConnectCell);
		}else{
			LC_Position(routeCell);
		}
	}
	LC_Pop();
	
	// restore context
	LC_Pop();
}


/** iterates over all biases and computes the appropriate splitter cell to wire to, and fills in the
actual values of current that biases will get.
@return 0 if no error
*/
int computeSplitterCells(){
	int i,j;
	double x,y,z;
	logger("\n\ncomputeSplitterCells()");
	// allocate memory for splitter cells
	
	biasStruct *bias;
	// iterate over biases and for each find correct splitter output
	for(i=0;i<biasgen.numBiases;i++){
		bias=biasgen.biases[i];
		bias->splitterNumber=nearestSplitter(bias->current);
		bias->actualCurrent=splitterCurrents[bias->splitterNumber];
		bias->actualToDesiredCurrentRatio=(bias->actualCurrent) / (bias->current);

		logBias(bias);

		// keep track of which splitter was used
		biasRange.splitterUsed[bias->splitterNumber]=true;	// set this bias used to true
	}
	
	// first determine number of bus segments we need for all the biases
	biasRange.numSplittersUsed=0;
	for(i=0;i<MAX_BIASES;i++){
		if(biasRange.splitterUsed[i]) biasRange.numSplittersUsed++;
	}
		
	// now iterate over splitters.
	// for each one that is used (as marked by bool in biasRange.splitterUsed[])
	// look to see if a bus has been assigned yet (as marked by >0 in biasRange.splitterToBusMap[]).
	// if nonnegative, then dont assign a new bus.
	// if negative, then assign the next bus.
	int lastBus=0; // start with bus 0
	for(i=0;i<biasRange.numSplitters;i++){
		if(!biasRange.splitterUsed[i]) continue;
		if(biasRange.splitterToBusMap[i]>=0) continue;
		biasRange.splitterToBusMap[i]=lastBus;
		biasRange.busToSplitterMap[lastBus]=i;
		lastBus++; // increment for next bus line
	}
	
	// iterate over biases again, now assign a bus number.
	for(i=0;i<biasgen.numBiases;i++){
		bias=biasgen.biases[i];
		bias->busNumber=biasRange.splitterToBusMap[bias->splitterNumber];
		logBias(bias);
	}

	logger("done with computeSplitterCells()\n");
	return 0;
}

/** 
computes the range of bias currents and the number of splitter cells. The number
of splitter cells is the log_(SPLITTER_RATIO) (normally log base 2) of the bias range.
We add 1 to this for slop.
@return 0 if no error
*/
int computeBiasRange(){
	// compute bounds on bias currents
	int i;
	logger("computeBiasRange()");
	biasRange.maxBiasCurrent=-1e19;
	biasRange.minBiasCurrent=1e19;
	for(i=0;i<biasgen.numBiases;i++){
		biasRange.maxBiasCurrent=max(biasRange.maxBiasCurrent,biasgen.biases[i]->current);
		biasRange.minBiasCurrent=min(biasRange.minBiasCurrent,biasgen.biases[i]->current);
	}
	if(biasRange.maxBiasCurrent<=0 || biasRange.minBiasCurrent<=0){
		alert(LFormat("computeBiasRange: minBias=%g, maxBias=%g: either/both max/min bias currents <= 0",biasRange.maxBiasCurrent, biasRange.minBiasCurrent));
		return -1;
	}
	biasRange.maxToMinRatio=biasRange.maxBiasCurrent/biasRange.minBiasCurrent;
	// y=2^x, log(y)=x*log(2), log2(y)=x=log(y)/log(2)
	biasRange.log2MaxToMinRatio=log(biasRange.maxToMinRatio)/log(SPLITTER_RATIO);  // becomes log_(SPLITTER_RATIO)
	biasRange.numSplitters=ceil(biasRange.log2MaxToMinRatio)+1;  // add 1 for slop
	logger(LFormat("computeBiasRange: biasRange.maxToMinRatio=%g\nbiasRange.numSplitters=%d",biasRange.maxToMinRatio,biasRange.numSplitters));
	if(biasRange.numSplitters>MAX_SPLITTERS) {
		alert(
			LFormat("Too many splitter cells (%d>%d). Increase MAX_SPLITTERS",
				biasRange.numSplitters, MAX_SPLITTERS));
		return -1;
	}
	logger("done with computeBiasRange()\n");
	return 0;
}	

/** 
NOTE, this function seems to return garbage, i can't find bug. suspect math or stdlib bug.
replaced by explicit computation.

@return the current from a given splitter cell.
@param n the splitter cell, numbered from 1 being the first one.

*/
double currentFromSplitter(int n){
	int i;
	double current;
/*
	current=masterBias.current/SPLITTER_RATIO;
	for(i=0;i<n;i++){
		current/=SPLITTER_RATIO;
	}	
*/
	current=masterBias.current/pow((double)SPLITTER_RATIO,(double)n+1);
	//alert(LFormat("currentFromSplitter: splitterCell=%d, splitterCurrent=%g",n,current));
	return (double)current;
}

/** @return the nearest splitter cell to provide a given current.
@param current the desired current
*/
int nearestSplitter(double current){
	int cell;
	
	// compute log base SPLITTER_RATIO
	double logCurrent = log(biasRange.maxBiasCurrent/current)/log(SPLITTER_RATIO);
	cell=rint(logCurrent); // rounds to nearest int
//	alert(LFormat("logCurrent=%g rounded=%d",logCurrent, cell));

	splitterCurrents[cell]=currentFromSplitter(cell);

	logger(LFormat("nearestSplitter: current=%g, splitterCell=%d, splitterCurrent=%g",current,cell,splitterCurrents[cell]));
	return cell;
}

/** @return nearest int if int>0. We need this because rint is not shipped with interpreter... and (int)double truncates */
//PDZ	int rint(double x){
//PDZ		double n;
//PDZ		double rem=modf(x,&n);
//PDZ		if(rem<.5) return (int)n; else return (int)(n+1);
//PDZ	}

	
// already defined in headers
//#define max(a,b) (((a)>(b))?(a),(b))
//#define min(a,b) (((a)<(b))?(a),(b))

/** 
reads schematic netlist "biasgen.sp" to parse it for lines starting with "*BIASCOMPILE".
Results are stored in the biasgen.biases array and biasgen.numBiases is set to the number of parsed biasgen.biases.
The max and min bias currents are computed and stored in maxBiasCurrent and minBiasCurrent.

@return 0 if no error
*/
int parseSchematic(){
	char line[MAX_LINE];
	biasStruct *newBias;
	int i,qq;
//	FILE *testdataFile=NULL;//PDZ		
//	alert("parseSchematic");
//beginPDZ
	testdataFile=NULL;
	testdataFile=fopen("D:\\Piter\\BiasGen\\biasgen\\FixedBiasGenDesignKit\\MOSIS-SCMOS-SUBM\\testdata.txt","w");
	if(testdataFile==NULL) LDialog_AlertBox(LFormat("La hemos cagao..."));
//endPDZ
	
	schematicFile=fopen(NETLIST,"r");
	if(schematicFile==NULL){
		alert(LFormat("couldn't open schematic netlist %s",NETLIST));
		return -3;
	}
	
	openOutputSchematicFile(); // open file for writing out netlist of compiled biasgen, which includes individual biases
/*
	if(lvsSchematicFile!=NULL){
		alert("opened lvsSchematicFile OK");
	}
*/	
	// scan for command lines and store resulting commands into bias structures	
	biasgen.numBiases=0;
	while(!feof(schematicFile)){
		//fgets(line,MAX_LINE,schematicFile);
		getLine(line);
//beginPDZxxx
		fprintf(testdataFile,"%s\n",line);
//endPDZ
//		LDialog_MsgBox(LFormat("%ld",ftell(schematicFile)));
		// if not compiler or process parameters, contine
//		LDialog_MsgBox(line);
		if(strstr(line,BIASCOMPILE)==NULL && strstr(line,BIASPROCESS)==NULL ) continue;

		if(strstr(line,BIASCOMPILE)!=NULL){
			// bias parameters
			biasgen.numBiases++;
			if(biasgen.numBiases>MAX_BIASES){
				alert("Too many biases, edit MAX_BIASES and reload macro");
				return -5;
			}
			newBias=(biasStruct*)calloc(1,sizeof(biasStruct));
			initBiasDefaults(newBias);
			biasgen.biases[biasgen.numBiases-1]=newBias;
//PDZ			if(parseBias(line,newBias)!=0) {fclose(testdataFile); return -7;}
//beginPDZ
			qq=parseBias(line,newBias);
			if(qq!=0){fclose(logFile); 
				alert(LFormat("parseBias returned, %d",qq)); 
				return -7;}
//endPDZ
		}else if(strstr(line,BIASPROCESS)!=NULL){
			// process parameters
			parseProcessParameters(line);
		}else{
			alert(line);
		}//if(strstr(line,BIASCOMPILE)!=NULL)
	}//while(!feof(schematicFile))
	fclose(schematicFile);	
	fclose(testdataFile);	
//	alert("parsed schematic");
	
	return 0;
}

/** reads a line from schematicFile into buffer line, returns number of chars read.
newline is included in returned string.
@param line a buffer to read the line into
@return length of line in chars including newline
*/
int getLine(char* line){
	int c;
	int n=1;
	char *l;
	l=line;
	c=fgetc(schematicFile);
//	fprintf(logFile,"%c\n",(char)c);

	while (c!='\n' && c!=0 && n++<MAX_LINE-2 && !feof(schematicFile)){
		*l++=(char)c;
		c=fgetc(schematicFile);
//		fprintf(logFile,"%c\n",(char)c);
	}

	if(c=='\n') *l++='\n';
	*l=0;
//	alert(LFormat("read line: %s",line));
	if(lvsSchematicFile!=NULL){
		fprintf(lvsSchematicFile,"%s",line); // write copy of original line to LVS schematic
	}
	
	return strlen(line);
}



/** parses a single line to load information into biasStruct
@param line the line 
@param bias the strcture to fill
*/
int parseBias(char *line, biasStruct *bias){

	char *tok,*subTok;
	char *phc;//PDZ
	logger(LFormat("bias line: %s",line));
	
	fprintf(testdataFile, "LINEA %s\n", line);//PDZ
	tok=strtok(line," \t");
	while(tok!=NULL){
		if(strstr(tok,BIASCOMPILE)!=NULL){
			// do nothing, just recognize it
		}else	if(strstr(tok,"name=")!=NULL){
			strncpy(bias->name,strchr(tok,'=')+1,MAX_NAME);
			fprintf(testdataFile, "PARSEBIAS1 %s\n", bias->name);//PDZ
		}else if(strstr(tok,"W=")!=NULL){
			sscanf(strchr(tok,'=')+1,"%g",&bias->width);
			fprintf(testdataFile, "PARSEBIAS2 %g\n", bias->width);//PDZ
		}else if(strstr(tok,"L=")!=NULL){
			sscanf(strchr(tok,'=')+1,"%g",&bias->length);
			fprintf(testdataFile, "PARSEBIAS3 %g\n", bias->length);//PDZ
		}else if(strstr(tok,"I=")!=NULL){
			subTok=strchr(tok,'=')+2;
			phc=strtok(subTok,"'");//PDZ
			//logger(LFormat("subTok=%s",subTok));//lg
			fprintf(testdataFile, "PARSEBIAS4subtok %s\n", subTok);//PDZ
			sscanf(subTok,"%lg",&bias->current);
			fprintf(testdataFile, "PARSEBIAS4 %lg\n", bias->current);//PDZ
		}else if(strstr(tok,"M=")!=NULL){
			sscanf(strchr(tok,'=')+1,"%d",&bias->multiplier);
			fprintf(testdataFile, "PARSEBIAS5 %d\n", bias->multiplier);//PDZ
		}else if(strstr(tok,"type=")!=NULL){
			sscanf(strchr(tok,'=')+1,"%s",bias->typeString);
			subTok=strchr(tok,'=')+1;
			fprintf(testdataFile, "PARSEBIAS6 %s\n", bias->typeString);//PDZ
			//logger(LFormat("type token=%s",subTok));
			if(strcmp(subTok,"N_CURRENT")==0){
				bias->typeInt=BIAS_TYPE_N_CURRENT;
			}else if(strcmp(subTok,"P_CURRENT")==0){
				bias->typeInt=BIAS_TYPE_P_CURRENT;
			}else if(strcmp(subTok,"N_CASCODE")==0){
				bias->typeInt=BIAS_TYPE_N_CASCODE;
			}else if(strcmp(subTok,"P_CASCODE")==0){
				bias->typeInt=BIAS_TYPE_P_CASCODE;
			}else {
				alert(LFormat("unknown bias type %s in line %s",subTok,line));
				return -1;
			}
		}else {
			alert(LFormat("unknown token %s in line %s",tok,line));
			return -2;
		}
		tok=strtok(NULL," \t");
	}// tokens
	
	// check for bogus biases
	logBias(bias);
	
	if(strlen(bias->name)==0){
		alert("empty bias name");
		return -4;
	}
	
	if(bias->current<=0.0){
		alert("zero current bias");
		return -6;
	}
	
	
	logBias(bias);

	return 0;
} // parseBias


/** parses a single line to load information about process parameters
@param line the line
@return 0 if no error 
*/
int parseProcessParameters(char *line){
	char *tok,*subTok;
	char *phc;//PDZ
	
	logger(LFormat("biasprocess line: %s",line));
/*
		}else if(strstr(tok,"I=")!=NULL){
			subTok=strchr(tok,'=')+2;
			phc=strtok(subTok,"'");//PDZ
			//logger(LFormat("subTok=%s",subTok));//lg
			fprintf(testdataFile, "PARSEBIAS4subtok %s\n", subTok);//PDZ
			sscanf(subTok,"%lg",&bias->current);
			fprintf(testdataFile, "PARSEBIAS4 %lg\n", bias->current);//PDZ
*/	
	tok=strtok(line," \t");
	while(tok!=NULL){
		if(strstr(tok,BIASPROCESS)!=NULL){
			// do nothing, just recognize it
		}else	if(strstr(tok,"kprime=")!=NULL){
//PDZ			sscanf(strchr(tok,'=')+1,"%lg",&process.kprime);
//beginPDZ
			subTok=strchr(tok,'=')+2;
			phc=strtok(subTok,"'");
			sscanf(subTok,"%lg",&process.kprime);
			fprintf(testdataFile, "ASUNTO KPRIME: %lg", process.kprime );
//endPDZ		
		}else if(strstr(tok,"temperature=")!=NULL){
			sscanf(strchr(tok,'=')+1,"%lg",&process.temperature);
		}else {
			alert(LFormat("unknown token %s in line %s\nTokens are Kprime and Temperature (case sensitive)",tok,line));
			fclose(testdataFile);
			return -1;
		}
		tok=strtok(NULL," \t");
	}
	process.ut=0.0254*(process.temperature+273.)/300.;
	
	logger(LFormat("process kprime=%lg, temperature=%lg, UT=%lg",process.kprime,process.temperature,process.ut));

	fclose(testdataFile);//PDZ
	return 0;
} // parseProcessParameters


/** opens schematic file for output (which will include schematics for individual biases
@return -1 if error, else 0
*/
int openOutputSchematicFile(){

	lvsSchematicFile=fopen(NETLIST_FOR_LVS,"w");
	if(lvsSchematicFile==NULL){
		alert(LFormat("couldn't open output schematic netlist for LVS"));
		return -1;
	}
	fprintf(lvsSchematicFile,"* Copy of biasgen schematic written to include individual biases\n");
	logger("Opened output schematic file\n");
	
	return 0;
}

/** closes output schematic file
@return 0 always
*/
int closeOutputSchematicFile(){
	if(lvsSchematicFile!=NULL)
		fclose(lvsSchematicFile);
	return 0;
}


/**
	writes out and closes output schematic, which is same as input schematic but includes transistors
	for individual biases according to whether they are N_CURRENT, P_CURRENT, N_CASCODE, P_CASCODE, etc.
	This schematic can be LVS'ed directly to generated layout, without having to manually draw
	the transistors corresponding to the specified biases and adjust their sizes.
	
	@return 0 if no errors
*/


/** uses maxBiasCurrent to compute appropriate value of off-chip resistance and fills in values for 
masterBiasCurrent and masterBiasResistance.

in subthreshold, i=ln(M)*UT/R, so R=ln(M)*UT/R
above threshold, i=(2/beta*R^2)*sqrt(1-1/sqrt(M))^2 and beta=mu*Cox=2*K', K'=mu*Cox/2, so
R=(1-1/sqrt(M))/sqrt(K'*I)

@return 0 if no error
 */
int computeMasterBias(){
	double logGain;
	double beta;
	
	if(process.kprime==0){
		alert("process kprime (mu*Cox/2) is not set. Use the .biasProcess cell to set process parameters\nYou may need to reload the macro owing to a bug in the stdio library.");
		return -1;
	}
	
	logGain=log(MASTER_BIAS_GAIN);
	masterBias.current=SPLITTER_RATIO*biasRange.maxBiasCurrent;
	masterBias.resistanceSubThreshold=logGain*process.ut/masterBias.current;
	
	beta=process.kprime*MASTER_BIAS_W_OVER_L*2;
	
	masterBias.resistanceAboveThreshold=(1-(1/sqrt(MASTER_BIAS_GAIN))) * sqrt(2/beta/masterBias.current);
	
	masterBias.maxResistance=max(masterBias.resistanceSubThreshold, masterBias.resistanceAboveThreshold);
	
	logger(LFormat("computeMasterBias: MASTER_BIAS_GAIN=%g\nmaster bias current=%g\nresistance sub threshold=%g\nresistance above threshold=%g",
	MASTER_BIAS_GAIN,masterBias.current,masterBias.resistanceSubThreshold,masterBias.resistanceAboveThreshold));
	return 0;
}

/** register macro as hot key */
void  biasgen_register ( void )
{
//	LMacro_BindToMenu("Tools", "Build biasgen F5", "biasgen");
	LMacro_BindToHotKey(KEY_F5, "Build biasgen", "buildBiasgen");
//	LMacro_BindToHotKey(KEY_F4, "Reload biasgen macro", "reloadBiasgen");
	
}

void reloadBiasgen(){
	
}


}
biasgen_register ( );

/* 
$Log: biasgen.c,v $
Revision 1.3  2004/07/22 17:23:44  tobi
major upgrade: this version writes schematic netlist (not schamtic, just netlist) for compiled biasgen,
including all splitters and all individual biases.

Revision 1.2  2004/05/23 23:50:45  tobi
fixed to work correctly with Ledit version 11, which has obsoleted the Lcomp call LInstance_Set.
now using LC_Create2DArray to make the array of bias routing cells...

Revision 1.1  2004/05/16 15:43:46  tobi
split processes into subm sub-deep, and ams035
moved simulations into separate dir

Revision 1.11  2004/01/17 22:04:50  tobi
changed to incorporate bug fixes from subm-deep version done for florian and yann

Revision 1.10  2003/08/09 11:59:02  tobi
added license string to compiled layout.

Revision 1.9  2003/08/05 16:44:46  tobi
biasgen now builds bus for biases and labels it with bias names.

it also opens the text log file.

Revision 1.8  2003/08/03 09:16:30  tobi
started adding code to build bias bus.

Revision 1.7  2003/08/02 19:31:00  tobi
added splitter labels to the splitter bus

Revision 1.6  2003/08/01 15:44:13  tobi
finshed revision to reduce number of bus wires used to wire splitter
to biases.  now wires are used redundantly.

masterbias resistance Rx now printed and port made with max
resistance, which is best simple estimate of necessary resistance.

Revision 1.5  2003/07/31 21:56:58  tobi
started added code to remove redundant bus wires used by
multiple biases that share same splitter output.  not tested yet.

Revision 1.4  2003/07/28 15:04:29  tobi
built final(?) biasgen for tmpdiff10n with new values for bias currents.
this biasgen lvs'es OK.
routing built for tmpdiff10n in biasgenWithRouting cell in biasgen-tmpdiff10n.
LVS files added for biasgen.
schematic updated with corrected W/L for some bias transistors.

Revision 1.3  2003/07/28 06:40:07  tobi
modified biasgen for guesstimates of correct values for tmpdiff10n
and rebuilt the layout based on these estimates.
TODO: modify w/l of individual biases.

Revision 1.2  2003/07/23 14:59:24  tobi
LVS now ok, updated docs quite a bit.

Revision 1.4  2003/07/17 05:07:18  tobi
got array of routing cells to build and found out all state must be set explicitly and all vars need to be reset to correct value explicitly because they retain their values persistently between runs.
TODO, add connections in routing from bias splitters.

Revision 1.3  2003/07/14 23:16:29  tobi
added more code to biasgen.c to lay out current splitter, and started
to add termination.  next thing to do is to build bus.

Revision 1.2  2003/07/10 16:27:26  tobi
added a lot of code to biasgen.c to parse process parameters and to compute masterbias current and offchip resistors in weak and strong inversion.

changed layout to remove 1/2 lambda grid.  changed mouse grid back to 1 lambda grid.

added readme.txt to store implementation notes.

Revision 1.1  2003/07/10 03:14:05  tobi
initial version, only parses parameters from schematic

*/