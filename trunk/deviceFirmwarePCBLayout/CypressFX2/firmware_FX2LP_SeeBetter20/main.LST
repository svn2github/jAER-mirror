C51 COMPILER V7.50   MAIN                                                                  01/24/2012 15:59:54 PAGE 1   


C51 COMPILER V7.50, COMPILATION OF MODULE MAIN
OBJECT MODULE PLACED IN main.OBJ
COMPILER INVOKED BY: C:\Keil\C51\BIN\C51.EXE main.c BROWSE DEBUG OBJECTEXTEND

line level    source

   1          #pragma NOIV               // Do not generate interrupt vectors
   2          //-----------------------------------------------------------------------------
   3          //   File:      main.c
   4          //   Description: FX2LP firmware for the TCVS320/DVS320 retina chip   
   5          //
   6          // created: 1/2008, cloned from tmpdiff128 stereo board firmware
   7          // Revision: 0.01 
   8          // authors raphael berner, patrick lichtsteiner, tobi delbruck
   9          //
  10          //-----------------------------------------------------------------------------
  11          #include "lp.h"
  12          #include "lpregs.h"
  13          #include "syncdly.h"            // SYNCDELAY macro
  14          #include "biasgen.h" 
  15          #include "portsFX2.h"
  16          //#include "ports.h"
  17          //#include "micro.h"
  18          //#include "opcode.h"
  19          
  20          extern BOOL GotSUD;             // Received setup data flag
  21          //extern BOOL Sleep;
  22          extern BOOL Rwuen;
  23          extern BOOL Selfpwr;
  24          
  25          //BYTE Configuration;             // Current configuration
  26          //BYTE AlternateSetting;          // Alternate settings
  27          
  28          //WORD packetSize;
  29          
  30          // port E, not bit addressable - more bits are in biasgen.h
  31          #define CPLD_NOT_RESET                  0x80  // PE7 called nCPLDReset on host 
  32          #define DVS_nReset                              0x08  // PE3 called nChipReset on host, resets DVS array and AER logic
  33          #define BIAS_ADDR_SEL                   0x01  // PE0 called biasAddrSel selects the address shift register
  34          
  35          #define setArrayReset()         IOE=IOE&~DVS_nReset;    
  36          #define releaseArrayReset()     IOE=IOE|DVS_nReset;
  37          
  38          #define releaseAddrSR()         IOE=IOE|BIAS_ADDR_SEL;
  39          #define selectAddrSR()          IOE=IOE&~BIAS_ADDR_SEL; 
  40          
  41          #define BIAS_DIAG_SEL                   PA0
  42          #define RESET_TS                                PA7
  43          #define TIMESTAMP_MASTER                PA1
  44          #define RUN_CPLD                                PA3  // called runCpld on host
  45          
  46          #define RUN_ADC                 PC0  // called runAdc on host
  47          #define CPLD_SR_CLOCK   PC1
  48          #define CPLD_SR_LATCH   PC2
  49          #define CPLD_SR_BIT             PC3
  50          
  51          #define DB_Addr 1 // zero if only one byte address is needed for EEPROM, one if two byte address
  52          
  53          #define LEDmask         0x40  // PE6
  54          BOOL LEDon;
  55          
C51 COMPILER V7.50   MAIN                                                                  01/24/2012 15:59:54 PAGE 2   

  56          
  57          //#define MAX_NAME_LENGTH 8
  58          //#define STRING_ADDRESS (EEPROM_SIZE - MAX_NAME_LENGTH)
  59          
  60          #define MSG_TS_RESET 1
  61          
  62          // vendor requests
  63          #define VR_ENABLE_AE_IN 0xB3 // enable IN transfers
  64          #define VR_DISABLE_AE_IN 0xB4 // disable IN transfers
  65          #define VR_TRIGGER_ADVANCE_TRANSFER 0xB7 // trigger in packet commit (for host requests for early access t
             -o AE data) NOT IMPLEMENTED
  66          #define VR_RESETTIMESTAMPS 0xBb 
  67          //#define VR_SET_DEVICE_NAME 0xC2
  68          //#define VR_TIMESTAMP_TICK 0xC3
  69          #define VR_RESET_FIFOS 0xC4
  70          #define VR_DOWNLOAD_CPLD_CODE 0xC5 
  71          #define VR_READOUT_EEPROM 0xC9
  72          #define VR_IS_TS_MASTER 0xCB
  73          //#define VR_MISSED_EVENTS 0xCC
  74          #define VR_WRITE_CPLD_SR 0xCF
  75          //#define VR_RUN_ADC            0xCE
  76          
  77          #define VR_WRITE_CONFIG 0xB8 // write bytes out to SPI
  78                                          // the wLengthL field of SETUPDAT specifies the number of bytes to write out (max 64 per request)
  79                                          // the bytes are in the data packet
  80          //#define VR_SET_POWERDOWN 0xB9 // control powerDown. wValue controls the powerDown pin. Raise high to pow
             -er off, lower to power on.
  81          #define VR_EEPROM_BIASGEN_BYTES 0xBa // write bytes out to EEPROM for power on default
  82          
  83          #define VR_SETARRAYRESET 0xBc // set the state of the array reset which resets communication logic, and po
             -ssibly also holds pixels in reset
  84          #define VR_DOARRAYRESET 0xBd // toggle the array reset low long enough to reset all pixels and communicati
             -on logic 
  85          
  86          #define BIAS_FLASH_START 9 // start of bias value (this is where number of bytes is stored
  87          
  88          #define VR_UPLOAD               0xc0
  89          #define VR_DOWNLOAD             0x40
  90          #define VR_EEPROM               0xa2 // loads (uploads) EEPROM
  91          #define VR_RAM                  0xa3 // loads (uploads) external ram
  92          
  93          #define EP0BUFF_SIZE    0x40
  94          #define NUM_CONFIG_BITS_PRECEDING_BIAS_BYTES 40 
  95          // 10 muxes, each with 4 bits of config info. not a multiple of 8 so needs to be handled specially for SPI
             - interface.
  96          // we handle this by just padding the most signif nibble of the first byte written - this nibble will get 
             -shifted out.
  97          
  98          xdata unsigned int numBiasBytes; // number of bias bytes saved
  99          
 100          extern int g_iMovingAlgoIndex;      
 101          extern int g_iMovingDataIndex;
 102          
 103          BOOL JTAGinit;
 104          
 105          #define NUM_BIAS_BYTES 97 // 22 biases a 4 bytes, 1 Vdac a one byte plus 4 shifted source a 2 bytes 
 106          // (remember there are also 10 muxes a 4 bits, so the total bitstream is 102 bytes)
 107          // cDVSTest10 does not have the Vdac and the first four biases, but it does not matter if we shift in too 
             -many bits
 108          xdata unsigned char biasBytes[]={0x00,                                  // Vdac readout reference
 109                                                                           0x00,0x00,0x00,0x00,   // RObuffer
 110                                                                           0x00,0x00,0x00,0x00,   // refcurrent
C51 COMPILER V7.50   MAIN                                                                  01/24/2012 15:59:54 PAGE 3   

 111                                                                           0x00,0x00,0x00,0x00,   // ROcas
 112                                                                           0x00,0x00,0x00,0x00,   // ROgate
 113                                                                           0x00,0x00,0x00,0x00,   // follPad
 114                                                                           0x00,0x00,0x00,0x00,   // if_refr
 115                                                                           0x00,0x00,0x00,0x00,   // if_threshol
 116                                                                           0x00,0x00,0x00,0x00,   // AEpuY
 117                                                                           0x00,0x00,0x00,0x00,   // AEpuX
 118                                                                           0x00,0x00,0x00,0x00,   // AEReqEndPd
 119                                                                           0x00,0x00,0x00,0x00,   // AEReqPD
 120                                                                           0x00,0x00,0x00,0x00,   // refr
 121                                                                           0x00,0x00,0x00,0x00,   // fb
 122                                                                           0x00,0x00,0x00,0x00,   // pr
 123                                                                           0x00,0x00,0x00,0x00,   //pixInv
 124                                                                           0x00,0x00,0x00,0x00,   // pcas
 125                                                                           0x00,0x00,0x00,0x00,   // amp
 126                                                                           0x00,0x00,0x00,0x00,   // blue
 127                                                                           0x00,0x00,0x00,0x00,   // red
 128                                                                           0x00,0x00,0x00,0x00,   // off
 129                                                                           0x00,0x00,0x00,0x00,   // On
 130                                                                           0x00,0x00,0x00,0x00,   // diff
 131                                                                           0x00,0x00,             // SSNmid
 132                                                                           0x00,0x00,             // SSN
 133                                                                           0x00,0x00,  // SSPmid
 134                                                                           0x00,0x00}; // SSP
 135                                                                                   
 136          
 137          long cycleCounter;
 138          int i;
 139          
 140          #define I2C_Addr 0x51 //adress is 0101_0001
 141          
 142          
 143          
 144          void startMonitor(void);
 145          void stopMonitor(void);
 146          void configTimestampCounter(void);
 147          void toggleLED(void);
 148          
 149          void EEPROMWrite(WORD addr, BYTE length, BYTE xdata *buf);
 150          void EEPROMWriteBYTE(WORD addr, BYTE value);
 151          void EEPROMRead(WORD addr, BYTE length, BYTE xdata *buf);
 152          
 153          void downloadSerialNumberFromEEPROM(void);
 154          
 155          //-----------------------------------------------------------------------------
 156          // Task Dispatcher hooks
 157          //   The following hooks are called by the task dispatcher.
 158          //-----------------------------------------------------------------------------
 159          
 160          void TD_Init(void)              // Called once at startup
 161          {  
 162   1              // set the CPU clock to 48MHz
 163   1              CPUCS = ((CPUCS & ~bmCLKSPD) | bmCLKSPD1) ;
 164   1              CPUCS = CPUCS & 0xFD ; // 1111_1101
 165   1      
 166   1              // set the slave FIFO interface to 30MHz, slave fifo mode
 167   1              IFCONFIG = 0xA3; // 1010_0011
 168   1      
 169   1              // disable interrupts by the input pins and by timers and serial ports:
 170   1              IE &= 0x00; // 0000_0000 
 171   1      
 172   1              // disable interrupt pins 4, 5 and 6
C51 COMPILER V7.50   MAIN                                                                  01/24/2012 15:59:54 PAGE 4   

 173   1              EIE &= 0xE3; // 1110_0011;
 174   1      
 175   1              // Registers which require a synchronization delay, see section 15.14
 176   1              // FIFORESET        FIFOPINPOLAR
 177   1              // INPKTEND         OUTPKTEND
 178   1              // EPxBCH:L         REVCTL
 179   1              // GPIFTCB3         GPIFTCB2
 180   1              // GPIFTCB1         GPIFTCB0
 181   1              // EPxFIFOPFH:L     EPxAUTOINLENH:L
 182   1              // EPxFIFOCFG       EPxGPIFFLGSEL
 183   1              // PINFLAGSxx       EPxFIFOIRQ
 184   1              // EPxFIFOIE        GPIFIRQ
 185   1              // GPIFIE           GPIFADRH:L
 186   1              // UDMACRCH:L       EPxGPIFTRIG
 187   1              // GPIFTRIG
 188   1        
 189   1              //enable Port C and port E
 190   1              SYNCDELAY;
 191   1              PORTCCFG = 0x00;
 192   1              SYNCDELAY;
 193   1              PORTACFG = 0x00; // do not use interrupts 0 and 1
 194   1              SYNCDELAY;
 195   1              PORTECFG = 0x00;
 196   1      
 197   1              
 198   1              OEC = 0x0F; // 0000_1111 // JTAG, shift register stuff
 199   1              OEE = 0xFF; // 1111_1111 
 200   1              OEA = 0x89;  // 1000_1001 PA1: timestampMaster
 201   1      
 202   1              // 
 203   1              IOC = 0x00; 
 204   1              IOA = 0x00;
 205   1              IOE=  0x20;          //set BiasClock high 
 206   1              setPowerDownBit();      // tie biases to rail
 207   1      
 208   1              EP1OUTCFG = 0x00;                       // EP1OUT disabled
 209   1              SYNCDELAY;
 210   1              EP1INCFG = 0xA0;                        // EP1IN enabled, bulk
 211   1              SYNCDELAY;                   
 212   1              EP2CFG = 0x00;                          // EP2 disabled
 213   1              SYNCDELAY;                     
 214   1              EP4CFG = 0x00;                          // EP4 disabled
 215   1              SYNCDELAY;                 
 216   1              EP6CFG = 0xE0;                          // EP6 enabled, in bulk, quad buffered 
 217   1              SYNCDELAY;               
 218   1              EP8CFG = 0x00;                          // EP8 disabled
 219   1      
 220   1              SYNCDELAY;
 221   1              REVCTL= 0x03;
 222   1      
 223   1              EP6AUTOINLENH=0x02;
 224   1              EP6AUTOINLENL=0x00;
 225   1      
 226   1              SYNCDELAY;
 227   1              EP6FIFOCFG = 0x09 ; //0000_1001
 228   1      
 229   1              //set FIFO flag configuration: FlagB: EP6 full, flagC and D unused
 230   1              SYNCDELAY;
 231   1              PINFLAGSAB = 0xE8; // 1110_1000
 232   1      
 233   1              cycleCounter=0;
 234   1      
C51 COMPILER V7.50   MAIN                                                                  01/24/2012 15:59:54 PAGE 5   

 235   1              biasInit();     // init biasgen ports and pins                             
 236   1              EZUSB_InitI2C(); // init I2C to enable EEPROM read and write
 237   1      
 238   1              setArrayReset(); // keep pixels from spiking, reset all of them
 239   1              // pump powerdown to make sure masterbias is really started up
 240   1      /*      for(i=0;i<20;i++)
 241   1              {
 242   1                      setPowerDownBit();
 243   1                      //EZUSB_Delay1ms();
 244   1                      releasePowerDownBit();
 245   1                      //EZUSB_Delay1ms();
 246   1              }
 247   1              EZUSB_Delay(10); // ms delay after masterbias (re)startup
 248   1              for (i=0;i<NUM_BIAS_BYTES;i++)
 249   1              {
 250   1                      spiwritebyte(biasBytes[i]); // load hardcoded biases
 251   1              }
 252   1              latchNewBiases();       */
 253   1              
 254   1      
 255   1              
 256   1              IT0=1;          // make INT0# edge-sensitive
 257   1              EX0=0;          // disable INT0# (this interrupt was used to signal to the host to reset WrapAdd)
 258   1      
 259   1              IT1=1; // INT1# edge-sensitve
 260   1              EX1=0; // disable INT1#
 261   1      
 262   1              LEDon=FALSE;
 263   1         IOE |= CPLD_NOT_RESET; // take CPLD out of reset
 264   1      
 265   1      
 266   1      }
 267          
 268          void TD_Poll(void)              // Called repeatedly while the device is idle
 269          {       
 270   1      
 271   1              if(cycleCounter++>=100000){
 272   2      
 273   2                      toggleLED();
 274   2                      cycleCounter=0; // this makes a slow heartbeat on the LED to show firmware is running
 275   2              }               
 276   1      }
 277          
 278          void toggleLED(void)
 279          {
 280   1              if (LEDon==TRUE)
 281   1              {
 282   2                      IOE &= ~LEDmask;
 283   2                      LEDon=FALSE;
 284   2              }
 285   1              else
 286   1              {
 287   2                      IOE |= LEDmask;
 288   2                      LEDon=TRUE;
 289   2              }
 290   1      }
 291          
 292          /*void downloadSerialNumberFromEEPROM(void)
 293          {
 294                  BYTE i;
 295          
 296                  char *dscrRAM;
C51 COMPILER V7.50   MAIN                                                                  01/24/2012 15:59:54 PAGE 6   

 297                  BYTE xdata buf[MAX_NAME_LENGTH];
 298          
 299                  // get pointer to string descriptor 3
 300                  dscrRAM =  (char *)EZUSB_GetStringDscr(3);
 301          
 302                  // read string description from EEPROM
 303                  EEPROMRead(STRING_ADDRESS, MAX_NAME_LENGTH, buf);
 304                  
 305                  //write string description (serial number) to RAM
 306                  for (i=0;i<MAX_NAME_LENGTH;i++)
 307                  {
 308                          dscrRAM[2+i*2] = buf[i];
 309                  }
 310          }*/
 311          
 312          void startMonitor(void)
 313          {
 314   1              RUN_CPLD=1;
 315   1      
 316   1              releasePowerDownBit();
 317   1      //      IOE = IOE | DVS_nReset; //start dvs statemachines
 318   1       
 319   1      }
 320          
 321          void stopMonitor(void)
 322          {
 323   1      
 324   1              // force last paket
 325   1              
 326   1      //      EP6FIFOCFG = 0x01; //0000_0001 disable auto-in
 327   1      //      SYNCDELAY;
 328   1      
 329   1      //      if(EP6FIFOFLGS==0x00)
 330   1      //      { // if buffer available
 331   1      //      INPKTEND=0x06; // force in paket
 332   1      //              SYNCDELAY;
 333   1      //      }
 334   1      
 335   1              // reset fifo   
 336   1              FIFORESET = 0x80;
 337   1              SYNCDELAY;
 338   1              FIFORESET = 0x06;
 339   1              SYNCDELAY;
 340   1              FIFORESET = 0x00;
 341   1              SYNCDELAY;
 342   1      
 343   1              EP6FIFOCFG =0x09;  //0000_1001 set back to autoin
 344   1              SYNCDELAY;
 345   1      
 346   1              RUN_CPLD=0;
 347   1      
 348   1      //      IOE &= ~DVS_nReset;
 349   1      }
 350          
 351          // writes the byte in big endian order, e.g. from msb to lsb
 352          void CPLDwriteByte(BYTE dat)
 353          {
 354   1              BYTE i=0;
 355   1              BYTE mask=0x80;
 356   1      
 357   1              CPLD_SR_CLOCK = 0;
 358   1              for (i=0; i<8;i++)
C51 COMPILER V7.50   MAIN                                                                  01/24/2012 15:59:54 PAGE 7   

 359   1              {
 360   2                      CPLD_SR_BIT= dat & mask;
 361   2                      CPLD_SR_CLOCK = 1;
 362   2                      CPLD_SR_CLOCK = 0;
 363   2                      mask= mask >> 1;        
 364   2              }
 365   1      }
 366          
 367          void EEPROMWriteByte(WORD addr, BYTE value)
 368          {
 369   1              BYTE            i = 0;
 370   1              BYTE xdata      ee_str[3];
 371   1              if(DB_Addr)
 372   1                      ee_str[i++] = MSB(addr); // if 16 bit, we need 2-byte address and 1 byte data
 373   1      
 374   1              ee_str[i++] = LSB(addr);
 375   1              ee_str[i++] = value;
 376   1      
 377   1              IOE |= LEDmask;
 378   1              EZUSB_WriteI2C(I2C_Addr, i, ee_str);
 379   1              IOE &= ~LEDmask;
 380   1              LEDon=FALSE;
 381   1          EZUSB_WaitForEEPROMWrite(I2C_Addr);
 382   1      }
 383          
 384          void EEPROMWrite(WORD addr, BYTE length, BYTE xdata *buf)
 385          {
 386   1              BYTE    i;
 387   1              for(i=0;i<length;++i)
 388   1                      EEPROMWriteByte(addr++,buf[i]);
 389   1      }
 390          
 391          void EEPROMRead(WORD addr, BYTE length, BYTE xdata *buf)
 392          {
 393   1              BYTE            i = 0;
 394   1              BYTE            j = 0;
 395   1              BYTE xdata      ee_str[2];
 396   1      
 397   1              if(DB_Addr)
 398   1                      ee_str[i++] = MSB(addr);
 399   1      
 400   1              ee_str[i++] = LSB(addr);
 401   1      
 402   1              EZUSB_WriteI2C(I2C_Addr, i, ee_str);
 403   1      
 404   1              for(j=0; j < length; j++)
 405   1                      *(buf+j) = 0xcd;
 406   1      
 407   1              EZUSB_ReadI2C(I2C_Addr, length, buf);
 408   1      }
 409          
 410          
 411          BOOL TD_Suspend(void)          // Called before the device goes into suspend mode
 412          {
 413   1        // reset CPLD
 414   1        IOE &= ~CPLD_NOT_RESET;  
 415   1        IOE &= ~DVS_nReset; 
 416   1      
 417   1        return(TRUE);
 418   1      }
 419          
 420          BOOL TD_Resume(void)          // Called after the device resumes
C51 COMPILER V7.50   MAIN                                                                  01/24/2012 15:59:54 PAGE 8   

 421          {
 422   1      
 423   1         IOE |= CPLD_NOT_RESET;
 424   1         IOE |= DVS_nReset;
 425   1      
 426   1         return(TRUE);
 427   1      }
 428          
 429          //-----------------------------------------------------------------------------
 430          // Device Request hooks
 431          //   The following hooks are called by the end point 0 device request parser.
 432          //-----------------------------------------------------------------------------
 433          
 434          /*BOOL DR_GetDescriptor(void)
 435          {
 436             return(TRUE);
 437          }
 438          
 439          BOOL DR_SetConfiguration(void)   // Called when a Set Configuration command is received
 440          {
 441          //   Configuration = SETUPDAT[2];
 442             return(TRUE);            // Handled by user code
 443          }*/
 444          
 445          BOOL DR_GetConfiguration(void)   // Called when a Get Configuration command is received
 446          {
 447   1         EP0BUF[0] = 0x00;//Configuration;
 448   1         EP0BCH = 0;
 449   1         EP0BCL = 1;
 450   1         return(TRUE);            // Handled by user code
 451   1      }
 452          
 453          /*BOOL DR_SetInterface(void)       // Called when a Set Interface command is received
 454          {
 455          //   AlternateSetting = SETUPDAT[2];
 456             return(TRUE);            // Handled by user code
 457          }*/
 458          
 459          BOOL DR_GetInterface(void)       // Called when a Set Interface command is received
 460          {
 461   1         EP0BUF[0] = 0x00;//AlternateSetting;
 462   1         EP0BCH = 0;
 463   1         EP0BCL = 1;
 464   1         return(TRUE);            // Handled by user code
 465   1      }
 466          
 467          /*BOOL DR_GetStatus(void)
 468          {
 469             return(TRUE);
 470          }
 471          
 472          BOOL DR_ClearFeature(void)
 473          {
 474             return(TRUE);
 475          }
 476          
 477          BOOL DR_SetFeature(void)
 478          {
 479             return(TRUE);
 480          }*/
 481          
 482          // the SETUPDAT array has the following 8 elements (see FX2 TRM Section 2.3)
C51 COMPILER V7.50   MAIN                                                                  01/24/2012 15:59:54 PAGE 9   

 483          //SETUPDAT[0] VendorRequest 0x40 for OUT type, 0xC0 for IN type
 484          //SETUPDAT[1] The actual vendor request (e.g. VR_ENABLE_AE_IN below)
 485          //SETUPDAT[2] wValueL 16 bit value LSB
 486          //         3  wValueH MSB
 487          //         4  wIndexL 16 bit field, varies according to request
 488          //         5  wIndexH
 489          //         6  wLengthL Number of bytes to transfer if there is a data phase
 490          //         7  wLengthH
 491          BYTE xsvfReturn;
 492          
 493          BOOL DR_VendorCmnd(void)
 494          {       
 495   1              WORD value; 
 496   1              WORD len,ind, bc; // xdata used here to conserve data ram; if not EEPROM writes don't work anymore
 497   1      
 498   1              WORD addr; // xdata used here to conserve data ram; if not EEPROM writes don't work anymore
 499   1              WORD i;
 500   1              bit oldbit;
 501   1      //      char *dscrRAM;
 502   1      //      unsigned char xdata JTAGdata[400];
 503   1      
 504   1              // we don't actually process the command here, we process it in the main loop
 505   1              // here we just do the handshaking and ensure if it is a command that is implemented
 506   1              switch (SETUPDAT[1]){
 507   2                      case VR_ENABLE_AE_IN: // enable IN transfers
 508   2                              {
 509   3                                      startMonitor();
 510   3                                      break;  // handshake phase triggered below
 511   3                              }
 512   2                      case VR_DISABLE_AE_IN: // disable IN transfers
 513   2                              {
 514   3                                      stopMonitor();
 515   3                                              break;
 516   3                              }
 517   2                      case VR_RESET_FIFOS: // reset in and out fifo
 518   2                              {
 519   3                                      SYNCDELAY;
 520   3                                      EP6FIFOCFG = 0x01; //0000_0001  disable auto-in
 521   3                                      SYNCDELAY;
 522   3                                      FIFORESET = 0x80;
 523   3                                      SYNCDELAY;
 524   3                                      FIFORESET = 0x06;
 525   3                                      SYNCDELAY;
 526   3                                      FIFORESET = 0x00;
 527   3      
 528   3      
 529   3                                      SYNCDELAY;
 530   3                                      EP6FIFOCFG = 0x09 ; //0000_1001 reenable auto-in
 531   3                                      break;
 532   3                              }
 533   2              /*      case VR_DOWNLOAD_CPLD_CODE:
 534   2                              {
 535   2                              if (SETUPDAT[0]==VR_DOWNLOAD) {
 536   2                      
 537   2                                      if (SETUPDAT[4]) {
 538   2                                              xsvfReturn = ispEntryPoint();
 539   2                                      } else
 540   2                                      {
 541   2                                              addr = SETUPDAT[2];             // Get address and length
 542   2                                              addr |= SETUPDAT[3] << 8;
 543   2                                              len = SETUPDAT[6];
 544   2                                              len |= SETUPDAT[7] << 8;
C51 COMPILER V7.50   MAIN                                                                  01/24/2012 15:59:54 PAGE 10  

 545   2              
 546   2                                              // first download programming data to EEPROM
 547   2                                              addr= addr + EEPROM_CPLDCODE_START; 
 548   2                                              while(len)                                      // Move new data through EP0OUT 
 549   2                                              {                                                       // one packet at a time.
 550   2                                                      // Arm endpoint - do it here to clear (after sud avail)
 551   2                                                      EP0BCH = 0;
 552   2                                                      EP0BCL = 0; // Clear bytecount to allow new data in; also stops NAKing
 553   2              
 554   2                                                      while(EP0CS & bmEPBUSY);
 555   2              
 556   2                                                      bc = EP0BCL; // Get the new bytecount
 557   2              
 558   2                                                      for(i=0; i<bc; i++)
 559   2                                                                      EEPROMWriteBYTE(addr+i, EP0BUF[i]);                                                     
 560   2              
 561   2                                                      addr += bc;
 562   2                                                      len -= bc;
 563   2                                              }
 564   2                                      }
 565   2      
 566   2                                      break;
 567   2                              }
 568   2                              else //case VR_XSVF_ERROR_CODE:
 569   2                              {
 570   2                                       // program CPLD when host ask
 571   2      
 572   2                                      EP0BUF[0] = SETUPDAT[1];
 573   2                                      EP0BUF[1]= xsvfReturn;
 574   2      
 575   2                                      EP0BUF[2] = 0xFF & (g_iMovingAlgoIndex >> 24);
 576   2                              EP0BUF[3] = 0xFF & (g_iMovingAlgoIndex >> 16);
 577   2                                      EP0BUF[4] = 0xFF & (g_iMovingAlgoIndex >> 8);
 578   2                                      EP0BUF[5] = 0xFF & (g_iMovingAlgoIndex);
 579   2      
 580   2                                      EP0BUF[6] = 0xFF & (g_iMovingDataIndex >> 24);
 581   2                              EP0BUF[7] = 0xFF & (g_iMovingDataIndex >> 16);
 582   2                                      EP0BUF[8] = 0xFF & (g_iMovingDataIndex >> 8);
 583   2                                      EP0BUF[9] = 0xFF & (g_iMovingDataIndex);
 584   2      
 585   2                                      EP0BCH = 0;
 586   2                                      EP0BCL = 10;
 587   2                                      EP0CS |= bmHSNAK;
 588   2      
 589   2                                      return(FALSE);
 590   2                              } 
 591   2                              }*/
 592   2              /*      case VR_SET_DEVICE_NAME:
 593   2                              {
 594   2                                      *EP0BUF = SETUPDAT[1];
 595   2                                      EP0BCH = 0;
 596   2                                      EP0BCL = 1;
 597   2                                      EP0CS |= bmHSNAK;
 598   2      
 599   2                                      while(EP0CS & bmEPBUSY); //wait for the data packet to arrive
 600   2      
 601   2                                      dscrRAM = (char*)EZUSB_GetStringDscr(3); // get address of serial number descriptor-string in RAM
 602   2      
 603   2                                      if (EP0BCL > MAX_NAME_LENGTH)
 604   2                                      {
 605   2                                              len=MAX_NAME_LENGTH;
 606   2                                      } else 
C51 COMPILER V7.50   MAIN                                                                  01/24/2012 15:59:54 PAGE 11  

 607   2                                      {
 608   2                                              len=EP0BCL;
 609   2                                      }
 610   2              
 611   2                                      for (i=0;i<len;i++)
 612   2                                      {
 613   2                                              EEPROMWriteBYTE(STRING_ADDRESS+i, EP0BUF[i]); // write string to EEPROM
 614   2                                              dscrRAM[2+i*2] = EP0BUF[i]; // write string to RAM
 615   2                                      }
 616   2      
 617   2                                      for (i=len; i<MAX_NAME_LENGTH; i++) // fill the rest with stop characters
 618   2                                      {
 619   2                                              EEPROMWriteBYTE(STRING_ADDRESS+i, ' '); // write string to EEPROM                               
 620   2                                              dscrRAM[2+i*2] = ' '; // write string to RAM
 621   2                                      }
 622   2      
 623   2                                      EP0BCH = 0;
 624   2                                      EP0BCL = 0;
 625   2      
 626   2                                      return(FALSE);
 627   2                              }*/             
 628   2                      case VR_RESETTIMESTAMPS:
 629   2                              {
 630   3                                      RESET_TS=1; // assert RESET_TS pin for one instruction cycle (four clock cycles)
 631   3                                      RESET_TS=0;
 632   3      
 633   3                                      // reset dvs statemachines
 634   3      //                              IOE= IOE & ~DVS_nReset;
 635   3      //                              _nop_();
 636   3      //                              _nop_();
 637   3      //                              _nop_();
 638   3      //                              IOE = IOE | DVS_nReset; //start dvs statemachines
 639   3      
 640   3                                      break;
 641   3                              }
 642   2                      case VR_WRITE_CONFIG: // write bytes to SPI interface and also handles other configuration of board like
             - CPLD and port bits on FX2
 643   2                      case VR_EEPROM_BIASGEN_BYTES: // falls through and actual command is tested below
 644   2                              {
 645   3                                      // the value bytes are the specific config command
 646   3                                      // the index bytes are the arguments
 647   3                                      // more data comes in the setupdat
 648   3                                      
 649   3                                      SYNCDELAY;
 650   3                                      value = SETUPDAT[2];            // Get request value
 651   3                                      value |= SETUPDAT[3] << 8;      // data comes little endian
 652   3                                      ind = SETUPDAT[4];                      // Get index
 653   3                                      ind |= SETUPDAT[5] << 8;
 654   3                                      len = SETUPDAT[6];              // length for data phase
 655   3                                      len |= SETUPDAT[7] << 8;
 656   3                                      switch(value&0xFF){ // take LSB for specific setup command 
 657   4       
 658   4      // from SeeBetter.Biasgen inner class 
 659   4      #define CMD_IPOT  1
 660   4      #define CMD_AIPOT  2
 661   4      #define CMD_SCANNER  3
 662   4      #define CMD_CHIP  4
 663   4      #define CMD_SETBIT  5
 664   4      #define CMD_CPLDCONFIG 8
 665   4      
 666   4                                      case CMD_IPOT:
 667   4      
C51 COMPILER V7.50   MAIN                                                                  01/24/2012 15:59:54 PAGE 12  

 668   4                                              numBiasBytes=len;
 669   4                                              while(len){     // Move new data through EP0OUT, one packet at a time, 
 670   5                                                      // eventually will get len down to zero by bc=64,64,15 (for example)
 671   5                                                      // Arm endpoint - do it here to clear (after sud avail)
 672   5                                                      EP0BCH = 0;
 673   5                                                      EP0BCL = 0; // Clear bytecount to allow new data in; also stops NAKing
 674   5                                                      SYNCDELAY;
 675   5                                                      while(EP0CS & bmEPBUSY);  // spin here until data arrives
 676   5                                                      bc = EP0BCL; // Get the new bytecount
 677   5                                                      for(i=0; i<bc; i++){
 678   6                                                              spiwritebyte(EP0BUF[i]); // writes out the bits big endian (msb to lsb)
 679   6                                                      }
 680   5      //                                              value += bc;    // inc eeprom value to write to, in case that's what we're doing
 681   5                                                      len -= bc; // dec total byte count
 682   5                                              }
 683   4                                              latchNewBiases();
 684   4                                              break;
 685   4      
 686   4                                      case CMD_AIPOT:
 687   4                                              
 688   4                                              EP0BCH = 0;
 689   4                                              EP0BCL = 0; // Clear bytecount to allow new data in; also stops NAKing
 690   4                                              BIAS_DIAG_SEL = 0;
 691   4                                              selectAddrSR();
 692   4                                              SYNCDELAY;
 693   4                                              while(EP0CS & bmEPBUSY);  // spin here until data arrives
 694   4                                              bc = EP0BCL; // Get the new bytecount
 695   4                                              spiwritebyte(EP0BUF[0]); // write bias address
 696   4                                              latchNewBiases();
 697   4                                              releaseAddrSR();
 698   4                                              //two data bytes per bias
 699   4                                              for(i=1; i<3; i++){
 700   5                                                      spiwritebyte(EP0BUF[i]); // writes out the bits big endian (msb to lsb)
 701   5                                              }
 702   4                                              latchNewBiases();
 703   4                                              break;
 704   4      
 705   4                                              
 706   4                                      case CMD_SETBIT:
 707   4                                              EP0BCH = 0;
 708   4                                              EP0BCL = 0; // Clear bytecount to allow new data in; also stops NAKing
 709   4                                              SYNCDELAY;
 710   4                                              while(EP0CS & bmEPBUSY);  // spin here until data arrives
 711   4                                              // sends value=CMD_SETBIT, index=portbit with (port(b=0,d=1,e=2)<<8)|bitmask(e.g. 00001000) in MSB/LS
             -B, byte[0]=value (1,0)
 712   4                                              // also if button is tristable type in GUI, then byte[0] has tristate in bit1
 713   4                                              {
 714   5                                                      bit bitval=(EP0BUF[0]&1); // 1=set, 0=clear
 715   5                                                      bit tristate=(EP0BUF[0]&2?1:0); // 1=tristate, 0=drive
 716   5                                                      unsigned char bitmask=SETUPDAT[4]; // bitmaskit mask, LSB of ind
 717   5                                                      switch(SETUPDAT[5]){ // this is port, MSB of ind
 718   6                                                              case 0: // port a
 719   6                                                                      if(bitval) IOA|=bitmask; else IOA&= ~bitmask;
 720   6                                                                      if(tristate) OEA&= ~bitmask; else OEA|=bitmask; 
 721   6                                                              break;
 722   6                                                              case 1: // port c
 723   6                                                                      if(bitval) IOC|=bitmask; else IOC&= ~bitmask;
 724   6                                                                      if(tristate) OEC&= ~bitmask; else OEC|=bitmask; 
 725   6                                                              break;
 726   6                                                              case 2: // port d
 727   6                                                                      if(bitval) IOD|=bitmask; else IOD&= ~bitmask;
 728   6                                                                      if(tristate) OED&= ~bitmask; else OED|=bitmask; 
C51 COMPILER V7.50   MAIN                                                                  01/24/2012 15:59:54 PAGE 13  

 729   6                                                              break;
 730   6                                                              case 3: // port e
 731   6                                                                      if(bitval) IOE|=bitmask; else IOE&= ~bitmask;
 732   6                                                                      if(tristate) OEE&= ~bitmask; else OEE|=bitmask; 
 733   6                                                              break;
 734   6                                                              default:
 735   6                                                                      return TRUE; // error
 736   6                                                      }
 737   5                                              }
 738   4                                              break;
 739   4                                      case CMD_SCANNER:
 740   4                                              // scanner is controlled by CPLD entirely, we just write the correct bits to the CPLD config SR.  Thi
             -s legacy cmd now returns a stall.
 741   4                                              return TRUE;
 742   4                                              break;
 743   4      
 744   4                                      case CMD_CHIP:
 745   4                                              // send diagnose SR values to chip
 746   4                                              BIAS_DIAG_SEL = 1;
 747   4                                              numBiasBytes=len;
 748   4                                              while(len){     // Move new data through EP0OUT, one packet at a time, 
 749   5                                                      // eventually will get len down to zero by bc=64,64,15 (for example)
 750   5                                                      // Arm endpoint - do it here to clear (after sud avail)
 751   5                                                      EP0BCH = 0;
 752   5                                                      EP0BCL = 0; // Clear bytecount to allow new data in; also stops NAKing
 753   5                                                      SYNCDELAY;
 754   5                                                      while(EP0CS & bmEPBUSY);  // spin here until data arrives
 755   5                                                      bc = EP0BCL; // Get the new bytecount
 756   5                                                      for(i=0; i<bc; i++){
 757   6                                                              spiwritebyte(EP0BUF[i]); // writes out the bits big endian (msb to lsb)
 758   6                                                      }
 759   5      //                                              value += bc;    // inc eeprom value to write to, in case that's what we're doing
 760   5                                                      len -= bc; // dec total byte count
 761   5                                              }
 762   4                                              latchNewBiases();
 763   4                                              BIAS_DIAG_SEL = 0;
 764   4                                              break;
 765   4      
 766   4                                      case CMD_CPLDCONFIG: // send bit string to CPLD configuration shift register (new feature on cochleaAM
             -S1c board/cpld/firmware)
 767   4                                                      // len holds the number of bytes to send
 768   4                                                      // the bytes should be sent from host so that the first byte
 769   4                                                      // holds the MSB, i.e., the bytes should be sent big endian from the host.
 770   4                                                      // i.e., the msb of the first byte should be the biggest-numbered bit
 771   4                                                      // and the lsb of the last byte is bit 0 as specified in the CPLD HDL configuration.
 772   4                                                      // Each byte here is written out big endian, from msb to lsb.
 773   4                                                      // Only integral bytes are written, so if the number of bytes is not a multiple of 8, 
 774   4                                                      // then the first byte written (the MSB) should be left padded so that the msb ends up at the corret
 775   4                                                      // position.
 776   4                                              
 777   4                                              oldbit=RUN_ADC;
 778   4                                              RUN_ADC=0;
 779   4                                              while(len){                                     // Move new data through EP0OUT, one packet at a time
 780   5                                                      // Arm endpoint - do it here to clear (after sud avail)
 781   5                                                      EP0BCH = 0;
 782   5                                                      EP0BCL = 0; // Clear bytecount to allow new data in; also stops NAKing
 783   5                                                      while(EP0CS & bmEPBUSY);  // spin here until data arrives
 784   5                                                      bc = EP0BCL; // Get the new bytecount
 785   5                                              
 786   5                                                      for(i=0; i<bc; i++){
 787   6                                                              CPLDwriteByte(EP0BUF[i]); // writes the byte in big endian order, e.g. from msb to lsb
 788   6                                                      }
C51 COMPILER V7.50   MAIN                                                                  01/24/2012 15:59:54 PAGE 14  

 789   5                                                      len -= bc; // dec total byte count
 790   5                                              }
 791   4                              
 792   4                                              CPLD_SR_LATCH=0;
 793   4                                              CPLD_SR_LATCH=1;
 794   4                                              RUN_ADC=oldbit;
 795   4              
 796   4                                                      break; // very important, otherwise get stall
 797   4                                      default:
 798   4                                              return(TRUE);  // don't recognize command, generate stall
 799   4                                      } // end of subcmd switch
 800   3      
 801   3                                      EP0BCH = 0;
 802   3                                      EP0BCL = 0;                   // Arm endpoint with 0 byte to transfer
 803   3                                      toggleLED();
 804   3                                      return(FALSE); // very important, otherwise get stall
 805   3                              } // end of subcmds to config cmds
 806   2      /* commented out because these VR's are replaced by direct bit control from host side via general interfac
             -e to ports
 807   2              case VR_WRITE_CPLD_SR: // write bytes to SPI interface
 808   2                              {
 809   2                                      SYNCDELAY;
 810   2                                      len = SETUPDAT[6];
 811   2                                      len |= SETUPDAT[7] << 8;
 812   2                                      oldbit=RUN_ADC;
 813   2                                      RUN_ADC=0;
 814   2                                      while(len){                                     // Move new data through EP0OUT, one packet at a time
 815   2                                              // Arm endpoint - do it here to clear (after sud avail)
 816   2                                              EP0BCH = 0;
 817   2                                              EP0BCL = 0; // Clear bytecount to allow new data in; also stops NAKing
 818   2                                              while(EP0CS & bmEPBUSY);  // spin here until data arrives
 819   2                                              bc = EP0BCL; // Get the new bytecount
 820   2                                      
 821   2                                              for(i=0; i<bc; i++){
 822   2                                                      CPLDwriteByte(EP0BUF[i]);                                       
 823   2                                              }
 824   2                                      
 825   2                                              len -= bc; // dec total byte count
 826   2                                      }
 827   2                      
 828   2                                      CPLD_SR_LATCH=0;
 829   2                                      CPLD_SR_LATCH=1;
 830   2      
 831   2                                      EP0BCH = 0;
 832   2                                      EP0BCL = 0;                   // Arm endpoint with 0 byte to transfer
 833   2                                      toggleLED();
 834   2                                      return(FALSE); // very important, otherwise get stall
 835   2                              }
 836   2                      case VR_RUN_ADC:
 837   2                              {       
 838   2                                      if (SETUPDAT[2])
 839   2                                      {
 840   2                                              RUN_ADC=1;
 841   2                                      } else 
 842   2                                      {
 843   2                                              RUN_ADC=0;
 844   2                                      }
 845   2                                      break;
 846   2                              }
 847   2                      case VR_SET_POWERDOWN: // control powerDown output bit
 848   2                              {
 849   2                                      if (SETUPDAT[2])
C51 COMPILER V7.50   MAIN                                                                  01/24/2012 15:59:54 PAGE 15  

 850   2                                      {
 851   2                                              setPowerDownBit();
 852   2                                      } else 
 853   2                                      {
 854   2                                              releasePowerDownBit();
 855   2                                      }
 856   2                                      break;
 857   2      
 858   2                              }
 859   2      
 860   2      */
 861   2                      case VR_SETARRAYRESET: // set array reset, based on lsb of argument. This also resets the AER logic.
 862   2                              {
 863   3                                      if (SETUPDAT[2]&0x01)
 864   3                                      {
 865   4                                              IOE &= ~DVS_nReset;
 866   4                                      } else
 867   3                                      {
 868   4                                              IOE |= DVS_nReset;
 869   4                                      }
 870   3                              
 871   3                                      break;
 872   3                              }
 873   2      
 874   2                      case VR_DOARRAYRESET: // reset array for fixed reset time
 875   2                              {
 876   3                                      IOE &= ~DVS_nReset;
 877   3                                      _nop_();
 878   3                                      _nop_();
 879   3                                      _nop_();
 880   3                                      _nop_();
 881   3                                      _nop_();
 882   3                                      _nop_();
 883   3                                      _nop_();
 884   3                                      _nop_();        // a few us
 885   3                                      _nop_();
 886   3                                      _nop_();
 887   3                                      _nop_();
 888   3                                      _nop_();
 889   3                                      _nop_();
 890   3                                      _nop_();
 891   3                                      IOE |= DVS_nReset;
 892   3                                      break;
 893   3                              }
 894   2              /*      case VR_IS_TS_MASTER:
 895   2                              {
 896   2                                      EP0BUF[0] = SETUPDAT[1];
 897   2                                      EP0BUF[1]= TIMESTAMP_MASTER;
 898   2                                      EP0BCH = 0;
 899   2                                      EP0BCL = 2;
 900   2                                      EP0CS |= bmHSNAK;
 901   2      
 902   2                                      return(FALSE);
 903   2                              }*/
 904   2                      case VR_RAM:
 905   2                      case VR_EEPROM:
 906   2                      {
 907   3                              addr = SETUPDAT[2];             // Get address and length
 908   3                              addr |= SETUPDAT[3] << 8;
 909   3                              len = SETUPDAT[6];
 910   3                              len |= SETUPDAT[7] << 8;
 911   3                              // Is this an upload command ?
C51 COMPILER V7.50   MAIN                                                                  01/24/2012 15:59:54 PAGE 16  

 912   3                              if(SETUPDAT[0] == VR_UPLOAD)  // this is automatically defined on host from direction of vendor request
 913   3                              {
 914   4                                      while(len)                                      // Move requested data through EP0IN 
 915   4                                      {                                                       // one packet at a time.
 916   5      
 917   5                                              while(EP0CS & bmEPBUSY);
 918   5      
 919   5                                              if(len < EP0BUFF_SIZE)
 920   5                                                      bc = len;
 921   5                                              else
 922   5                                                      bc = EP0BUFF_SIZE;
 923   5      
 924   5                                              // Is this a RAM upload ?
 925   5                                              if(SETUPDAT[1] == VR_RAM)
 926   5                                              {
 927   6                                                      for(i=0; i<bc; i++)
 928   6                                                              *(EP0BUF+i) = *((BYTE xdata *)addr+i);
 929   6                                              }
 930   5                                              else
 931   5                                              {
 932   6                                                      for(i=0; i<bc; i++)
 933   6                                                              *(EP0BUF+i) = 0xcd;
 934   6                                                      EEPROMRead(addr,(WORD)bc,(WORD)EP0BUF);
 935   6                                              }
 936   5      
 937   5                                              EP0BCH = 0;
 938   5                                              EP0BCL = (BYTE)bc; // Arm endpoint with # bytes to transfer
 939   5      
 940   5                                              addr += bc;
 941   5                                              len -= bc;
 942   5      
 943   5                                      }
 944   4                              }
 945   3                              // Is this a download command ?
 946   3                              else if(SETUPDAT[0] == VR_DOWNLOAD) // this is automatically defined on host from direction of vendor r
             -equest
 947   3                              {
 948   4                                      while(len)                                      // Move new data through EP0OUT 
 949   4                                      {                                                       // one packet at a time.
 950   5                                              // Arm endpoint - do it here to clear (after sud avail)
 951   5                                              EP0BCH = 0;
 952   5                                              EP0BCL = 0; // Clear bytecount to allow new data in; also stops NAKing
 953   5      
 954   5                                              while(EP0CS & bmEPBUSY);
 955   5      
 956   5                                              bc = EP0BCL; // Get the new bytecount
 957   5      
 958   5                                              // Is this a RAM download ?
 959   5                                              if(SETUPDAT[1] == VR_RAM)
 960   5                                              {
 961   6                                                      for(i=0; i<bc; i++)
 962   6                                                              *((BYTE xdata *)addr+i) = *(EP0BUF+i);
 963   6                                              }
 964   5                                              else
 965   5                                                      EEPROMWrite(addr,bc,(WORD)EP0BUF);
 966   5      
 967   5                                              addr += bc;
 968   5                                              len -= bc;
 969   5                                      }
 970   4                              }
 971   3                              return(FALSE);
 972   3                      }
C51 COMPILER V7.50   MAIN                                                                  01/24/2012 15:59:54 PAGE 17  

 973   2                      default:
 974   2                      { // we received an invalid command
 975   3                              return(TRUE);
 976   3                      }
 977   2              }
 978   1      
 979   1              *EP0BUF = SETUPDAT[1];
 980   1              EP0BCH = 0;
 981   1              EP0BCL = 1;
 982   1              EP0CS |= bmHSNAK;
 983   1      
 984   1              return(FALSE);
 985   1      }
 986          
 987          // no interrupts are used for TCVS320
 988          // RESET HOST TIMESTAMP INTERRUPT not used
 989          /*void ISR_TSReset(void) interrupt 3 {
 990                  LED=0;
 991                  
 992                  SYNCDELAY; // reset fifos to delete events with the old timestamps
 993                  FIFORESET = 0x80;
 994                  SYNCDELAY;
 995                  FIFORESET = 0x06;
 996                  SYNCDELAY;
 997                  FIFORESET = 0x00;
 998          
 999                  SYNCDELAY;
1000                  EP6FIFOCFG = 0x09 ; //0000_1001
1001          
1002          
1003                  if (EP1INCS!=0x02)
1004                  {
1005                          EP1INBUF[0]=MSG_TS_RESET;
1006                          SYNCDELAY;
1007                          EP1INBC=1;
1008                          SYNCDELAY;
1009                          IE0=0; // clear interrupt
1010                          EX0=1; // enable INT0# external interrupt
1011                          LED=1;
1012                  }
1013          }
1014          
1015          */
1016          
1017          //-----------------------------------------------------------------------------
1018          // USB Interrupt Handlers
1019          //   The following functions are called by the USB interrupt jump table.
1020          //-----------------------------------------------------------------------------
1021          
1022          // Setup Data Available Interrupt Handler
1023          void ISR_Sudav(void) interrupt 0
1024          {
1025   1         GotSUD = TRUE;            // Set flag
1026   1         EZUSB_IRQ_CLEAR();
1027   1         USBIRQ = bmSUDAV;         // Clear SUDAV IRQ
1028   1      }
1029          
1030          // Setup Token Interrupt Handler
1031          void ISR_Sutok(void) interrupt 0
1032          {
1033   1         EZUSB_IRQ_CLEAR();
1034   1         USBIRQ = bmSUTOK;         // Clear SUTOK IRQ
C51 COMPILER V7.50   MAIN                                                                  01/24/2012 15:59:54 PAGE 18  

1035   1      }
1036          
1037          void ISR_Sof(void) interrupt 0
1038          {
1039   1         EZUSB_IRQ_CLEAR();
1040   1         USBIRQ = bmSOF;            // Clear SOF IRQ
1041   1      }
1042          
1043          void ISR_Ures(void) interrupt 0
1044          {
1045   1         if (EZUSB_HIGHSPEED())
1046   1         {
1047   2            pConfigDscr = pHighSpeedConfigDscr;
1048   2            pOtherConfigDscr = pFullSpeedConfigDscr;
1049   2          //  packetSize = 512;
1050   2      
1051   2         }
1052   1         else
1053   1         {
1054   2            pConfigDscr = pFullSpeedConfigDscr;
1055   2            pOtherConfigDscr = pHighSpeedConfigDscr;
1056   2          //  packetSize = 64;
1057   2         }
1058   1         
1059   1         EZUSB_IRQ_CLEAR();
1060   1         USBIRQ = bmURES;         // Clear URES IRQ
1061   1      }
1062          
1063          void ISR_Susp(void) interrupt 0
1064          {
1065   1      //   Sleep = TRUE;
1066   1      //   EZUSB_IRQ_CLEAR();
1067   1      //   USBIRQ = bmSUSP;
1068   1      }
1069          
1070          void ISR_Highspeed(void) interrupt 0
1071          {
1072   1         if (EZUSB_HIGHSPEED())
1073   1         {
1074   2            pConfigDscr = pHighSpeedConfigDscr;
1075   2            pOtherConfigDscr = pFullSpeedConfigDscr;
1076   2          //  packetSize = 512;
1077   2      
1078   2         }
1079   1         else
1080   1         {
1081   2            pConfigDscr = pFullSpeedConfigDscr;
1082   2            pOtherConfigDscr = pHighSpeedConfigDscr;
1083   2          //  packetSize = 64;
1084   2         }
1085   1      
1086   1         EZUSB_IRQ_CLEAR();
1087   1         USBIRQ = bmHSGRANT;
1088   1      }
1089          void ISR_Ep0ack(void) interrupt 0
1090          {
1091   1      }
1092          void ISR_Stub(void) interrupt 0
1093          {
1094   1      }
1095          void ISR_Ep0in(void) interrupt 0
1096          {
C51 COMPILER V7.50   MAIN                                                                  01/24/2012 15:59:54 PAGE 19  

1097   1      }
1098          void ISR_Ep0out(void) interrupt 0
1099          {
1100   1      }
1101          void ISR_Ep1in(void) interrupt 0
1102          {
1103   1      }
1104          void ISR_Ep1out(void) interrupt 0
1105          {
1106   1      }
1107          void ISR_Ep2inout(void) interrupt 0
1108          {
1109   1      }
1110          void ISR_Ep4inout(void) interrupt 0
1111          {
1112   1      }
1113          void ISR_Ep6inout(void) interrupt 0
1114          {
1115   1      }
1116          void ISR_Ep8inout(void) interrupt 0
1117          {
1118   1      }
1119          void ISR_Ibn(void) interrupt 0
1120          {
1121   1      }
1122          void ISR_Ep0pingnak(void) interrupt 0
1123          {
1124   1      }
1125          void ISR_Ep1pingnak(void) interrupt 0
1126          {
1127   1      }
1128          void ISR_Ep2pingnak(void) interrupt 0
1129          {
1130   1      }
1131          void ISR_Ep4pingnak(void) interrupt 0
1132          {
1133   1      }
1134          void ISR_Ep6pingnak(void) interrupt 0
1135          {
1136   1      }
1137          void ISR_Ep8pingnak(void) interrupt 0
1138          {
1139   1      }
1140          void ISR_Errorlimit(void) interrupt 0
1141          {
1142   1      }
1143          void ISR_Ep2piderror(void) interrupt 0
1144          {
1145   1      }
1146          void ISR_Ep4piderror(void) interrupt 0
1147          {
1148   1      }
1149          void ISR_Ep6piderror(void) interrupt 0
1150          {
1151   1      }
1152          void ISR_Ep8piderror(void) interrupt 0
1153          {
1154   1      }
1155          void ISR_Ep2pflag(void) interrupt 0
1156          {
1157   1      }
1158          void ISR_Ep4pflag(void) interrupt 0
C51 COMPILER V7.50   MAIN                                                                  01/24/2012 15:59:54 PAGE 20  

1159          {
1160   1      }
1161          void ISR_Ep6pflag(void) interrupt 0
1162          {
1163   1      }
1164          void ISR_Ep8pflag(void) interrupt 0
1165          {
1166   1      }
1167          void ISR_Ep2eflag(void) interrupt 0
1168          {
1169   1      }
1170          void ISR_Ep4eflag(void) interrupt 0
1171          {
1172   1      }
1173          void ISR_Ep6eflag(void) interrupt 0
1174          {
1175   1      }
1176          void ISR_Ep8eflag(void) interrupt 0
1177          {
1178   1      }
1179          void ISR_Ep2fflag(void) interrupt 0
1180          {
1181   1      }
1182          void ISR_Ep4fflag(void) interrupt 0
1183          {
1184   1      }
1185          void ISR_Ep6fflag(void) interrupt 0
1186          {
1187   1      }
1188          void ISR_Ep8fflag(void) interrupt 0
1189          {
1190   1      }
1191          void ISR_GpifComplete(void) interrupt 0
1192          {
1193   1      }
1194          void ISR_GpifWaveform(void) interrupt 0
1195          {
1196   1      }


MODULE INFORMATION:   STATIC OVERLAYABLE
   CODE SIZE        =   2034    ----
   CONSTANT SIZE    =   ----    ----
   XDATA SIZE       =     99       5
   PDATA SIZE       =   ----    ----
   DATA SIZE        =      7      20
   IDATA SIZE       =   ----    ----
   BIT SIZE         =      2       3
END OF MODULE INFORMATION.


C51 COMPILATION COMPLETE.  0 WARNING(S),  0 ERROR(S)
