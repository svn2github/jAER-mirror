C51 COMPILER V7.50   MAIN                                                                  05/06/2013 10:30:04 PAGE 1   


C51 COMPILER V7.50, COMPILATION OF MODULE MAIN
OBJECT MODULE PLACED IN main.OBJ
COMPILER INVOKED BY: C:\Keil\C51\BIN\C51.EXE main.c BROWSE DEBUG OBJECTEXTEND

line level    source

   1          #pragma NOIV               // Do not generate interrupt vectors
   2          //-----------------------------------------------------------------------------
   3          //   File:      main.c
   4          //   Description: FX2LP firmware for the TCVS320/DVS320 retina chip   
   5          //
   6          // created: 1/2008, cloned from tmpdiff128 stereo board firmware
   7          // Revision: 0.01 
   8          // authors raphael berner, patrick lichtsteiner, tobi delbruck
   9          //
  10          //-----------------------------------------------------------------------------
  11          #include "lp.h"
  12          #include "lpregs.h"
  13          #include "syncdly.h"            // SYNCDELAY macro
  14          #include "biasgen.h" 
  15          #include "portsFX2.h"
  16          //#include "ports.h"
  17          //#include "micro.h"
  18          //#include "opcode.h"
  19          
  20          extern BOOL GotSUD;             // Received setup data flag
  21          //extern BOOL Sleep;
  22          extern BOOL Rwuen;
  23          extern BOOL Selfpwr;
  24          
  25          //BYTE Configuration;             // Current configuration
  26          //BYTE AlternateSetting;          // Alternate settings
  27          
  28          //WORD packetSize;
  29          
  30          // port E, not bit addressable - more bits are in biasgen.h
  31          #define CPLD_NOT_RESET                  0x80  // PE7 called nCPLDReset on host 
  32          #define DVS_nReset                              0x08  // PE3 called nChipReset on host, resets DVS array and AER logic
  33          #define BIAS_ADDR_SEL                   0x01  // PE0 called biasAddrSel selects the address shift register
  34          
  35          #define setArrayReset()         IOE=IOE&~DVS_nReset;    
  36          #define releaseArrayReset()     IOE=IOE|DVS_nReset;
  37          
  38          #define releaseAddrSR()         IOE=IOE|BIAS_ADDR_SEL;
  39          #define selectAddrSR()          IOE=IOE&~BIAS_ADDR_SEL; 
  40          
  41          #define BIAS_DIAG_SEL                   PA0
  42          #define RESET_TS                                PA7
  43          #define TIMESTAMP_MASTER                PA1
  44          #define RUN_CPLD                                PA3  // called runCpld on host
  45          
  46          #define RUN_ADC                 PC0  // called runAdc on host
  47          #define CPLD_SR_CLOCK   PC1
  48          #define CPLD_SR_LATCH   PC2
  49          #define CPLD_SR_BIT             PC3
  50          
  51          #define DB_Addr 1 // zero if only one byte address is needed for EEPROM, one if two byte address
  52          
  53          #define LEDmask         0x40  // PE6
  54          BOOL LEDon;
  55          
C51 COMPILER V7.50   MAIN                                                                  05/06/2013 10:30:04 PAGE 2   

  56          
  57          //#define MAX_NAME_LENGTH 8
  58          //#define STRING_ADDRESS (EEPROM_SIZE - MAX_NAME_LENGTH)
  59          
  60          #define MSG_TS_RESET 1
  61          
  62          // vendor requests
  63          #define VR_ENABLE_AE_IN 0xB3 // enable IN transfers
  64          #define VR_DISABLE_AE_IN 0xB4 // disable IN transfers
  65          #define VR_TRIGGER_ADVANCE_TRANSFER 0xB7 // trigger in packet commit (for host requests for early access t
             -o AE data) NOT IMPLEMENTED
  66          #define VR_RESETTIMESTAMPS 0xBb 
  67          //#define VR_SET_DEVICE_NAME 0xC2
  68          //#define VR_TIMESTAMP_TICK 0xC3
  69          #define VR_RESET_FIFOS 0xC4
  70          #define VR_DOWNLOAD_CPLD_CODE 0xC5 
  71          #define VR_READOUT_EEPROM 0xC9
  72          #define VR_IS_TS_MASTER 0xCB
  73          //#define VR_MISSED_EVENTS 0xCC
  74          #define VR_WRITE_CPLD_SR 0xCF
  75          //#define VR_RUN_ADC            0xCE
  76          
  77          #define VR_WRITE_CONFIG 0xB8 // write bytes out to SPI
  78                                          // the wLengthL field of SETUPDAT specifies the number of bytes to write out (max 64 per request)
  79                                          // the bytes are in the data packet
  80          //#define VR_SET_POWERDOWN 0xB9 // control powerDown. wValue controls the powerDown pin. Raise high to pow
             -er off, lower to power on.
  81          #define VR_EEPROM_BIASGEN_BYTES 0xBa // write bytes out to EEPROM for power on default
  82          
  83          #define VR_SETARRAYRESET 0xBc // set the state of the array reset which resets communication logic, and po
             -ssibly also holds pixels in reset
  84          #define VR_DOARRAYRESET 0xBd // toggle the array reset low long enough to reset all pixels and communicati
             -on logic 
  85          
  86          #define BIAS_FLASH_START 9 // start of bias value (this is where number of bytes is stored
  87          
  88          #define VR_UPLOAD               0xc0
  89          #define VR_DOWNLOAD             0x40
  90          #define VR_EEPROM               0xa2 // loads (uploads) EEPROM
  91          #define VR_RAM                  0xa3 // loads (uploads) external ram
  92          
  93          #define EP0BUFF_SIZE    0x40
  94          #define NUM_CONFIG_BITS_PRECEDING_BIAS_BYTES 40 
  95          // 10 muxes, each with 4 bits of config info. not a multiple of 8 so needs to be handled specially for SPI
             - interface.
  96          // we handle this by just padding the most signif nibble of the first byte written - this nibble will get 
             -shifted out.
  97          
  98          xdata unsigned int numBiasBytes; // number of bias bytes saved
  99          
 100          extern int g_iMovingAlgoIndex;      
 101          extern int g_iMovingDataIndex;
 102          
 103          BOOL JTAGinit;
 104          
 105          #define NUM_BIAS_BYTES 97 // 22 biases a 4 bytes, 1 Vdac a one byte plus 4 shifted source a 2 bytes 
 106          // (remember there are also 10 muxes a 4 bits, so the total bitstream is 102 bytes)
 107          // cDVSTest10 does not have the Vdac and the first four biases, but it does not matter if we shift in too 
             -many bits
 108          xdata unsigned char biasBytes[]={0x00,                                  // Vdac readout reference
 109                                                                           0x00,0x00,0x00,0x00,   // RObuffer
 110                                                                           0x00,0x00,0x00,0x00,   // refcurrent
C51 COMPILER V7.50   MAIN                                                                  05/06/2013 10:30:04 PAGE 3   

 111                                                                           0x00,0x00,0x00,0x00,   // ROcas
 112                                                                           0x00,0x00,0x00,0x00,   // ROgate
 113                                                                           0x00,0x00,0x00,0x00,   // follPad
 114                                                                           0x00,0x00,0x00,0x00,   // if_refr
 115                                                                           0x00,0x00,0x00,0x00,   // if_threshol
 116                                                                           0x00,0x00,0x00,0x00,   // AEpuY
 117                                                                           0x00,0x00,0x00,0x00,   // AEpuX
 118                                                                           0x00,0x00,0x00,0x00,   // AEReqEndPd
 119                                                                           0x00,0x00,0x00,0x00,   // AEReqPD
 120                                                                           0x00,0x00,0x00,0x00,   // refr
 121                                                                           0x00,0x00,0x00,0x00,   // fb
 122                                                                           0x00,0x00,0x00,0x00,   // pr
 123                                                                           0x00,0x00,0x00,0x00,   //pixInv
 124                                                                           0x00,0x00,0x00,0x00,   // pcas
 125                                                                           0x00,0x00,0x00,0x00,   // amp
 126                                                                           0x00,0x00,0x00,0x00,   // blue
 127                                                                           0x00,0x00,0x00,0x00,   // red
 128                                                                           0x00,0x00,0x00,0x00,   // off
 129                                                                           0x00,0x00,0x00,0x00,   // On
 130                                                                           0x00,0x00,0x00,0x00,   // diff
 131                                                                           0x00,0x00,             // SSNmid
 132                                                                           0x00,0x00,             // SSN
 133                                                                           0x00,0x00,  // SSPmid
 134                                                                           0x00,0x00}; // SSP
 135                                                                                   
 136          
 137          long cycleCounter;
 138          int i;
 139          
 140          #define I2C_Addr 0x51 //adress is 0101_0001
 141          
 142          
 143          
 144          void startMonitor(void);
 145          void stopMonitor(void);
 146          void configTimestampCounter(void);
 147          void toggleLED(void);
 148          
 149          void EEPROMWrite(WORD addr, BYTE length, BYTE xdata *buf);
 150          void EEPROMWriteBYTE(WORD addr, BYTE value);
 151          void EEPROMRead(WORD addr, BYTE length, BYTE xdata *buf);
 152          
 153          void downloadSerialNumberFromEEPROM(void);
 154          
 155          //-----------------------------------------------------------------------------
 156          // Task Dispatcher hooks
 157          //   The following hooks are called by the task dispatcher.
 158          //-----------------------------------------------------------------------------
 159          
 160          void TD_Init(void)              // Called once at startup
 161          {  
 162   1              // set the CPU clock to 48MHz
 163   1              CPUCS = ((CPUCS & ~bmCLKSPD) | bmCLKSPD1) ;
 164   1              CPUCS = CPUCS & 0xFD ; // 1111_1101
 165   1      
 166   1              // set the slave FIFO interface to 30MHz, slave fifo mode
 167   1              IFCONFIG = 0xA3; // 1010_0011
 168   1      
 169   1              // disable interrupts by the input pins and by timers and serial ports:
 170   1              IE &= 0x00; // 0000_0000 
 171   1      
 172   1              // disable interrupt pins 4, 5 and 6
C51 COMPILER V7.50   MAIN                                                                  05/06/2013 10:30:04 PAGE 4   

 173   1              EIE &= 0xE3; // 1110_0011;
 174   1      
 175   1              // Registers which require a synchronization delay, see section 15.14
 176   1              // FIFORESET        FIFOPINPOLAR
 177   1              // INPKTEND         OUTPKTEND
 178   1              // EPxBCH:L         REVCTL
 179   1              // GPIFTCB3         GPIFTCB2
 180   1              // GPIFTCB1         GPIFTCB0
 181   1              // EPxFIFOPFH:L     EPxAUTOINLENH:L
 182   1              // EPxFIFOCFG       EPxGPIFFLGSEL
 183   1              // PINFLAGSxx       EPxFIFOIRQ
 184   1              // EPxFIFOIE        GPIFIRQ
 185   1              // GPIFIE           GPIFADRH:L
 186   1              // UDMACRCH:L       EPxGPIFTRIG
 187   1              // GPIFTRIG
 188   1        
 189   1              //enable Port C and port E
 190   1              SYNCDELAY;
 191   1              PORTCCFG = 0x00;
 192   1              SYNCDELAY;
 193   1              PORTACFG = 0x00; // do not use interrupts 0 and 1
 194   1              SYNCDELAY;
 195   1              PORTECFG = 0x00;
 196   1      
 197   1              
 198   1              OEC = 0x0F; // 0000_1111 // JTAG, shift register stuff
 199   1              OEE = 0xFF; // 1111_1111 
 200   1              OEA = 0x89;  // 1000_1001 PA1: timestampMaster
 201   1      
 202   1              // 
 203   1              IOC = 0x00; 
 204   1              IOA = 0x00;
 205   1              IOE=  0x20;          //set BiasClock high 
 206   1              setPowerDownBit();      // tie biases to rail
 207   1      
 208   1              EP1OUTCFG = 0x00;                       // EP1OUT disabled
 209   1              SYNCDELAY;
 210   1              EP1INCFG = 0xA0;                        // EP1IN enabled, bulk
 211   1              SYNCDELAY;                   
 212   1              EP2CFG = 0x00;                          // EP2 disabled
 213   1              SYNCDELAY;                     
 214   1              EP4CFG = 0x00;                          // EP4 disabled
 215   1              SYNCDELAY;                 
 216   1              EP6CFG = 0xE0;                          // EP6 enabled, in bulk, quad buffered 
 217   1              SYNCDELAY;               
 218   1              EP8CFG = 0x00;                          // EP8 disabled
 219   1      
 220   1              SYNCDELAY;
 221   1              REVCTL= 0x03;
 222   1      
 223   1              EP6AUTOINLENH=0x02;
 224   1              EP6AUTOINLENL=0x00;
 225   1      
 226   1              SYNCDELAY;
 227   1              EP6FIFOCFG = 0x09 ; //0000_1001
 228   1      
 229   1              //set FIFO flag configuration: FlagB: EP6 full, flagC and D unused
 230   1              SYNCDELAY;
 231   1              PINFLAGSAB = 0xE8; // 1110_1000
 232   1      
 233   1              cycleCounter=0;
 234   1      
C51 COMPILER V7.50   MAIN                                                                  05/06/2013 10:30:04 PAGE 5   

 235   1              biasInit();     // init biasgen ports and pins                             
 236   1              EZUSB_InitI2C(); // init I2C to enable EEPROM read and write
 237   1      
 238   1              setArrayReset(); // keep pixels from spiking, reset all of them
 239   1              // pump powerdown to make sure masterbias is really started up
 240   1      /*      for(i=0;i<20;i++)
 241   1              {
 242   1                      setPowerDownBit();
 243   1                      //EZUSB_Delay1ms();
 244   1                      releasePowerDownBit();
 245   1                      //EZUSB_Delay1ms();
 246   1              }
 247   1              EZUSB_Delay(10); // ms delay after masterbias (re)startup
 248   1              for (i=0;i<NUM_BIAS_BYTES;i++)
 249   1              {
 250   1                      spiwritebyte(biasBytes[i]); // load hardcoded biases
 251   1              }
 252   1              latchNewBiases();       */
 253   1              
 254   1      
 255   1              
 256   1              IT0=1;          // make INT0# edge-sensitive
 257   1              EX0=0;          // disable INT0# (this interrupt was used to signal to the host to reset WrapAdd)
 258   1      
 259   1              IT1=1; // INT1# edge-sensitve
 260   1              EX1=0; // disable INT1#
 261   1      
 262   1              LEDon=FALSE;
 263   1         IOE |= CPLD_NOT_RESET; // take CPLD out of reset
 264   1      
 265   1      
 266   1      }
 267          
 268          void TD_Poll(void)              // Called repeatedly while the device is idle
 269          {       
 270   1      
 271   1              if(cycleCounter++>=100000){
 272   2      
 273   2                      toggleLED();
 274   2                      cycleCounter=0; // this makes a slow heartbeat on the LED to show firmware is running
 275   2              }               
 276   1      }
 277          
 278          void toggleLED(void)
 279          {
 280   1              if (LEDon==TRUE)
 281   1              {
 282   2                      IOE &= ~LEDmask;
 283   2                      LEDon=FALSE;
 284   2              }
 285   1              else
 286   1              {
 287   2                      IOE |= LEDmask;
 288   2                      LEDon=TRUE;
 289   2              }
 290   1      }
 291          
 292          /*void downloadSerialNumberFromEEPROM(void)
 293          {
 294                  BYTE i;
 295          
 296                  char *dscrRAM;
C51 COMPILER V7.50   MAIN                                                                  05/06/2013 10:30:04 PAGE 6   

 297                  BYTE xdata buf[MAX_NAME_LENGTH];
 298          
 299                  // get pointer to string descriptor 3
 300                  dscrRAM =  (char *)EZUSB_GetStringDscr(3);
 301          
 302                  // read string description from EEPROM
 303                  EEPROMRead(STRING_ADDRESS, MAX_NAME_LENGTH, buf);
 304                  
 305                  //write string description (serial number) to RAM
 306                  for (i=0;i<MAX_NAME_LENGTH;i++)
 307                  {
 308                          dscrRAM[2+i*2] = buf[i];
 309                  }
 310          }*/
 311          
 312          void startMonitor(void)
 313          {
 314   1              RUN_CPLD=1;
 315   1      
 316   1              releasePowerDownBit();
 317   1      //      IOE = IOE | DVS_nReset; //start dvs statemachines
 318   1       
 319   1      }
 320          
 321          void stopMonitor(void)
 322          {
 323   1      
 324   1              // force last paket
 325   1              
 326   1      //      EP6FIFOCFG = 0x01; //0000_0001 disable auto-in
 327   1      //      SYNCDELAY;
 328   1      
 329   1      //      if(EP6FIFOFLGS==0x00)
 330   1      //      { // if buffer available
 331   1      //      INPKTEND=0x06; // force in paket
 332   1      //              SYNCDELAY;
 333   1      //      }
 334   1      
 335   1              // reset fifo   
 336   1              FIFORESET = 0x80;
 337   1              SYNCDELAY;
 338   1              FIFORESET = 0x06;
 339   1              SYNCDELAY;
 340   1              FIFORESET = 0x00;
 341   1              SYNCDELAY;
 342   1      
 343   1              EP6FIFOCFG =0x09;  //0000_1001 set back to autoin
 344   1              SYNCDELAY;
 345   1      
 346   1              RUN_CPLD=0;
 347   1      
 348   1      //      IOE &= ~DVS_nReset;
 349   1      }
 350          
 351          // writes the byte in big endian order, e.g. from msb to lsb
 352          void CPLDwriteByte(BYTE dat)
 353          {
 354   1              BYTE i=0;
 355   1              BYTE mask=0x80;
 356   1      
 357   1              CPLD_SR_CLOCK = 0;
 358   1              for (i=0; i<8;i++)
C51 COMPILER V7.50   MAIN                                                                  05/06/2013 10:30:04 PAGE 7   

 359   1              {
 360   2                      CPLD_SR_BIT= dat & mask;
 361   2                      CPLD_SR_CLOCK = 1;
 362   2                      CPLD_SR_CLOCK = 0;
 363   2                      mask= mask >> 1;        
 364   2              }
 365   1      }
 366          
 367          void EEPROMWriteByte(WORD addr, BYTE value)
 368          {
 369   1              BYTE            i = 0;
 370   1              BYTE xdata      ee_str[3];
 371   1              if(DB_Addr)
 372   1                      ee_str[i++] = MSB(addr); // if 16 bit, we need 2-byte address and 1 byte data
 373   1      
 374   1              ee_str[i++] = LSB(addr);
 375   1              ee_str[i++] = value;
 376   1      
 377   1              IOE |= LEDmask;
 378   1              EZUSB_WriteI2C(I2C_Addr, i, ee_str);
 379   1              IOE &= ~LEDmask;
 380   1              LEDon=FALSE;
 381   1          EZUSB_WaitForEEPROMWrite(I2C_Addr);
 382   1      }
 383          
 384          void EEPROMWrite(WORD addr, BYTE length, BYTE xdata *buf)
 385          {
 386   1              BYTE    i;
 387   1              for(i=0;i<length;++i)
 388   1                      EEPROMWriteByte(addr++,buf[i]);
 389   1      }
 390          
 391          void EEPROMRead(WORD addr, BYTE length, BYTE xdata *buf)
 392          {
 393   1              BYTE            i = 0;
 394   1              BYTE            j = 0;
 395   1              BYTE xdata      ee_str[2];
 396   1      
 397   1              if(DB_Addr)
 398   1                      ee_str[i++] = MSB(addr);
 399   1      
 400   1              ee_str[i++] = LSB(addr);
 401   1      
 402   1              EZUSB_WriteI2C(I2C_Addr, i, ee_str);
 403   1      
 404   1              for(j=0; j < length; j++)
 405   1                      *(buf+j) = 0xcd;
 406   1      
 407   1              EZUSB_ReadI2C(I2C_Addr, length, buf);
 408   1      }
 409          
 410          
 411          BOOL TD_Suspend(void)          // Called before the device goes into suspend mode
 412          {
 413   1        // reset CPLD
 414   1        IOE &= ~CPLD_NOT_RESET;  
 415   1        IOE &= ~DVS_nReset; 
 416   1      
 417   1        return(TRUE);
 418   1      }
 419          
 420          BOOL TD_Resume(void)          // Called after the device resumes
C51 COMPILER V7.50   MAIN                                                                  05/06/2013 10:30:04 PAGE 8   

 421          {
 422   1      
 423   1         IOE |= CPLD_NOT_RESET;
 424   1         IOE |= DVS_nReset;
 425   1      
 426   1         return(TRUE);
 427   1      }
 428          
 429          //-----------------------------------------------------------------------------
 430          // Device Request hooks
 431          //   The following hooks are called by the end point 0 device request parser.
 432          //-----------------------------------------------------------------------------
 433          
 434          /*BOOL DR_GetDescriptor(void)
 435          {
 436             return(TRUE);
 437          }
 438          
 439          BOOL DR_SetConfiguration(void)   // Called when a Set Configuration command is received
 440          {
 441          //   Configuration = SETUPDAT[2];
 442             return(TRUE);            // Handled by user code
 443          }*/
 444          
 445          BOOL DR_GetConfiguration(void)   // Called when a Get Configuration command is received
 446          {
 447   1         EP0BUF[0] = 0x00;//Configuration;
 448   1         EP0BCH = 0;
 449   1         EP0BCL = 1;
 450   1         return(TRUE);            // Handled by user code
 451   1      }
 452          
 453          /*BOOL DR_SetInterface(void)       // Called when a Set Interface command is received
 454          {
 455          //   AlternateSetting = SETUPDAT[2];
 456             return(TRUE);            // Handled by user code
 457          }*/
 458          
 459          BOOL DR_GetInterface(void)       // Called when a Set Interface command is received
 460          {
 461   1         EP0BUF[0] = 0x00;//AlternateSetting;
 462   1         EP0BCH = 0;
 463   1         EP0BCL = 1;
 464   1         return(TRUE);            // Handled by user code
 465   1      }
 466          
 467          /*BOOL DR_GetStatus(void)
 468          {
 469             return(TRUE);
 470          }
 471          
 472          BOOL DR_ClearFeature(void)
 473          {
 474             return(TRUE);
 475          }
 476          
 477          BOOL DR_SetFeature(void)
 478          {
 479             return(TRUE);
 480          }*/
 481          
 482          void latchConfigBits(void)
C51 COMPILER V7.50   MAIN                                                                  05/06/2013 10:30:04 PAGE 9   

 483          {
 484   1              short count;
 485   1              IOE&=~biasLatch;
 486   1              for (count=0; count<50;count++)
 487   1              {
 488   2                      _nop_();  
 489   2              }
 490   1              IOE|=biasLatch;
 491   1      }
 492          
 493          // the SETUPDAT array has the following 8 elements (see FX2 TRM Section 2.3)
 494          //SETUPDAT[0] VendorRequest 0x40 for OUT type, 0xC0 for IN type
 495          //SETUPDAT[1] The actual vendor request (e.g. VR_ENABLE_AE_IN below)
 496          //SETUPDAT[2] wValueL 16 bit value LSB
 497          //         3  wValueH MSB
 498          //         4  wIndexL 16 bit field, varies according to request
 499          //         5  wIndexH
 500          //         6  wLengthL Number of bytes to transfer if there is a data phase
 501          //         7  wLengthH
 502          BYTE xsvfReturn;
 503          
 504          BOOL DR_VendorCmnd(void)
 505          {       
 506   1              WORD value; 
 507   1              WORD len,ind, bc; // xdata used here to conserve data ram; if not EEPROM writes don't work anymore
 508   1      
 509   1              WORD addr; // xdata used here to conserve data ram; if not EEPROM writes don't work anymore
 510   1              WORD i;
 511   1              bit oldbit;
 512   1      //      char *dscrRAM;
 513   1      //      unsigned char xdata JTAGdata[400];
 514   1      
 515   1              // we don't actually process the command here, we process it in the main loop
 516   1              // here we just do the handshaking and ensure if it is a command that is implemented
 517   1              switch (SETUPDAT[1]){
 518   2                      case VR_ENABLE_AE_IN: // enable IN transfers
 519   2                              {
 520   3                                      startMonitor();
 521   3                                      break;  // handshake phase triggered below
 522   3                              }
 523   2                      case VR_DISABLE_AE_IN: // disable IN transfers
 524   2                              {
 525   3                                      stopMonitor();
 526   3                                              break;
 527   3                              }
 528   2                      case VR_RESET_FIFOS: // reset in and out fifo
 529   2                              {
 530   3                                      SYNCDELAY;
 531   3                                      EP6FIFOCFG = 0x01; //0000_0001  disable auto-in
 532   3                                      SYNCDELAY;
 533   3                                      FIFORESET = 0x80;
 534   3                                      SYNCDELAY;
 535   3                                      FIFORESET = 0x06;
 536   3                                      SYNCDELAY;
 537   3                                      FIFORESET = 0x00;
 538   3      
 539   3      
 540   3                                      SYNCDELAY;
 541   3                                      EP6FIFOCFG = 0x09 ; //0000_1001 reenable auto-in
 542   3                                      break;
 543   3                              }
 544   2              /*      case VR_DOWNLOAD_CPLD_CODE:
C51 COMPILER V7.50   MAIN                                                                  05/06/2013 10:30:04 PAGE 10  

 545   2                              {
 546   2                              if (SETUPDAT[0]==VR_DOWNLOAD) {
 547   2                      
 548   2                                      if (SETUPDAT[4]) {
 549   2                                              xsvfReturn = ispEntryPoint();
 550   2                                      } else
 551   2                                      {
 552   2                                              addr = SETUPDAT[2];             // Get address and length
 553   2                                              addr |= SETUPDAT[3] << 8;
 554   2                                              len = SETUPDAT[6];
 555   2                                              len |= SETUPDAT[7] << 8;
 556   2              
 557   2                                              // first download programming data to EEPROM
 558   2                                              addr= addr + EEPROM_CPLDCODE_START; 
 559   2                                              while(len)                                      // Move new data through EP0OUT 
 560   2                                              {                                                       // one packet at a time.
 561   2                                                      // Arm endpoint - do it here to clear (after sud avail)
 562   2                                                      EP0BCH = 0;
 563   2                                                      EP0BCL = 0; // Clear bytecount to allow new data in; also stops NAKing
 564   2              
 565   2                                                      while(EP0CS & bmEPBUSY);
 566   2              
 567   2                                                      bc = EP0BCL; // Get the new bytecount
 568   2              
 569   2                                                      for(i=0; i<bc; i++)
 570   2                                                                      EEPROMWriteBYTE(addr+i, EP0BUF[i]);                                                     
 571   2              
 572   2                                                      addr += bc;
 573   2                                                      len -= bc;
 574   2                                              }
 575   2                                      }
 576   2      
 577   2                                      break;
 578   2                              }
 579   2                              else //case VR_XSVF_ERROR_CODE:
 580   2                              {
 581   2                                       // program CPLD when host ask
 582   2      
 583   2                                      EP0BUF[0] = SETUPDAT[1];
 584   2                                      EP0BUF[1]= xsvfReturn;
 585   2      
 586   2                                      EP0BUF[2] = 0xFF & (g_iMovingAlgoIndex >> 24);
 587   2                              EP0BUF[3] = 0xFF & (g_iMovingAlgoIndex >> 16);
 588   2                                      EP0BUF[4] = 0xFF & (g_iMovingAlgoIndex >> 8);
 589   2                                      EP0BUF[5] = 0xFF & (g_iMovingAlgoIndex);
 590   2      
 591   2                                      EP0BUF[6] = 0xFF & (g_iMovingDataIndex >> 24);
 592   2                              EP0BUF[7] = 0xFF & (g_iMovingDataIndex >> 16);
 593   2                                      EP0BUF[8] = 0xFF & (g_iMovingDataIndex >> 8);
 594   2                                      EP0BUF[9] = 0xFF & (g_iMovingDataIndex);
 595   2      
 596   2                                      EP0BCH = 0;
 597   2                                      EP0BCL = 10;
 598   2                                      EP0CS |= bmHSNAK;
 599   2      
 600   2                                      return(FALSE);
 601   2                              } 
 602   2                              }*/
 603   2              /*      case VR_SET_DEVICE_NAME:
 604   2                              {
 605   2                                      *EP0BUF = SETUPDAT[1];
 606   2                                      EP0BCH = 0;
C51 COMPILER V7.50   MAIN                                                                  05/06/2013 10:30:04 PAGE 11  

 607   2                                      EP0BCL = 1;
 608   2                                      EP0CS |= bmHSNAK;
 609   2      
 610   2                                      while(EP0CS & bmEPBUSY); //wait for the data packet to arrive
 611   2      
 612   2                                      dscrRAM = (char*)EZUSB_GetStringDscr(3); // get address of serial number descriptor-string in RAM
 613   2      
 614   2                                      if (EP0BCL > MAX_NAME_LENGTH)
 615   2                                      {
 616   2                                              len=MAX_NAME_LENGTH;
 617   2                                      } else 
 618   2                                      {
 619   2                                              len=EP0BCL;
 620   2                                      }
 621   2              
 622   2                                      for (i=0;i<len;i++)
 623   2                                      {
 624   2                                              EEPROMWriteBYTE(STRING_ADDRESS+i, EP0BUF[i]); // write string to EEPROM
 625   2                                              dscrRAM[2+i*2] = EP0BUF[i]; // write string to RAM
 626   2                                      }
 627   2      
 628   2                                      for (i=len; i<MAX_NAME_LENGTH; i++) // fill the rest with stop characters
 629   2                                      {
 630   2                                              EEPROMWriteBYTE(STRING_ADDRESS+i, ' '); // write string to EEPROM                               
 631   2                                              dscrRAM[2+i*2] = ' '; // write string to RAM
 632   2                                      }
 633   2      
 634   2                                      EP0BCH = 0;
 635   2                                      EP0BCL = 0;
 636   2      
 637   2                                      return(FALSE);
 638   2                              }*/             
 639   2                      case VR_RESETTIMESTAMPS:
 640   2                              {
 641   3                                      RESET_TS=1; // assert RESET_TS pin for one instruction cycle (four clock cycles)
 642   3                                      RESET_TS=0;
 643   3      
 644   3                                      // reset dvs statemachines
 645   3      //                              IOE= IOE & ~DVS_nReset;
 646   3      //                              _nop_();
 647   3      //                              _nop_();
 648   3      //                              _nop_();
 649   3      //                              IOE = IOE | DVS_nReset; //start dvs statemachines
 650   3      
 651   3                                      break;
 652   3                              }
 653   2                      case VR_WRITE_CONFIG: // write bytes to SPI interface and also handles other configuration of board like
             - CPLD and port bits on FX2
 654   2                      case VR_EEPROM_BIASGEN_BYTES: // falls through and actual command is tested below
 655   2                              {
 656   3                                      // the value bytes are the specific config command
 657   3                                      // the index bytes are the arguments
 658   3                                      // more data comes in the setupdat
 659   3                                      
 660   3                                      SYNCDELAY;
 661   3                                      value = SETUPDAT[2];            // Get request value
 662   3                                      value |= SETUPDAT[3] << 8;      // data comes little endian
 663   3                                      ind = SETUPDAT[4];                      // Get index
 664   3                                      ind |= SETUPDAT[5] << 8;
 665   3                                      len = SETUPDAT[6];              // length for data phase
 666   3                                      len |= SETUPDAT[7] << 8;
 667   3                                      switch(value&0xFF){ // take LSB for specific setup command 
C51 COMPILER V7.50   MAIN                                                                  05/06/2013 10:30:04 PAGE 12  

 668   4       
 669   4      // from SeeBetter.Biasgen inner class 
 670   4      #define CMD_IPOT  1
 671   4      #define CMD_AIPOT  2
 672   4      #define CMD_SCANNER  3
 673   4      #define CMD_CHIP  4
 674   4      #define CMD_SETBIT  5
 675   4      #define CMD_CPLDCONFIG 8
 676   4      
 677   4                                      case CMD_IPOT:
 678   4      
 679   4                                              numBiasBytes=len;
 680   4                                              while(len){     // Move new data through EP0OUT, one packet at a time, 
 681   5                                                      // eventually will get len down to zero by bc=64,64,15 (for example)
 682   5                                                      // Arm endpoint - do it here to clear (after sud avail)
 683   5                                                      EP0BCH = 0;
 684   5                                                      EP0BCL = 0; // Clear bytecount to allow new data in; also stops NAKing
 685   5                                                      SYNCDELAY;
 686   5                                                      while(EP0CS & bmEPBUSY);  // spin here until data arrives
 687   5                                                      bc = EP0BCL; // Get the new bytecount
 688   5                                                      for(i=0; i<bc; i++){
 689   6                                                              spiwritebyte(EP0BUF[i]); // writes out the bits big endian (msb to lsb)
 690   6                                                      }
 691   5      //                                              value += bc;    // inc eeprom value to write to, in case that's what we're doing
 692   5                                                      len -= bc; // dec total byte count
 693   5                                              }
 694   4                                              latchNewBiases();
 695   4                                              break;
 696   4      
 697   4                                      case CMD_AIPOT:
 698   4                                              
 699   4                                              EP0BCH = 0;
 700   4                                              EP0BCL = 0; // Clear bytecount to allow new data in; also stops NAKing
 701   4                                              BIAS_DIAG_SEL = 0;
 702   4                                              selectAddrSR();
 703   4                                              SYNCDELAY;
 704   4                                              while(EP0CS & bmEPBUSY);  // spin here until data arrives
 705   4                                              bc = EP0BCL; // Get the new bytecount
 706   4                                              spiwritebyte(EP0BUF[0]); // write bias address
 707   4                                              latchNewBiases();
 708   4                                              releaseAddrSR();
 709   4                                              //two data bytes per bias
 710   4                                              for(i=1; i<3; i++){
 711   5                                                      spiwritebyte(EP0BUF[i]); // writes out the bits big endian (msb to lsb)
 712   5                                              }
 713   4                                              latchNewBiases();
 714   4                                              break;
 715   4      
 716   4                                              
 717   4                                      case CMD_SETBIT:
 718   4                                              EP0BCH = 0;
 719   4                                              EP0BCL = 0; // Clear bytecount to allow new data in; also stops NAKing
 720   4                                              SYNCDELAY;
 721   4                                              while(EP0CS & bmEPBUSY);  // spin here until data arrives
 722   4                                              // sends value=CMD_SETBIT, index=portbit with (port(b=0,d=1,e=2)<<8)|bitmask(e.g. 00001000) in MSB/LS
             -B, byte[0]=value (1,0)
 723   4                                              // also if button is tristable type in GUI, then byte[0] has tristate in bit1
 724   4                                              {
 725   5                                                      bit bitval=(EP0BUF[0]&1); // 1=set, 0=clear
 726   5                                                      bit tristate=(EP0BUF[0]&2?1:0); // 1=tristate, 0=drive
 727   5                                                      unsigned char bitmask=SETUPDAT[4]; // bitmaskit mask, LSB of ind
 728   5                                                      switch(SETUPDAT[5]){ // this is port, MSB of ind
C51 COMPILER V7.50   MAIN                                                                  05/06/2013 10:30:04 PAGE 13  

 729   6                                                              case 0: // port a
 730   6                                                                      if(bitval) IOA|=bitmask; else IOA&= ~bitmask;
 731   6                                                                      if(tristate) OEA&= ~bitmask; else OEA|=bitmask; 
 732   6                                                              break;
 733   6                                                              case 1: // port c
 734   6                                                                      if(bitval) IOC|=bitmask; else IOC&= ~bitmask;
 735   6                                                                      if(tristate) OEC&= ~bitmask; else OEC|=bitmask; 
 736   6                                                              break;
 737   6                                                              case 2: // port d
 738   6                                                                      if(bitval) IOD|=bitmask; else IOD&= ~bitmask;
 739   6                                                                      if(tristate) OED&= ~bitmask; else OED|=bitmask; 
 740   6                                                              break;
 741   6                                                              case 3: // port e
 742   6                                                                      if(bitval) IOE|=bitmask; else IOE&= ~bitmask;
 743   6                                                                      if(tristate) OEE&= ~bitmask; else OEE|=bitmask; 
 744   6                                                              break;
 745   6                                                              default:
 746   6                                                                      return TRUE; // error
 747   6                                                      }
 748   5                                              }
 749   4                                              break;
 750   4                                      case CMD_SCANNER:
 751   4                                              // scanner is controlled by CPLD entirely, we just write the correct bits to the CPLD config SR.  Thi
             -s legacy cmd now returns a stall.
 752   4                                              return TRUE;
 753   4                                              break;
 754   4      
 755   4                                      case CMD_CHIP:
 756   4                                              // send diagnose SR values to chip
 757   4                                              BIAS_DIAG_SEL = 1;
 758   4                                              numBiasBytes=len;
 759   4                                              while(len){     // Move new data through EP0OUT, one packet at a time, 
 760   5                                                      // eventually will get len down to zero by bc=64,64,15 (for example)
 761   5                                                      // Arm endpoint - do it here to clear (after sud avail)
 762   5                                                      EP0BCH = 0;
 763   5                                                      EP0BCL = 0; // Clear bytecount to allow new data in; also stops NAKing
 764   5                                                      SYNCDELAY;
 765   5                                                      while(EP0CS & bmEPBUSY);  // spin here until data arrives
 766   5                                                      bc = EP0BCL; // Get the new bytecount
 767   5                                                      for(i=0; i<bc; i++){
 768   6                                                              spiwritebyte(EP0BUF[i]); // writes out the bits big endian (msb to lsb)
 769   6                                                      }
 770   5      //                                              value += bc;    // inc eeprom value to write to, in case that's what we're doing
 771   5                                                      len -= bc; // dec total byte count
 772   5                                              }
 773   4                                              latchConfigBits();
 774   4                                              BIAS_DIAG_SEL = 0;
 775   4                                              break;
 776   4      
 777   4                                      case CMD_CPLDCONFIG: // send bit string to CPLD configuration shift register (new feature on cochleaAM
             -S1c board/cpld/firmware)
 778   4                                                      // len holds the number of bytes to send
 779   4                                                      // the bytes should be sent from host so that the first byte
 780   4                                                      // holds the MSB, i.e., the bytes should be sent big endian from the host.
 781   4                                                      // i.e., the msb of the first byte should be the biggest-numbered bit
 782   4                                                      // and the lsb of the last byte is bit 0 as specified in the CPLD HDL configuration.
 783   4                                                      // Each byte here is written out big endian, from msb to lsb.
 784   4                                                      // Only integral bytes are written, so if the number of bytes is not a multiple of 8, 
 785   4                                                      // then the first byte written (the MSB) should be left padded so that the msb ends up at the corret
 786   4                                                      // position.
 787   4                                              
 788   4                                              oldbit=RUN_ADC;
C51 COMPILER V7.50   MAIN                                                                  05/06/2013 10:30:04 PAGE 14  

 789   4                                              RUN_ADC=0;
 790   4                                              while(len){                                     // Move new data through EP0OUT, one packet at a time
 791   5                                                      // Arm endpoint - do it here to clear (after sud avail)
 792   5                                                      EP0BCH = 0;
 793   5                                                      EP0BCL = 0; // Clear bytecount to allow new data in; also stops NAKing
 794   5                                                      while(EP0CS & bmEPBUSY);  // spin here until data arrives
 795   5                                                      bc = EP0BCL; // Get the new bytecount
 796   5                                              
 797   5                                                      for(i=0; i<bc; i++){
 798   6                                                              CPLDwriteByte(EP0BUF[i]); // writes the byte in big endian order, e.g. from msb to lsb
 799   6                                                      }
 800   5                                                      len -= bc; // dec total byte count
 801   5                                              }
 802   4                              
 803   4                                              CPLD_SR_LATCH=0;
 804   4                                              CPLD_SR_LATCH=1;
 805   4                                              RUN_ADC=oldbit;
 806   4              
 807   4                                                      break; // very important, otherwise get stall
 808   4                                      default:
 809   4                                              return(TRUE);  // don't recognize command, generate stall
 810   4                                      } // end of subcmd switch
 811   3      
 812   3                                      EP0BCH = 0;
 813   3                                      EP0BCL = 0;                   // Arm endpoint with 0 byte to transfer
 814   3                                      toggleLED();
 815   3                                      return(FALSE); // very important, otherwise get stall
 816   3                              } // end of subcmds to config cmds
 817   2      /* commented out because these VR's are replaced by direct bit control from host side via general interfac
             -e to ports
 818   2              case VR_WRITE_CPLD_SR: // write bytes to SPI interface
 819   2                              {
 820   2                                      SYNCDELAY;
 821   2                                      len = SETUPDAT[6];
 822   2                                      len |= SETUPDAT[7] << 8;
 823   2                                      oldbit=RUN_ADC;
 824   2                                      RUN_ADC=0;
 825   2                                      while(len){                                     // Move new data through EP0OUT, one packet at a time
 826   2                                              // Arm endpoint - do it here to clear (after sud avail)
 827   2                                              EP0BCH = 0;
 828   2                                              EP0BCL = 0; // Clear bytecount to allow new data in; also stops NAKing
 829   2                                              while(EP0CS & bmEPBUSY);  // spin here until data arrives
 830   2                                              bc = EP0BCL; // Get the new bytecount
 831   2                                      
 832   2                                              for(i=0; i<bc; i++){
 833   2                                                      CPLDwriteByte(EP0BUF[i]);                                       
 834   2                                              }
 835   2                                      
 836   2                                              len -= bc; // dec total byte count
 837   2                                      }
 838   2                      
 839   2                                      CPLD_SR_LATCH=0;
 840   2                                      CPLD_SR_LATCH=1;
 841   2      
 842   2                                      EP0BCH = 0;
 843   2                                      EP0BCL = 0;                   // Arm endpoint with 0 byte to transfer
 844   2                                      toggleLED();
 845   2                                      return(FALSE); // very important, otherwise get stall
 846   2                              }
 847   2                      case VR_RUN_ADC:
 848   2                              {       
 849   2                                      if (SETUPDAT[2])
C51 COMPILER V7.50   MAIN                                                                  05/06/2013 10:30:04 PAGE 15  

 850   2                                      {
 851   2                                              RUN_ADC=1;
 852   2                                      } else 
 853   2                                      {
 854   2                                              RUN_ADC=0;
 855   2                                      }
 856   2                                      break;
 857   2                              }
 858   2                      case VR_SET_POWERDOWN: // control powerDown output bit
 859   2                              {
 860   2                                      if (SETUPDAT[2])
 861   2                                      {
 862   2                                              setPowerDownBit();
 863   2                                      } else 
 864   2                                      {
 865   2                                              releasePowerDownBit();
 866   2                                      }
 867   2                                      break;
 868   2      
 869   2                              }
 870   2      
 871   2      */
 872   2                      case VR_SETARRAYRESET: // set array reset, based on lsb of argument. This also resets the AER logic.
 873   2                              {
 874   3                                      if (SETUPDAT[2]&0x01)
 875   3                                      {
 876   4                                              IOE &= ~DVS_nReset;
 877   4                                      } else
 878   3                                      {
 879   4                                              IOE |= DVS_nReset;
 880   4                                      }
 881   3                              
 882   3                                      break;
 883   3                              }
 884   2      
 885   2                      case VR_DOARRAYRESET: // reset array for fixed reset time
 886   2                              {
 887   3                                      IOE &= ~DVS_nReset;
 888   3                                      _nop_();
 889   3                                      _nop_();
 890   3                                      _nop_();
 891   3                                      _nop_();
 892   3                                      _nop_();
 893   3                                      _nop_();
 894   3                                      _nop_();
 895   3                                      _nop_();        // a few us
 896   3                                      _nop_();
 897   3                                      _nop_();
 898   3                                      _nop_();
 899   3                                      _nop_();
 900   3                                      _nop_();
 901   3                                      _nop_();
 902   3                                      IOE |= DVS_nReset;
 903   3                                      break;
 904   3                              }
 905   2              /*      case VR_IS_TS_MASTER:
 906   2                              {
 907   2                                      EP0BUF[0] = SETUPDAT[1];
 908   2                                      EP0BUF[1]= TIMESTAMP_MASTER;
 909   2                                      EP0BCH = 0;
 910   2                                      EP0BCL = 2;
 911   2                                      EP0CS |= bmHSNAK;
C51 COMPILER V7.50   MAIN                                                                  05/06/2013 10:30:04 PAGE 16  

 912   2      
 913   2                                      return(FALSE);
 914   2                              }*/
 915   2                      case VR_RAM:
 916   2                      case VR_EEPROM:
 917   2                      {
 918   3                              addr = SETUPDAT[2];             // Get address and length
 919   3                              addr |= SETUPDAT[3] << 8;
 920   3                              len = SETUPDAT[6];
 921   3                              len |= SETUPDAT[7] << 8;
 922   3                              // Is this an upload command ?
 923   3                              if(SETUPDAT[0] == VR_UPLOAD)  // this is automatically defined on host from direction of vendor request
 924   3                              {
 925   4                                      while(len)                                      // Move requested data through EP0IN 
 926   4                                      {                                                       // one packet at a time.
 927   5      
 928   5                                              while(EP0CS & bmEPBUSY);
 929   5      
 930   5                                              if(len < EP0BUFF_SIZE)
 931   5                                                      bc = len;
 932   5                                              else
 933   5                                                      bc = EP0BUFF_SIZE;
 934   5      
 935   5                                              // Is this a RAM upload ?
 936   5                                              if(SETUPDAT[1] == VR_RAM)
 937   5                                              {
 938   6                                                      for(i=0; i<bc; i++)
 939   6                                                              *(EP0BUF+i) = *((BYTE xdata *)addr+i);
 940   6                                              }
 941   5                                              else
 942   5                                              {
 943   6                                                      for(i=0; i<bc; i++)
 944   6                                                              *(EP0BUF+i) = 0xcd;
 945   6                                                      EEPROMRead(addr,(WORD)bc,(WORD)EP0BUF);
 946   6                                              }
 947   5      
 948   5                                              EP0BCH = 0;
 949   5                                              EP0BCL = (BYTE)bc; // Arm endpoint with # bytes to transfer
 950   5      
 951   5                                              addr += bc;
 952   5                                              len -= bc;
 953   5      
 954   5                                      }
 955   4                              }
 956   3                              // Is this a download command ?
 957   3                              else if(SETUPDAT[0] == VR_DOWNLOAD) // this is automatically defined on host from direction of vendor r
             -equest
 958   3                              {
 959   4                                      while(len)                                      // Move new data through EP0OUT 
 960   4                                      {                                                       // one packet at a time.
 961   5                                              // Arm endpoint - do it here to clear (after sud avail)
 962   5                                              EP0BCH = 0;
 963   5                                              EP0BCL = 0; // Clear bytecount to allow new data in; also stops NAKing
 964   5      
 965   5                                              while(EP0CS & bmEPBUSY);
 966   5      
 967   5                                              bc = EP0BCL; // Get the new bytecount
 968   5      
 969   5                                              // Is this a RAM download ?
 970   5                                              if(SETUPDAT[1] == VR_RAM)
 971   5                                              {
 972   6                                                      for(i=0; i<bc; i++)
C51 COMPILER V7.50   MAIN                                                                  05/06/2013 10:30:04 PAGE 17  

 973   6                                                              *((BYTE xdata *)addr+i) = *(EP0BUF+i);
 974   6                                              }
 975   5                                              else
 976   5                                                      EEPROMWrite(addr,bc,(WORD)EP0BUF);
 977   5      
 978   5                                              addr += bc;
 979   5                                              len -= bc;
 980   5                                      }
 981   4                              }
 982   3                              return(FALSE);
 983   3                      }
 984   2                      default:
 985   2                      { // we received an invalid command
 986   3                              return(TRUE);
 987   3                      }
 988   2              }
 989   1      
 990   1              *EP0BUF = SETUPDAT[1];
 991   1              EP0BCH = 0;
 992   1              EP0BCL = 1;
 993   1              EP0CS |= bmHSNAK;
 994   1      
 995   1              return(FALSE);
 996   1      }
 997          
 998          // no interrupts are used for TCVS320
 999          // RESET HOST TIMESTAMP INTERRUPT not used
1000          /*void ISR_TSReset(void) interrupt 3 {
1001                  LED=0;
1002                  
1003                  SYNCDELAY; // reset fifos to delete events with the old timestamps
1004                  FIFORESET = 0x80;
1005                  SYNCDELAY;
1006                  FIFORESET = 0x06;
1007                  SYNCDELAY;
1008                  FIFORESET = 0x00;
1009          
1010                  SYNCDELAY;
1011                  EP6FIFOCFG = 0x09 ; //0000_1001
1012          
1013          
1014                  if (EP1INCS!=0x02)
1015                  {
1016                          EP1INBUF[0]=MSG_TS_RESET;
1017                          SYNCDELAY;
1018                          EP1INBC=1;
1019                          SYNCDELAY;
1020                          IE0=0; // clear interrupt
1021                          EX0=1; // enable INT0# external interrupt
1022                          LED=1;
1023                  }
1024          }
1025          
1026          */
1027          
1028          //-----------------------------------------------------------------------------
1029          // USB Interrupt Handlers
1030          //   The following functions are called by the USB interrupt jump table.
1031          //-----------------------------------------------------------------------------
1032          
1033          // Setup Data Available Interrupt Handler
1034          void ISR_Sudav(void) interrupt 0
C51 COMPILER V7.50   MAIN                                                                  05/06/2013 10:30:04 PAGE 18  

1035          {
1036   1         GotSUD = TRUE;            // Set flag
1037   1         EZUSB_IRQ_CLEAR();
1038   1         USBIRQ = bmSUDAV;         // Clear SUDAV IRQ
1039   1      }
1040          
1041          // Setup Token Interrupt Handler
1042          void ISR_Sutok(void) interrupt 0
1043          {
1044   1         EZUSB_IRQ_CLEAR();
1045   1         USBIRQ = bmSUTOK;         // Clear SUTOK IRQ
1046   1      }
1047          
1048          void ISR_Sof(void) interrupt 0
1049          {
1050   1         EZUSB_IRQ_CLEAR();
1051   1         USBIRQ = bmSOF;            // Clear SOF IRQ
1052   1      }
1053          
1054          void ISR_Ures(void) interrupt 0
1055          {
1056   1         if (EZUSB_HIGHSPEED())
1057   1         {
1058   2            pConfigDscr = pHighSpeedConfigDscr;
1059   2            pOtherConfigDscr = pFullSpeedConfigDscr;
1060   2          //  packetSize = 512;
1061   2      
1062   2         }
1063   1         else
1064   1         {
1065   2            pConfigDscr = pFullSpeedConfigDscr;
1066   2            pOtherConfigDscr = pHighSpeedConfigDscr;
1067   2          //  packetSize = 64;
1068   2         }
1069   1         
1070   1         EZUSB_IRQ_CLEAR();
1071   1         USBIRQ = bmURES;         // Clear URES IRQ
1072   1      }
1073          
1074          void ISR_Susp(void) interrupt 0
1075          {
1076   1      //   Sleep = TRUE;
1077   1      //   EZUSB_IRQ_CLEAR();
1078   1      //   USBIRQ = bmSUSP;
1079   1      }
1080          
1081          void ISR_Highspeed(void) interrupt 0
1082          {
1083   1         if (EZUSB_HIGHSPEED())
1084   1         {
1085   2            pConfigDscr = pHighSpeedConfigDscr;
1086   2            pOtherConfigDscr = pFullSpeedConfigDscr;
1087   2          //  packetSize = 512;
1088   2      
1089   2         }
1090   1         else
1091   1         {
1092   2            pConfigDscr = pFullSpeedConfigDscr;
1093   2            pOtherConfigDscr = pHighSpeedConfigDscr;
1094   2          //  packetSize = 64;
1095   2         }
1096   1      
C51 COMPILER V7.50   MAIN                                                                  05/06/2013 10:30:04 PAGE 19  

1097   1         EZUSB_IRQ_CLEAR();
1098   1         USBIRQ = bmHSGRANT;
1099   1      }
1100          void ISR_Ep0ack(void) interrupt 0
1101          {
1102   1      }
1103          void ISR_Stub(void) interrupt 0
1104          {
1105   1      }
1106          void ISR_Ep0in(void) interrupt 0
1107          {
1108   1      }
1109          void ISR_Ep0out(void) interrupt 0
1110          {
1111   1      }
1112          void ISR_Ep1in(void) interrupt 0
1113          {
1114   1      }
1115          void ISR_Ep1out(void) interrupt 0
1116          {
1117   1      }
1118          void ISR_Ep2inout(void) interrupt 0
1119          {
1120   1      }
1121          void ISR_Ep4inout(void) interrupt 0
1122          {
1123   1      }
1124          void ISR_Ep6inout(void) interrupt 0
1125          {
1126   1      }
1127          void ISR_Ep8inout(void) interrupt 0
1128          {
1129   1      }
1130          void ISR_Ibn(void) interrupt 0
1131          {
1132   1      }
1133          void ISR_Ep0pingnak(void) interrupt 0
1134          {
1135   1      }
1136          void ISR_Ep1pingnak(void) interrupt 0
1137          {
1138   1      }
1139          void ISR_Ep2pingnak(void) interrupt 0
1140          {
1141   1      }
1142          void ISR_Ep4pingnak(void) interrupt 0
1143          {
1144   1      }
1145          void ISR_Ep6pingnak(void) interrupt 0
1146          {
1147   1      }
1148          void ISR_Ep8pingnak(void) interrupt 0
1149          {
1150   1      }
1151          void ISR_Errorlimit(void) interrupt 0
1152          {
1153   1      }
1154          void ISR_Ep2piderror(void) interrupt 0
1155          {
1156   1      }
1157          void ISR_Ep4piderror(void) interrupt 0
1158          {
C51 COMPILER V7.50   MAIN                                                                  05/06/2013 10:30:04 PAGE 20  

1159   1      }
1160          void ISR_Ep6piderror(void) interrupt 0
1161          {
1162   1      }
1163          void ISR_Ep8piderror(void) interrupt 0
1164          {
1165   1      }
1166          void ISR_Ep2pflag(void) interrupt 0
1167          {
1168   1      }
1169          void ISR_Ep4pflag(void) interrupt 0
1170          {
1171   1      }
1172          void ISR_Ep6pflag(void) interrupt 0
1173          {
1174   1      }
1175          void ISR_Ep8pflag(void) interrupt 0
1176          {
1177   1      }
1178          void ISR_Ep2eflag(void) interrupt 0
1179          {
1180   1      }
1181          void ISR_Ep4eflag(void) interrupt 0
1182          {
1183   1      }
1184          void ISR_Ep6eflag(void) interrupt 0
1185          {
1186   1      }
1187          void ISR_Ep8eflag(void) interrupt 0
1188          {
1189   1      }
1190          void ISR_Ep2fflag(void) interrupt 0
1191          {
1192   1      }
1193          void ISR_Ep4fflag(void) interrupt 0
1194          {
1195   1      }
1196          void ISR_Ep6fflag(void) interrupt 0
1197          {
1198   1      }
1199          void ISR_Ep8fflag(void) interrupt 0
1200          {
1201   1      }
1202          void ISR_GpifComplete(void) interrupt 0
1203          {
1204   1      }
1205          void ISR_GpifWaveform(void) interrupt 0
1206          {
1207   1      }


MODULE INFORMATION:   STATIC OVERLAYABLE
   CODE SIZE        =   2044    ----
   CONSTANT SIZE    =   ----    ----
   XDATA SIZE       =     99       5
   PDATA SIZE       =   ----    ----
   DATA SIZE        =      7      20
   IDATA SIZE       =   ----    ----
   BIT SIZE         =      2       3
END OF MODULE INFORMATION.


C51 COMPILATION COMPLETE.  0 WARNING(S),  0 ERROR(S)
