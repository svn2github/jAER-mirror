/*
 * USBAEMon.java
 *
 * Created on February 17, 2005, 7:54 AM
 */
package ch.unizh.ini.caviar.hardwareinterface.usb;

import ch.unizh.ini.caviar.aemonitor.*;
import ch.unizh.ini.caviar.biasgen.*;
import ch.unizh.ini.caviar.aemonitor.AEMonitorInterface;
import ch.unizh.ini.caviar.chip.*;
import ch.unizh.ini.caviar.chip.filter.*;
//import ch.unizh.ini.caviar.chip.EventExtractor2D;
import ch.unizh.ini.caviar.chip.filter.EventFilter;
import ch.unizh.ini.caviar.chip.filter.FilterChain;
import ch.unizh.ini.caviar.chip.retina.*;
import ch.unizh.ini.caviar.event.EventPacket;
import ch.unizh.ini.caviar.hardwareinterface.*;
import ch.unizh.ini.caviar.util.*;
import de.thesycon.usbio.PnPNotifyInterface;
import java.beans.*;
import java.io.*;
import de.thesycon.usbio.*;
import de.thesycon.usbio.structs.*;
import java.net.URL;
import java.util.*;
import java.util.logging.Logger;
import java.util.prefs.*;


/**
 *  Acquires data from INI/USE USB2 board that uses Cypress FX2LP device and host driver firmware and software based on Thesycon Java USBIO.
 *Controls onchip biasgenerator using Cypress FX2 SPI interface.
 *<p>
 *<p>
 *In this class, you can also set the size of the host buffer with {@link #setAEBufferSize}, giving you more time between calls to process the events.
 *<p>
 *On the device, a timer sends all available events approximately every 10ms -- you don't need to wait for a fixed size buffer to be captured to be available to the host.
 *But if events come quickly enough, new events can be available much faster than this.
 *<p>
 *You can also request at any time an early transfer of events with {@link #requestEarlyTransfer}. This will send a vendor request to the device to immediately transfer
 * available events, but they won't be available to the host for a little while, depending on USBIOInterface and driver latency.
 *<p>
 *See the main() method for an example of use.
 *
 *
 * @author  tobi
 */
public class CypressFX2 implements UsbIoErrorCodes, PnPNotifyInterface, AEMonitorInterface, ReaderBufferControl, RealTimeFilter {
    
    
    protected Preferences prefs=Preferences.userNodeForPackage(this.getClass());
    protected Logger log=Logger.getLogger("CypressFX2");//this.getClass().getPackage().getName());
    
    protected AEChip chip;
    
    /** filename of FX2 binary executable, generated by uVision project and associated script that runs hex2bix */
    public final static String FIRMWARE_FILENAME_DAREK_BOARD="/ch/unizh/ini/caviar/hardwareinterface/usb/USBAER_FX2.bix"; //"USBAEMonFirware.bin";
    /** filename of FX2 binary executable, generated by uVision project and associated script that runs hex2bix */
    public final static String FIRMWARE_FILENAME_TMPDIFF128="/ch/unizh/ini/caviar/hardwareinterface/usb/USBAER_FX2LP_Retina.bix"; //"USBAEMonFirware.bin";
    /** filename of FX2 binary executable, generated by uVision project and associated script that runs hex2bix */
    public final static String FIRMWARE_FILENAME_TMPDIFF128_HEX="/ch/unizh/ini/caviar/hardwareinterface/usb/USBAER_FX2LP_Retina.hex"; //"USBAEMonFirware.bin";
    /** filename of FX2 binary executable, generated by uVision project and associated script that runs hex2bix */
    public final static String FIRMWARE_FILENAME_MONITOR_SEQUENCER="/ch/unizh/ini/caviar/hardwareinterface/usb/USBAERmini2.bix";
    /** filename of FX2 binary executable, generated by uVision project and associated script that runs hex2bix */
    public final static String FIRMWARE_FILENAME_MONITOR_SEQUENCER_HEX="/ch/unizh/ini/caviar/hardwareinterface/usb/USBAERmini2.hex";
    /** filename of FX2 binary executable, generated by uVision project and associated script that runs hex2bix */
    public final static String FIRMWARE_FILENAME_MONITOR_SEQUENCER_IIC="/ch/unizh/ini/caviar/hardwareinterface/usb/USBAERmini2.iic";
    public final static String FIRMWARE_FILENAME_MAPPER_IIC="/ch/unizh/ini/caviar/hardwareinterface/usb/USB2AERmapper.iic";
    
    
    /** driver guid (Globally unique ID, for this USB driver instance */
    //public final static String GUID = "{325ddf96-938c-11d3-9e34-0080c82727f4}";  // working from MouseSimple example.
    public final static String GUID  = "{7794C79A-40A7-4a6c-8A29-DA141C20D78C}"; // see guid.txt at root of CypressFX2USB2, generated by tobi for CypressFX2RetinaBiasgen
    //public final static String GUID    = "{96E73B6E-7A5A-11D4-9F24-0080C82727F4}";  // from default usbiowiz.inf file
    
    static public final short VID=(short)0x0547;
    static public final short PID_TMPDIFF128_RETINA=(short)0x8700;
    static public final short PID_DAREK_FX2_BOARD=(short)0x8701;
    static public final short PID_USBAERmini2=(short)0x8801;
    static public final short PID_USBAERmini2_without_firmware=(short)0x8800;
    static public final short PID_USB2AERmapper=(short)0x8900;
    
    /**
     * event supplied to listeners when new events are collected. this is final because it is just a marker for the listeners that new events are available
     */
    public final PropertyChangeEvent newEventPropertyChange=new PropertyChangeEvent(this, "NewEvents", null,null);
    PropertyChangeSupport support=new PropertyChangeSupport(this);
    
    
    // consts
    final static byte AE_MONITOR_ENDPOINT_ADDRESS = (byte)0x86;  // this is endpoint of AE fifo on Cypress FX2, 0x86 means IN endpoint EP6.
    final static byte STATUS_ENDPOINT_ADDRESS = (byte)0x81;  // this is endpoint 1 IN for device to report status changes asynchronously
    final short CPUCS = (short)0xE600;            // address of the CPUCS register, using for resetting 8051 and downloading firmware
    
    // vendor requests.
    final static byte VENDOR_REQUEST_START_TRANSFER=(byte)0xb3; // this is request to start sending events from FIFO endpoint
    final static byte VENDOR_REQUEST_STOP_TRANSFER=(byte)0xb4; // this is request to stop sending events from FIFO endpoint
    final static byte VENDOR_REQUEST_EARLY_TRANFER=(byte)0xb7; // this is request to transfer whatever you have now
    static final byte VENDOR_REQUEST_SEND_BIAS_BYTES=(byte)0xb8; // vendor command to send bias bytes out on SPI interface
    final byte VENDOR_REQUEST_POWERDOWN=(byte)0xb9; // vendor command to send bias bytes out on SPI interface
    final byte VENDOR_REQUEST_FLASH_BIASES=(byte)0xba;  // vendor command to flash the bias values to EEPROM
    final byte VENDOR_REQUEST_RESET_TIMESTAMPS=(byte)0xbb; // vendor command to reset timestamps
    final byte VENDOR_REQUEST_SET_ARRAY_RESET=(byte)0xbc; // vendor command to set array reset of retina
    final byte VENDOR_REQUEST_DO_ARRAY_RESET=(byte)0xbd; // vendor command to do an array reset (toggle arrayReset for a fixed time)
    //final byte VENDOR_REQUEST_WRITE_EEPROM=(byte)0xbe; // vendor command to write EEPROM
    final byte VENDOR_REQUEST_SET_LED=(byte)0xbf; // vendor command to set the board's LED
    final byte VENDOR_REQUEST_RSV2_SENDCMD=(byte)0xbe; // vendor command to sent command to RSV2
    //final byte VENDOR_REQUEST_READ_EEPROM=(byte)0xca; // vendor command to write EEPROM
    // #define VR_EEPROM		0xa2 // loads (uploads) EEPROM
    final byte VR_EEPROM =(byte)0xa2;
    // #define	VR_RAM			0xa3 // loads (uploads) external ram
    final byte VR_RAM =(byte)0xa3;
    
    // this is special hw vendor request for reading and writing RAM, used for firmware download
    static final byte VENDOR_REQUEST_FIRMWARE = (byte)0xA0; // download/upload firmware -- built in to FX2
    
    
    final static short CONFIG_INDEX                       = 0;
    final static short CONFIG_NB_OF_INTERFACES            = 1;
    final static short CONFIG_INTERFACE                   = 0;
    final static short CONFIG_ALT_SETTING                 = 0;
    final static int CONFIG_TRAN_SIZE                     = 512;
    
    
    // following are to support realtime filtering
    // the AEPacketRaw is used only within this class. Each packet is extracted using the chip extractor object from the first filter in the
    // realTimeFilterChain to a reused EventPacket.
    
    AEPacketRaw realTimeRawPacket=null;
    EventPacket realTimePacket=null;
    
    /** start of events that have been captured but not yet processed by the realTimeFilters */
    private int realTimeEventCounterStart=0;

    /** timeout in ms to reopen driver (reloading firmware) if no events are received for this time. This timeout will restart AE transmission if
     *another process (e.g. Biasgen) reloads the firmware. This timer is checked on every attempt to acquire events.
     */
    public static long NO_AE_REOPEN_TIMEOUT=3000;
    final short TICK_US=1; // time in us of each timestamp count here on host, could be different on board
    short TICK_US_BOARD=10; // time in us of timestamp tick on USB board. raphael: should not be final, i need to overwrite it and set it to 1
    
    /** default size of AE buffer for user processes */
    public static final int AE_BUFFER_SIZE=0x1ffff;
    
    /** the latest status returned from a USBIO call */
    protected int status;
    
    /** the event reader - a buffer pool thread from USBIO subclassing */
    protected AEReader aeReader=null;
    
    /** the thread that reads device status messages on EP1 */
    protected AsyncStatusThread asyncStatusThread=null;
    
    
    /** a USBIO buffer used for calls */
    protected UsbIoBuf BufDesc=null;
    
    /** used for event capture from driver */
    class CaptureBuffer{
        short[] addresses=null;
        int[] timestamps=null;
        int numEvents;
        boolean overrunOccuredFlag=false;
        int currentBuffer=0;
        CaptureBufferPool pool;
        
        CaptureBuffer(CaptureBufferPool pool){
            this.pool=pool;
            allocateMemory();
        }
        
        /** allocate memory for events */
        final void allocateMemory(){
            numEvents=0;
            eventCounter=0;
            addresses=new short[pool.bufferSize];
            timestamps=new int[pool.bufferSize];
        }
        
        final public short[] getAddresses() {
            return this.addresses;
        }
        
        final public int[] getTimestamps() {
            return this.timestamps;
        }
    }
    
    /** an array of CaptureBuffer that is used between the main thread and the AEReader thread to pass events.
     */
    class CaptureBufferPool{
        int bufferSize=AE_BUFFER_SIZE;
        int currentBuffer=0;
        int numBuffers=2;
        CaptureBuffer[] buffers=new CaptureBuffer[2];
        CaptureBuffer lastBufferReference=null;
        CaptureBufferPool(){
            for(int i=0;i<buffers.length;i++){
                buffers[i]=new CaptureBuffer(this);
            }
        }
        /** switch to next buffer */
        final void swap(){
            lastBufferReference=buffers[currentBuffer];
            currentBuffer++;
            if(currentBuffer>=numBuffers) currentBuffer=0;
            active().numEvents=0;
        }
        
        final CaptureBuffer last(){
            return lastBufferReference;
        }
        
        /** return current buffer */
        final CaptureBuffer active(){
            return buffers[currentBuffer];
        }
        
        final void allocateMemory(){
            for(int i=0;i<buffers.length;i++){
                buffers[i].allocateMemory();
            }
            
        }
    }
    
//    short[] addresses=null;
//    int[] timestamps=null;
//    int numEvents;
//    boolean overrunOccuredFlag=false;
//    int currentBuffer=0;
    
    /** used for event capture to pass events from AEReader to main thread (acquireAvailableEventsFromDriver) */
    CaptureBufferPool captureBufferPool=new CaptureBufferPool();
    
    int eventCounter=0;  // counts events acquired but not yet passed to user
    
    
    /** the last events from {@link #acquireAvailableEventsFromDriver} */
    protected AEPacketRaw events=new AEPacketRaw();
    
    PnPNotify pnp=null;
    USBIO_CLASS_OR_VENDOR_REQUEST vendorRequest;  // used for vendor requests to device (e.g. firmware download, start sending events, etc)
    
    protected boolean inEndpointEnabled=false;  // raphael: changed from private to protected, because i need to access this member
    
    /** device open status */
    protected boolean isOpened=false;
    
    private boolean aeReaderRunning=false;
    
    /** the device number, out of all potential compatible devices that could be opened */
    protected int interfaceNumber=0;
    
    
    /** Creates a new instance of USBAEMonitor. Note that it is possible to construct several instances
     * and use each of them to open and read from the same device.
     *@param devNumber the desired device number, in range returned by CypressFX2Factory.getNumInterfacesAvailable
     *@see CypressFX2TmpdiffRetinaFactory
     */
    protected CypressFX2(int devNumber) {
        this.interfaceNumber=devNumber;
//        pnp=new PnPNotify(this);
//        pnp.enablePnPNotification(GUID);
    }
    
    /** returns the SiLabs USBXPress device number to open() */
    int getInterfaceNumber() {
        return interfaceNumber;
    }
    
    /** sets the SiLabs USBXPress device number to open() */
    void setInterfaceNumber(int interfaceNumber) {
        this.interfaceNumber = interfaceNumber;
    }
    
    /** acquire a device for exclusive use, other processes can't open the device anymore
     * used for example for continuous sequencing in matlab */
    public void acquireDevice() throws HardwareInterfaceException {
        status=gUsbIo.acquireDevice();
        if (status != 0) {
            throw new HardwareInterfaceException("Unable to acquire device for exclusive use: " + UsbIo.errorText(status));
        }
    }
    
    /** release the device from exclusive use */
    public void releaseDevice() throws HardwareInterfaceException {
        status=gUsbIo.releaseDevice();
        if (status != 0) {
            throw new HardwareInterfaceException("Unable to release device from exclusive use: " + UsbIo.errorText(status));
        }
    }
    
    public PropertyChangeSupport getSupport() {
        return this.support;
    }
    
    public String toString() {
        return (getClass().getSimpleName() + ": Interface " + getInterfaceNumber());
    }
    
    /** the size in bytes of the EEPROM atttached to the CypressFX2LP */
    public int EEPROM_SIZE=8192;
    
    /** size of control transfer data packets. Actually vendor request allows for larger data buffer, but windows limits largest xfer to 4096. Here we limit largest
     *to size of buffer for control xfers. */
    public final int MAX_CONTROL_XFER_SIZE=64; // max control xfer size
    
    /** this is a BLOCKING write call to write the Cypress EEPROM. Max number of bytes is defined by {@link #EEPROM_SIZE}.
     *@param addr the starting address
     *@param bytes the bytes to write
     */
    synchronized protected void writeEEPROM(int addr, byte[] bytes) throws HardwareInterfaceException{
        
        if(bytes.length>EEPROM_SIZE) throw new RuntimeException(bytes.length+" is too many bytes for EEPROM to hold ("+EEPROM_SIZE+")");
        if(addr<0 || addr+bytes.length>EEPROM_SIZE) throw new RuntimeException(bytes.length+" is too many bytes for EEPROM to hold ("+EEPROM_SIZE+") starting at address "+addr);
        int result; // result of USBIO operations
        USBIO_DATA_BUFFER dataBuffer=null;
        USBIO_CLASS_OR_VENDOR_REQUEST vendorRequest=null;
        
        int numChunks, index;
        
        // make vendor request structure and populate it
        vendorRequest=new USBIO_CLASS_OR_VENDOR_REQUEST();
        
        
        vendorRequest.Request=VR_EEPROM; // this is EEPROM command, direction of vendor request defines download here
        
        vendorRequest.Flags=UsbIoInterface.USBIO_SHORT_TRANSFER_OK;
        vendorRequest.Type=UsbIoInterface.RequestTypeVendor;  // this is a vendor, not generic USB, request
        vendorRequest.Recipient=UsbIoInterface.RecipientDevice; // device (not endpoint, interface, etc) receives it
        vendorRequest.RequestTypeReservedBits=0;    // set these bits to zero for Cypress-specific 'vendor request' rather that user defined
        vendorRequest.Index=0;
        
        //send all but last chunk
        vendorRequest.Value = (short)addr;			//address to write to (starting)
        dataBuffer=new USBIO_DATA_BUFFER(MAX_CONTROL_XFER_SIZE);
        dataBuffer.setNumberOfBytesToTransfer(dataBuffer.Buffer().length);
        index=0;
        numChunks=bytes.length/MAX_CONTROL_XFER_SIZE;  // this is number of full chunks to send
        for(int i=0;i<numChunks;i++){
            System.arraycopy(bytes, i*MAX_CONTROL_XFER_SIZE, dataBuffer.Buffer(), 0, MAX_CONTROL_XFER_SIZE);
            result=gUsbIo.classOrVendorOutRequest(dataBuffer,vendorRequest);
            if(result!=USBIO_ERR_SUCCESS){
                close();
                throw new HardwareInterfaceException("Error on downloading segment number "+i+" of EEPROM write: "+UsbIo.errorText(result));
            }
            vendorRequest.Value += MAX_CONTROL_XFER_SIZE;			//change address of EEPROM write location
        }
        
        // now send final (short) chunk
        int numBytesLeft=bytes.length%MAX_CONTROL_XFER_SIZE;  // remainder
        if(numBytesLeft>0){
            dataBuffer=new USBIO_DATA_BUFFER(numBytesLeft);
            dataBuffer.setNumberOfBytesToTransfer(dataBuffer.Buffer().length);
            System.arraycopy(bytes, numChunks*MAX_CONTROL_XFER_SIZE, dataBuffer.Buffer(), 0, numBytesLeft);
            
            // send remaining part of firmware
            result=gUsbIo.classOrVendorOutRequest(dataBuffer,vendorRequest);
            if(result!=USBIO_ERR_SUCCESS){
                close();
                throw new HardwareInterfaceException("Error on downloading final segment of EEPROM write: "+UsbIo.errorText(result));
            }
        }
        
    } // writeEEPROM
    
    /** erases the VID/PID/DID and device identifier strings */
    synchronized protected void eraseEEPROM() throws HardwareInterfaceException{
        writeEEPROM(0,new byte[EEPROM_SIZE]);
    }
    
    /** read the EEPROM contents
     *@param addr the starting address
     *@param length the number of bytes to read
     */
    synchronized protected byte[] readEEPROM(int addr, int length) throws HardwareInterfaceException{
        int result;
        if(length>EEPROM_SIZE) throw new RuntimeException(length+" is more bytes than EEPROM can hold ("+EEPROM_SIZE+")");
        if(addr<0 || addr+length>EEPROM_SIZE) throw new RuntimeException(length+" is too many bytes to read from EEPROM which holds "+EEPROM_SIZE+" bytes, if you start at address "+addr);
        
        USBIO_DATA_BUFFER dataBuffer=null;
        USBIO_CLASS_OR_VENDOR_REQUEST vendorRequest=null;
        
        byte[] uploadBuffer=new byte[length];
        
        // make vendor request structure and populate it
        vendorRequest=new USBIO_CLASS_OR_VENDOR_REQUEST();
        vendorRequest.Request=VR_EEPROM; // this is download/upload EEPROM command, direction of vendor request defines upload to host
        
        vendorRequest.Flags=UsbIoInterface.USBIO_SHORT_TRANSFER_OK;
        vendorRequest.Type=UsbIoInterface.RequestTypeVendor;  // this is a vendor, not generic USB, request
        vendorRequest.Recipient=UsbIoInterface.RecipientDevice; // device (not endpoint, interface, etc) receives it
        vendorRequest.RequestTypeReservedBits=0;    // set these bits to zero for Cypress-specific 'vendor request' rather that user defined
        vendorRequest.Index=0;
        
        dataBuffer=new USBIO_DATA_BUFFER(length);
        int bytesTransferred=0;
        dataBuffer.setNumberOfBytesToTransfer(length);
        vendorRequest.Value=(short)addr; // this is EEPROM addr to read from for this chunk
        result=gUsbIo.classOrVendorInRequest(dataBuffer, vendorRequest);  // IN request defines direction, so will be understood as read EEPROM on device
        if(result!=USBIO_ERR_SUCCESS){
            close();
            throw new HardwareInterfaceException("Error during uploading EEPROM: "+UsbIo.errorText(result));
        }
        if(dataBuffer.getBytesTransferred()!=length){
            throw new HardwareInterfaceException("wrong number of bytes transferred, asked for "+length+", got "+dataBuffer.getBytesTransferred());
        }
        System.arraycopy(dataBuffer.Buffer(), 0, uploadBuffer, 0, length);
        
        return uploadBuffer;
    }
    
    
    /** writes the Cypress "C0" load to the EEPROM that makes the Cypress have a Vender, Product, and Device ID on powerup.
     *@param VID
     *@param PID
     *@param DID the 'device' ID, can be used to individualize devices
     */
    synchronized public void writeVIDPIDDID(short VID, short PID, short DID) throws HardwareInterfaceException{
        byte[] b=new byte[8];
        b[0]=(byte)0xC0;
        b[1]=(byte)(VID&0xFF);    // vid LSB
        b[2]=(byte)((VID&0xFF00)>>>8); // vid MSB
        b[3]=(byte)(PID&0xFF);
        b[4]=(byte)((PID&0xFF00)>>>8);
        b[5]=(byte)(DID&0xFF);
        b[6]=(byte)((DID&0xFF00)>>>8);
        b[7]=(byte)(0); // configuration byte, DISCON=0 (not disconnected after reset), 400kHz=0 (100kHz I2C  bus)
        
        writeEEPROM(0,b);
    }
    
    
    /** writes the Cypress "C2" load to the EEPROM that makes the Cypress have EEPROM firmware, including VID, PID, DID.
     *@param VID
     *@param PID
     *@param DID the 'device' ID, can be used to individualize devices
     *@param firmwareFilename a File containing the binary format firmware as output from hex2bix. This is a flat firmware format that starts at address 0.
     */
    public void writeC2Load(String firmwareFilename, short VID, short PID, short DID) throws HardwareInterfaceException{
        byte[] fw=null;
        
        try{
            fw=loadBinaryFirmwareFile(firmwareFilename);
        }catch(IOException e){
            throw new HardwareInterfaceException(e.getMessage());
        }
        
        byte[] b=new byte[12];
        b[0]=(byte)0xC2;
        b[1]=(byte)(VID&0xFF);    // vid LSB
        b[2]=(byte)((VID&0xFF00)>>>8); // vid MSB
        b[3]=(byte)(PID&0xFF);
        b[4]=(byte)((PID&0xFF00)>>>8);
        b[5]=(byte)(DID&0xFF);
        b[6]=(byte)((DID&0xFF00)>>>8);
        b[7]=(byte)(0); // configuration byte, DISCON=0 (not disconnected after reset), 400kHz=0 (100kHz I2C  bus)
        
        b[8]=(byte)((fw.length&0xFF00)>>>8);
        b[9]=(byte)((fw.length&0xFF));
        b[10]=0;
        b[11]=0;
        
        byte[] end=new byte[5];
        end[0]=(byte)0x80;
        end[1]=(byte)0x01;
        end[2]=(byte)0xe6;
        end[4]=0;
        
        byte[] w=new byte[b.length+fw.length+end.length];
        System.arraycopy(b,0,w,0,b.length);
        System.arraycopy(fw,0,w,b.length,fw.length);
        System.arraycopy(end,0,w,b.length+fw.length,end.length);
        
        
        writeEEPROM(0,w);
    }
    
    
    /** writes the Cypress "C2" load to the EEPROM that makes the Cypress have EEPROM firmware, including VID, PID, DID.
     *@param VID
     *@param PID
     *@param DID the 'device' ID, can be used to individualize devices
     *@param hexFileResourcePath a full path pointing to a resource containing the firmware as output from compiler in Intel hex format. This resource is a file that is somewhere in the classpath, i.e. it is a file
     *that is included in the project jar. For example: "/ch/unizh/ini/caviar/hardwareinterface/usb/USBAER_FX2LP_Retina.hex"
     *@see #FIRMWARE_FILENAME_TMPDIFF128_HEX
     *@see #FIRMWARE_FILENAME_MONITOR_SEQUENCER_HEX
     */
    synchronized public void writeHexFileToEEPROM(String hexFileResourcePath, short VID, short PID, short DID) throws HardwareInterfaceException{
        
        HexFileParser parser;
        try{
            parser=new HexFileParser(hexFileResourcePath);
        }catch(FileNotFoundException e){
            throw new HardwareInterfaceException(e.getMessage()+": cannot open resource "+hexFileResourcePath);
        }catch(IOException e2){
            throw new HardwareInterfaceException(e2.getMessage()+": cannot open resource "+hexFileResourcePath);
            
        }
        ArrayList<HexFileParser.Record> records=parser.getRecords();
        int index=0;
        byte[] b;
        
        b=new byte[12];
        b[0]=(byte)0xC2; // write C2 load format header
        b[1]=(byte)(VID&0xFF);    // vid LSB
        b[2]=(byte)((VID&0xFF00)>>>8); // vid MSB
        b[3]=(byte)(PID&0xFF);
        b[4]=(byte)((PID&0xFF00)>>>8);
        b[5]=(byte)(DID&0xFF);
        b[6]=(byte)((DID&0xFF00)>>>8);
        b[7]=(byte)(0); // configuration byte, DISCON=0 (not disconnected after reset), 400kHz=0 (100kHz I2C  bus)
        
        writeEEPROM(0,b); // write VID/PID etc header starting at addr 0
        
        index+=b.length;
        
        // now for each hex file record, we must write this record, contiguous with the last one, and each record written to
        // flash must contain the starting address of how many bytes there are (up to 1023) and where the memory should go.
        // now write hex file records, one by one
        for(HexFileParser.Record r:records){
            b=new byte[4];
            b[0]=(byte)((r.data.length&0xFF00)>>>8);
            b[1]=(byte)((r.data.length&0xFF));
            b[2]=(byte)((r.address&0xFF00)>>>8);
            b[3]=(byte)((r.address&0xFF));
            writeEEPROM(index,b);
            index+=b.length;
            writeEEPROM(index, r.data);
            index+=r.data.length;
        }
        
        // now write footer
        
        b=new byte[5];
        b[0]=(byte)0x80;
        b[1]=(byte)0x01;
        b[2]=(byte)0xe6;
        b[3]=(byte)0;
        b[4]=0;
        
        writeEEPROM(index,b);
        index+=b.length;
        
    }
    
    /** downloads firmware to the FX2 RAM from a hex file.
     *@param hexFileResourcePath a full path pointing to a resource containing the firmware as output from compiler in Intel hex format. This resource is a file that is somewhere in the classpath, i.e. it is a file
     *that is included in the project jar. For example: "/ch/unizh/ini/caviar/hardwareinterface/usb/USBAER_FX2LP_Retina.hex"
     *@see #FIRMWARE_FILENAME_TMPDIFF128_HEX
     *@see #FIRMWARE_FILENAME_MONITOR_SEQUENCER_HEX
     */
    synchronized public void downloadFirmwareHex(String hexFileResourcePath) throws HardwareInterfaceException{
        
        HexFileParser parser;
        try{
            parser=new HexFileParser(hexFileResourcePath);
        }catch(FileNotFoundException e){
            throw new HardwareInterfaceException(e.getMessage()+": cannot open resource "+hexFileResourcePath);
        }catch(IOException e2){
            throw new HardwareInterfaceException(e2.getMessage()+": cannot open resource "+hexFileResourcePath);
            
        }
        ArrayList<HexFileParser.Record> records=parser.getRecords();
        
        set8051Reset(true);
        
        // now for each hex file record, we must write this record, contiguous with the last one, and each record written to
        // flash must contain the starting address of how many bytes there are (up to 1023) and where the memory should go.
        // now write hex file records, one by one
        for(HexFileParser.Record r:records){
            download8051RAM(r.address, r.data);
        }
        
        set8051Reset(false);
    }
    
    
    /** adds a listener for new events captured from the device. 
     Actually gets called whenever someone looks for new events and there are some using
     acquireAvailableEventsFromDriver, not when data is actually captured by AEReader.
     Thus it will be limited to the users sampling rate, e.g. the game loop rendering rate.
     
     * @param listener the listener. It is called with a PropertyChangeEvent when new events
     * are received by a call to {@link #acquireAvailableEventsFromDriver}.
     * These events may be accessed by calling {@link #getEvents}.
     */
    public void addAEListener(AEListener listener) {
        support.addPropertyChangeListener(listener);
    }
    
    public void removeAEListener(AEListener listener) {
        support.removePropertyChangeListener(listener);
    }
    
    /** starts reader buffer pool thread and enables in endpoints for AEs */
    public void startAEReader() throws HardwareInterfaceException {  // raphael: changed from private to protected, because i need to access this method
        int status=0; // don't use global status in this function
        // bind pipe
        
        if(aeReaderRunning){
            log.warning("CypressFX2.startAEReader(): already running");
            return;
        }
        
        // start the thread that listens for device status information (e.g. timestamp reset)
        // asyncStatusThread=new AsyncStatusThread(this);
        //asyncStatusThread.start();
        
//        System.out.println("before starting aereader gUsbIo.isOpen()="+gUsbIo.isOpen());
        setAeReader(new AEReader(this));
        
        allocateAEBuffers();
        
        getAeReader().startThread(3); // arg is number of errors before giving up
        
//        Thread.currentThread().yield();
//        System.out.println("after starting aereader gUsbIo.isOpen()="+gUsbIo.isOpen());
        
        // enableINEndpoint(); already gets enabled in setEventAcquistionEnabled
        HardwareInterfaceException.clearException();
        
    } // startAEReader
    
    long lastTimeEventCaptured=System.currentTimeMillis(); // used for timer to restart IN transfers, in case another connection, e.g. biasgen, has disabled them
    
    /** Gets available events from driver.  {@link HardwareInterfaceException} is thrown if there is an error.
     *{@link #overrunOccurred} will be reset after this call.
     *<p>
     *This method also starts event acquisition if it is not running already.
     *
     *This methods copies the events from the acquisition buffer to new buffers that the user can do anything they want.
     *
     *Thread safe: synchronized on access to the capture buffer.
     *
     * @return number of events acquired. If this is zero there is no point in getting the events, because there are none.
     *@throws HardwareInterfaceException
     *@see #setEventAcquisitionEnabled
     *
     * .
     */
    public AEPacketRaw acquireAvailableEventsFromDriver() throws HardwareInterfaceException {
        if(!isOpened){
            open();
        }
        
        // make sure event acquisition is running
        if(!inEndpointEnabled){
            setEventAcquisitionEnabled(true);
        }
        
//        HardwareInterfaceException.clearException();
        
        // make sure that event translation from driver is allowed to run if need be, to avoid holding up event sender
//        Thread.currentThread().yield();
        
        short[] addresses;
        int[] timestamps;
        int nEvents;
        
        synchronized(captureBufferPool){ // synchronize on aeReader so that we don't try to access the events at the same time
            CaptureBuffer activeBuffer=captureBufferPool.active();
            activeBuffer.overrunOccuredFlag=false;
            addresses=activeBuffer.getAddresses();
            timestamps=activeBuffer.getTimestamps();
            nEvents=activeBuffer.numEvents;
            eventCounter=0;
            captureBufferPool.swap();
        }
        
//        events=new AEPacketRaw(nEvents);
        // reuse same packet to avoid constant new'ing
        events.ensureCapacity(nEvents);
        if(nEvents==0){
            computeEstimatedEventRate(null);
            return events;
        }else{
            System.arraycopy(addresses, 0, events.getAddresses(), 0, nEvents);
            System.arraycopy(timestamps, 0, events.getTimestamps(), 0, nEvents);
            events.setNumEvents(nEvents);
            computeEstimatedEventRate(events);
            support.firePropertyChange(newEventPropertyChange); // call listeners
            return events;
        }
    }
    
    
    /** the max capacity of this USB2 bus interface is 24MB/sec/4 bytes/event
     */
    public int getMaxCapacity() {
        return 6000000;
    }
    
    private int estimateEventRate=0;
    
    /** @return event rate in events/sec as computed from last acquisition.
     *
     */
    public int getEstimatedEventRate() {
        return estimateEventRate;
    }
    
    /** computes the estimated event rate for a packet of events */
    void computeEstimatedEventRate(AEPacketRaw events){
        if(events==null || events.getNumEvents()<2 ) estimateEventRate=0;
        else{
            int[] ts=events.getTimestamps();
            int n=events.getNumEvents();
            int dt=ts[n-1]-ts[0];
            estimateEventRate=(int)(1e6f*(float)n/(float)dt);
        }
    }
    
    /** Returns the number of events acquired by the last call to {@link
     * #acquireAvailableEventsFromDriver }
     * @return number of events acquired
     */
    public int getNumEventsAcquired(){
        return captureBufferPool.active().numEvents;
    }
    
    
    /** reset the timestamps to zero. This has two effects. First it sends a vendor request down the control endpoint
     to tell the device to reset its own internal timestamp counters. Second, it tells the AEReader object to reset its
     timestamps, meaning to reset its unwrap counter.
     */
    synchronized public void resetTimestamps() {
        log.info(this+".resetTimestamps(): zeroing timestamps");
        int status=0; // don't use global status in this function
        dontwrap=true;
        // send vendor request for device to reset timestamps
        if(gUsbIo==null){
            throw new RuntimeException("device must be opened before sending this vendor request");
        }
        
        // make vendor request structure and populate it
        USBIO_CLASS_OR_VENDOR_REQUEST VendorRequest=new USBIO_CLASS_OR_VENDOR_REQUEST();
        
        VendorRequest.Flags=UsbIoInterface.USBIO_SHORT_TRANSFER_OK;
        VendorRequest.Type=UsbIoInterface.RequestTypeVendor;
        VendorRequest.Recipient=UsbIoInterface.RecipientDevice;
        VendorRequest.RequestTypeReservedBits=0;
        VendorRequest.Request=VENDOR_REQUEST_RESET_TIMESTAMPS;
        VendorRequest.Index=0;
        
        VendorRequest.Value=0;
        USBIO_DATA_BUFFER dataBuffer=new USBIO_DATA_BUFFER(1);
        dataBuffer.setNumberOfBytesToTransfer(1);
        //        dataBuffer.Buffer()[0]=1;
        status=gUsbIo.classOrVendorOutRequest(dataBuffer,VendorRequest);
        if(status!=USBIO_ERR_SUCCESS){
            log.warning("CypressFX2.resetTimestamps: couldn't send vendor request to reset timestamps");
        }
        if(getAeReader()!=null)
            getAeReader().resetTimestamps(); // reset wrap counter and flush buffers
        else
            log.warning("CypressFX2.resetTimestamps(): reader not yet started, can't reset timestamps");
    }
    
    
    /** reset the entire pixel array */
    public void resetPixelArray() {
        // send vendor request for device to reset array
        int status=0; // don't use global status in this function
        if(gUsbIo==null){
            throw new RuntimeException("device must be opened before sending this vendor request");
        }
        
        // make vendor request structure and populate it
        USBIO_CLASS_OR_VENDOR_REQUEST VendorRequest=new USBIO_CLASS_OR_VENDOR_REQUEST();
        
        VendorRequest.Flags=UsbIoInterface.USBIO_SHORT_TRANSFER_OK;
        VendorRequest.Type=UsbIoInterface.RequestTypeVendor;
        VendorRequest.Recipient=UsbIoInterface.RecipientDevice;
        VendorRequest.RequestTypeReservedBits=0;
        VendorRequest.Request=VENDOR_REQUEST_DO_ARRAY_RESET;
        VendorRequest.Index=0;
        
        VendorRequest.Value=0;
        USBIO_DATA_BUFFER dataBuffer=new USBIO_DATA_BUFFER(1);
        dataBuffer.setNumberOfBytesToTransfer(1);
        //        dataBuffer.Buffer()[0]=1;
        status=gUsbIo.classOrVendorOutRequest(dataBuffer,VendorRequest);
        if(status!=USBIO_ERR_SUCCESS){
            log.warning("CypressFX2.resetPixelArray: couldn't send vendor request to reset array");
        }
    }
    
    protected boolean arrayResetEnabled=false;
    
    /** set the board LED state. Useful for debugging. Not available for CypressFX2MonitorSequencer
     * @param value true to turn it on, false to turn it off.
     */
    synchronized public void setLed(boolean value) {
        // send vendor request for device to reset array
        int status=0; // don't use global status in this function
        if(gUsbIo==null){
            throw new RuntimeException("device must be opened before sending this vendor request");
        }
        
        // make vendor request structure and populate it
        USBIO_CLASS_OR_VENDOR_REQUEST VendorRequest=new USBIO_CLASS_OR_VENDOR_REQUEST();
        
        VendorRequest.Flags=UsbIoInterface.USBIO_SHORT_TRANSFER_OK;
        VendorRequest.Type=UsbIoInterface.RequestTypeVendor;
        VendorRequest.Recipient=UsbIoInterface.RecipientDevice;
        VendorRequest.RequestTypeReservedBits=0;
        VendorRequest.Request=VENDOR_REQUEST_SET_LED;
        VendorRequest.Index=0;
        
        VendorRequest.Value=(short)(value?0:1);  // this is the request bit, if value true, send value 0, false send value 1
        // on the board, 1 actually turns off the LED because the anode is tied to Vdd and the  cathode to the GPIO output
        
        USBIO_DATA_BUFFER dataBuffer=new USBIO_DATA_BUFFER(0); // no data, value is in request value
        dataBuffer.setNumberOfBytesToTransfer(dataBuffer.Buffer().length);
        
        status=gUsbIo.classOrVendorOutRequest(dataBuffer,VendorRequest);
        if(status!=USBIO_ERR_SUCCESS){
            log.warning("CypressFX2.resetPixelArray: couldn't send vendor request to set LED");
        }
    }

    
    /** Is true if an overrun occured in the driver (><code> AE_BUFFER_SIZE</code> events) during the period before the last time {@link
     * #acquireAvailableEventsFromDriver } was called. This flag is cleared by {@link #acquireAvailableEventsFromDriver}, so you need to
     * check it before you acquire the events.
     *<p>
     *If there is an overrun, the events grabbed are the most ancient; events after the overrun are discarded. The timestamps continue on but will
     *probably be lagged behind what they should be.
     * @return true if there was an overrun.
     */
    public boolean overrunOccurred(){
        synchronized(captureBufferPool){
            return captureBufferPool.active().overrunOccuredFlag;
        }
    }
    
    /** Closes the device. Never throws an exception.
     */
    synchronized public void close(){
        if(!isOpened){
            log.warning("CypressFX2.close(): not open");
            return;
        }
        
        try{
            if (this.isEventAcquisitionEnabled()) {
                setEventAcquisitionEnabled(false);
                stopAEReader();
            }
            if(asyncStatusThread!=null) asyncStatusThread.stopThread();
        }catch(HardwareInterfaceException e){
            e.printStackTrace();
        }
        
        
        gUsbIo.close();
        UsbIo.destroyDeviceList(gDevList);
        log.info("USBIOInterface.close(): device closed");
        isOpened=false;
    }
    
    
    // not really necessary to stop this thread, i believe, because close will unbind already according to usbio docs
    public void stopAEReader() {  // raphael: changed from private to protected, because i need to access this method
        if(getAeReader()!=null){
            //   System.out.println("CypressFX2.stopAEReader(): stopping aeReader thread");
            getAeReader().shutdownThread();
            // unbind pipe
            getAeReader().unbind();
            // close device
            getAeReader().close();
            
            setAeReader(null);
        }
        
        //  asyncStatusThread=null;
    }
    
    /** sends vendor request to trigger an immediate commit of whatever is in the endpoint fifo immediately.
     * next call to <@link #acquireAvailableEventsFromDriver} will get these events if you wait a bit.
     */
    synchronized public void requestEarlyTransfer() throws HardwareInterfaceException {
        // start getting events by sending vendor request 0xb3 to control endpoint 0
        // documented in firmware FX2_to_extFIFO.c
        
        // make vendor request structure and populate it
        USBIO_CLASS_OR_VENDOR_REQUEST VendorRequest=new USBIO_CLASS_OR_VENDOR_REQUEST();
        int status=0; // don't use global status in this function
        
        VendorRequest.Flags=UsbIoInterface.USBIO_SHORT_TRANSFER_OK;
        VendorRequest.Type=UsbIoInterface.RequestTypeVendor;
        VendorRequest.Recipient=UsbIoInterface.RecipientDevice;
        VendorRequest.RequestTypeReservedBits=0;
        VendorRequest.Request=(byte)VENDOR_REQUEST_EARLY_TRANFER;
        VendorRequest.Index=0;
        
        USBIO_DATA_BUFFER dataBuffer=new USBIO_DATA_BUFFER(1);
        VendorRequest.Value=0; // (byte)VENDOR_REQUEST_START_TRANSFER;
        dataBuffer=new USBIO_DATA_BUFFER(1);
        dataBuffer.setNumberOfBytesToTransfer(dataBuffer.Buffer().length);
        dataBuffer.Buffer()[0]=1;
        status=gUsbIo.classOrVendorOutRequest(dataBuffer,VendorRequest);
        if(status!=USBIO_ERR_SUCCESS){
            throw new HardwareInterfaceException("Unable to send vendor request to send events early: "+UsbIo.errorText(status));
        }
        HardwareInterfaceException.clearException();
        
    }
    
    /** @return true if inEndpoint was enabled.
     * However, some other connection (e.g. biasgen) could have disabled the in transfers.
     */
    public boolean isInEndpointEnabled() {
        return this.inEndpointEnabled;
    }
    
    /** sends a vendor request to enable or disable in transfers of AEs
     *@param inEndpointEnabled true to send vendor request to enable, false to send request to disable
     */
    public void setInEndpointEnabled(final boolean inEndpointEnabled) throws HardwareInterfaceException {
        if(inEndpointEnabled)
            enableINEndpoint();
        else
            disableINEndpoint();
    }
    
    synchronized void enableINEndpoint() throws HardwareInterfaceException {
        // start getting events by sending vendor request 0xb3 to control endpoint 0
        // documented in firmware FX2_to_extFIFO.c
//        System.out.println("USBAEMonitor.enableINEndpoint()");
        // make vendor request structure and populate it
        if(gUsbIo==null){
            log.warning("CypressFX2.enableINEndpoint(): null USBIO device");
            return;
        }
        int status=0; // don't use global status in this function
        USBIO_CLASS_OR_VENDOR_REQUEST VendorRequest=new USBIO_CLASS_OR_VENDOR_REQUEST();
        
        VendorRequest.Flags=UsbIoInterface.USBIO_SHORT_TRANSFER_OK;
        VendorRequest.Type=UsbIoInterface.RequestTypeVendor;
        VendorRequest.Recipient=UsbIoInterface.RecipientDevice;
        VendorRequest.RequestTypeReservedBits=0;
        VendorRequest.Request=(byte)VENDOR_REQUEST_START_TRANSFER;
        VendorRequest.Index=0;
        
        VendorRequest.Value=0;
        USBIO_DATA_BUFFER dataBuffer=new USBIO_DATA_BUFFER(0);
        dataBuffer.setNumberOfBytesToTransfer(0);
        status=gUsbIo.classOrVendorOutRequest(dataBuffer,VendorRequest);
        if(status!=USBIO_ERR_SUCCESS){
            close();
            throw new HardwareInterfaceException("Unable to send vendor request to send events: "+UsbIo.errorText(status));
        }else
            inEndpointEnabled=true;
        HardwareInterfaceException.clearException();
    }
    
    
    synchronized void disableINEndpoint(){
        // stop endpoint sending events by sending vendor request 0xb4 to control endpoint 0
        // these requests are docuemented in firmware file FX2_to_extFIFO.c
        
        // make vendor request structure and populate it
        int status=0; // don't use global status in this function
        USBIO_CLASS_OR_VENDOR_REQUEST VendorRequest=new USBIO_CLASS_OR_VENDOR_REQUEST();
        
        VendorRequest.Flags=UsbIoInterface.USBIO_SHORT_TRANSFER_OK;
        VendorRequest.Type=UsbIoInterface.RequestTypeVendor;
        VendorRequest.Recipient=UsbIoInterface.RecipientDevice;
        VendorRequest.RequestTypeReservedBits=0;
        VendorRequest.Request=VENDOR_REQUEST_STOP_TRANSFER;
        VendorRequest.Index=0;
        
        VendorRequest.Value=0;
        USBIO_DATA_BUFFER dataBuffer=new USBIO_DATA_BUFFER(0);
        dataBuffer.setNumberOfBytesToTransfer(0);
        status=gUsbIo.classOrVendorOutRequest(dataBuffer,VendorRequest);
        if(status!=USBIO_ERR_SUCCESS){
            log.info("disableINEndpoint: couldn't send vendor request to disable IN transfers--it could be that device is gone or sendor is OFF and and completing GPIF cycle");
        }else
            inEndpointEnabled=false;
        HardwareInterfaceException.clearException();
    }
    
    class AsyncStatusThread extends Thread {
        UsbIoPipe pipe;
        CypressFX2 monitor;
        boolean stop=false;
        byte msg;
        AsyncStatusThread(CypressFX2 monitor) throws HardwareInterfaceException {
            this.monitor=monitor;
        }
        
        public void stopThread(){
            if (pipe!=null)
                pipe.abortPipe();
            interrupt();
        }
        
        public void run(){
            int status;
            UsbIoBuf buffer=new UsbIoBuf(64); // size of EP1
            pipe=new UsbIoPipe();
            status=pipe.bind(monitor.getInterfaceNumber(), STATUS_ENDPOINT_ADDRESS, gDevList, GUID);
            if(status!=USBIO_ERR_SUCCESS){
                log.warning("error binding to pipe for EP1 for device status: "+UsbIo.errorText(status));
            }
            USBIO_PIPE_PARAMETERS pipeParams=new USBIO_PIPE_PARAMETERS();
            pipeParams.Flags=UsbIoInterface.USBIO_SHORT_TRANSFER_OK;
            status=pipe.setPipeParameters(pipeParams);
            if (status != USBIO_ERR_SUCCESS) {
                log.warning("can't set pipe parameters: "+UsbIo.errorText(status));
            }
            while(!stop && !isInterrupted()){
                buffer.NumberOfBytesToTransfer=64;
                status=pipe.read(buffer);
                if (status == 0) {
                    log.warning("Stopping status thread: error reading status pipe: "+UsbIo.errorText(buffer.Status));
                    break;
                }
                status=pipe.waitForCompletion(buffer);
                if (status != 0 && buffer.Status!=UsbIoErrorCodes.USBIO_ERR_CANCELED) {
                    log.warning("Stopping status thread: error waiting for completion of read on status pipe: "+UsbIo.errorText(buffer.Status));
                    break;
                }
                if(buffer.BytesTransferred>0){
                    msg=buffer.BufferMem[0];
                    if(msg==1){
                        AEReader rd= getAeReader();
                        if (rd!=null) {
                            log.info("*********************************** CypressFX2.AsyncStatusThread.run(): timestamps externally reset");
                            rd.resetTimestamps();
                        } else {
                            log.info("Received timestamp external reset message, but monitor is not running");
                        }
                    }
                }else{
                    log.warning("warning, 0 bytes in asyncStatusThread");
                }
            }
//            System.out.println("Status reader thread terminated.");
        } // run()
    }
    
    protected boolean relativeTimestampMode=false; //raphael: need this variable to branch in AEReader
    volatile boolean dontwrap=false; // used for resetTimestamps
    
    int aeReaderFifoSize=prefs.getInt("CypressFX2.AEReader.fifoSize",8192);
    
    /** sets the buffer size for the aereader thread. optimal size depends on event rate, for high event
     *  rates, at least 4096 bytes should be chosen, using caviarviewer and low event rates need smaller
     *  buffer size to produce suitable frame rates*/
    public void setAEReaderFifoSize(int size) {
        this.aeReaderFifoSize=size;
        prefs.putInt("CypressFX2.AEReader.fifoSize",size);
    }
    
    int aeReaderNumBuffers=prefs.getInt("CypressFX2.AEReader.numBuffers",4);
    
    
    /** sets the number of buffers for the aereader thread.*/
    public void setAEReaderNumBuffers(int num) {
        this.aeReaderNumBuffers=num;
        prefs.putInt("CypressFX2.AEReader.numBuffers",num);
    }
    
    
    /**
     * AE reader class. the thread continually reads events into buffers. when a buffer is read, ProcessData transfers and transforms the buffer data to AE address
     * and timestamps information and puts it in the addresses and timestamps arrays. a call to acquireAvailableEventsFromDriver copies the events to enw user
     * arrays that can be accessed by getEvents() (this packet is also returned by {@link #acquireAvailableEventsFromDriver}). The relevant methods are synchronized so are thread safe.
     */
    public class AEReader extends UsbIoReader implements ReaderBufferControl{
        
        /** the priority for this acquisition thread. This should be set high (e.g. Thread.MAX_PRIORITY) so that the thread can
         * start new buffer reads in a timely manner so that the sender does not get blocked
         * */
        public static final int PRIORITY=Thread.MAX_PRIORITY; // Thread.NORM_PRIORITY+2
        
        /** size of CypressFX2 USB fifo's in bytes. */
        public static final int CYPRESS_FIFO_SIZE=512;
        
        /** the default number of USB read buffers used in the reader */
        public static final int CYPRESS_NUM_BUFFERS=2;
        
        /** the number of capture buffers for the buffer pool for the translated address-events.
         * These buffers allow for smoother access to buffer space by the event capture thread */
        private int numBuffers=prefs.getInt("CypressFX2.AEReader.numBuffers",CYPRESS_NUM_BUFFERS);
        
        /** size of FIFOs in bytes used in AEReader for event capture from device.
         * This does not have to be the same size as the FIFOs in the CypressFX2 (512 bytes). If it is too small, then there
         * are frequent thread context switches that can greatly slow down rendering loops.
         */
        private int fifoSize=prefs.getInt("CypressFX2.AEReader.fifoSize",CYPRESS_FIFO_SIZE); // 512;
        CypressFX2 monitor=null;
        
        public AEReader(CypressFX2 m) throws HardwareInterfaceException {
            super();
            monitor=m;
            
            fifoSize=monitor.aeReaderFifoSize;
            numBuffers=monitor.aeReaderNumBuffers;
            
            int status;
            status = bind(monitor.getInterfaceNumber(),AE_MONITOR_ENDPOINT_ADDRESS, gDevList, GUID); // device has already been opened so we don't need all the params
            if (status != USBIO_ERR_SUCCESS) {
                throw new HardwareInterfaceException("can't bind pipe: "+UsbIo.errorText(status));
            }
            
            USBIO_PIPE_PARAMETERS pipeParams=new USBIO_PIPE_PARAMETERS();
            pipeParams.Flags=UsbIoInterface.USBIO_SHORT_TRANSFER_OK;
            status=setPipeParameters(pipeParams);
            if (status != USBIO_ERR_SUCCESS) {
                throw new HardwareInterfaceException("can't set pipe parameters: "+UsbIo.errorText(status));
            }
        }
        
        // called before buffer is submitted to driver
        public void processBuffer(UsbIoBuf Buf) {
            Buf.NumberOfBytesToTransfer = Buf.Size;
            Buf.BytesTransferred = 0;
            Buf.OperationFinished = false;
            //            System.out.println("ProcessBuffer (before read)");
        }
        
        /** Resets the timestamp unwrap value, resets the USBIO pipe, and reallocates the memory for the CaptureBufferPool. 
         */
        synchronized public void resetTimestamps(){
            log.info("wrapAdd="+wrapAdd+", zeroing it");
            wrapAdd=WRAP_START;
            lasttimestamp=0;
            lastshortts=0;
            resetPipe(); // make sure to flush all the buffers
            synchronized(captureBufferPool){
                captureBufferPool.active().allocateMemory();
            }
        }
        
        int cycleCounter=0;
//        SpikeSound pop=new SpikeSound();
        
        /** called when buffer is received from driver
         @param Buf the data buffer with raw data
         */
        public void processData(UsbIoBuf Buf) {
            cycleCounter++;
//               System.out.print(".");
//                if(cycleCounter%80==0) System.out.println("");
//                System.out.flush();
            if (Buf.Status == USBIO_ERR_SUCCESS || Buf.Status==USBIO_ERR_CANCELED ) {
                //                System.out.println("ProcessData: "+Buf.BytesTransferred+" bytes transferred: ");
                if ((monitor.getVIDPID()[1]==PID_USBAERmini2) || (monitor.getVIDPID()[1]==monitor.PID_USB2AERmapper)) {
                    translateEvents_EmptyWrapEvent(Buf);
                } else {
                    translateEvents(Buf);
                }
//                pop.play();
            } else {
                log.warning("ProcessData: Bytes transferred: " + Buf.BytesTransferred + "  Status: " + UsbIo.errorText(Buf.Status));
                monitor.close();
            }
        }
        
        
        // sync so that we don't try to copy events while buffer is being translated
        // this method extracts addresses and timestamps and copies them to the instance addresses and timestamps arrays, where they will be accessed
        // later by the acquireAvailableEventsFromDriver method (which copies them to returned user arrays)
        
        // note timestamps are multiplied by 10 so that they are in us, because the cypress fx2 retina board uses the
        // timer1 interrupt with period 10us to clock the timestamps counters
        
        final int REAL_WRAP_TIME_MS=(1<<16)/1000; // this is wrap time in ms on device timestamp counter, e.g. 650ms
        // it is used below to check for bogus timetamp wraps due to glitches in sampling timestamp counter output
        long lastWrapTimeMs=System.currentTimeMillis();
        
        int lastshortts=0, tsinccounter=0;
        int lasttimestamp=0;
        
//        final long START=(1L<<30L);
        final int WRAP_START=0; //(int)(0xFFFFFFFFL&(2147483648L-0x400000L)); // set high to test big wrap 1<<30;
        
        // wrapAdd is the time to add to short timestamp to unwrap it
        int wrapAdd=WRAP_START; //0;
        int lastWrapAdd=0;
        boolean wrappedBig=false;  // indicates that wrapAdd has just wrapped itself, so that we should allow nonmonotonic timestamp
        
        /** Populates the AE array, translating from raw bufffer data to raw addresses and unwrapped timestamps.
         *<p>
         * ae and timestamps are sent from USB device in BIG-ENDIAN format. MSB comes first,
         * The addresses are simply copied over, and the timestamps are unwrapped to make uint32 timestamps.
         * wrapping is detected when the present timestamp is less than the previous one.
         * then we assume the counter has wrapped--but only once--and add into this and subsequent
         * timestamps the wrap value of 2^16. this offset is maintained and increases every time there
         * is a wrap. hence it integrates the wrap offset.
         * the timestamp is returned in 1us ticks.
         * this conversion is to make values more compatible with other CAVIAR software components.
         *<p>
         *If an overrun has occurred, then the data is still translated up to the overrun.
         */
        protected void translateEvents(UsbIoBuf b){
            /* the following bit errors in timestamps appeared on Tmpdiff128 small board:
             ************* BAD WRAP: shortts=0x00000769 lastshortts=0x0000d761 wraps=0
             ************ BAD WRAP: shortts=0x0000fcff lastshortts=0x0000fdff wraps=13
             ************ BAD WRAP: shortts=0x00000000 lastshortts=0x0000ffff wraps=14
             ************ BAD WRAP: shortts=0x000071ff lastshortts=0x000073ff wraps=38
             ************ BAD WRAP: shortts=0x00000000 lastshortts=0x0000ffff wraps=39
             ************ BAD WRAP: shortts=0x0000b5ff lastshortts=0x0000b7ff wraps=46
             ************ BAD WRAP: shortts=0x00000001 lastshortts=0x0000ffff wraps=47
             ************ BAD WRAP: shortts=0x0000b1ff lastshortts=0x0000b3ff wraps=59
             ************ BAD WRAP: shortts=0x00000000 lastshortts=0x0000ffff wraps=60
             ************ BAD WRAP: shortts=0x0000b1ff lastshortts=0x0000b3ff wraps=62
             ************ BAD WRAP: shortts=0x00000000 lastshortts=0x0000ffff wraps=63
             ************ BAD WRAP: shortts=0x000059ff lastshortts=0x00005bff wraps=65
             ************ BAD WRAP: shortts=0x00000000 lastshortts=0x0000ffff wraps=66
0 	0x0	0000
1 	0x1	0001
2 	0x2	0010
3 	0x3	0011
4 	0x4	0100
5 	0x5	0101
6 	0x6	0110
7 	0x7	0111
8 	0x8	1000
9 	0x9	1001
10 	0xa	1010
11 	0xb	1011
12 	0xc	1100
13 	0xd	1101
14 	0xe	1110
15 	0xf	1111
             *
             *
             *The following was happening on one Tmpdiff128 board (first version) before soldering down the counters on the board again
getStringDescriptor 2: Tmpdiff128 Retina (Cypress FX2LP)
             ************ BAD WRAP: Real dt=281 ms, shortts=0x00000000 lastshortts=0x0000ffb8 wraps=0
             ************ BAD WRAP: Real dt=141 ms, shortts=0x000035ff lastshortts=0x000037ff wraps=29
             ************ BAD WRAP: Real dt=78 ms, shortts=0x00000000 lastshortts=0x0000ffff wraps=30
             ************ BAD WRAP: Real dt=219 ms, shortts=0x000051ff lastshortts=0x000053ff wraps=31
             ************ BAD WRAP: Real dt=468 ms, shortts=0x0000a5ff lastshortts=0x0000afff wraps=32
             ************ BAD WRAP: Real dt=109 ms, shortts=0x00000000 lastshortts=0x0000ffff wraps=33
             ************ BAD WRAP: Real dt=94 ms, shortts=0x00000000 lastshortts=0x0000ffff wraps=35
             ************ BAD WRAP: Real dt=328 ms, shortts=0x00007cff lastshortts=0x00007dff wraps=36
             ************ BAD WRAP: Real dt=328 ms, shortts=0x000079ff lastshortts=0x00007bff wraps=38
             ************ BAD WRAP: Real dt=500 ms, shortts=0x0000b5ff lastshortts=0x0000b7ff wraps=41
             ************ BAD WRAP: Real dt=141 ms, shortts=0x000031ff lastshortts=0x000033ff wraps=45
             ************ BAD WRAP: Real dt=250 ms, shortts=0x000002b8 lastshortts=0x00005a72 wraps=0
             ************ BAD WRAP: Real dt=375 ms, shortts=0x00000073 lastshortts=0x00008cf5 wraps=0
             ************ BAD WRAP: Real dt=375 ms, shortts=0x000089ff lastshortts=0x00008bff wraps=6
             *
             */
            
//            System.out.println("buf has "+b.BytesTransferred+" bytes");
            synchronized(captureBufferPool){
                if(captureBufferPool.active().overrunOccuredFlag) return;  // don't bother if there's already an overrun, consumer must get the events to clear this flag before there is more room for new events
                int shortts;
                byte[] aeBuffer=b.BufferMem;
                //            byte lsb,msb;
                int bytesSent=b.BytesTransferred;
                if(bytesSent%4!=0){
//                System.out.println("CypressFX2.AEReader.translateEvents(): warning: "+bytesSent+" bytes sent, which is not multiple of 4");
                    bytesSent=(bytesSent/4)*4; // truncate off any extra part-event
                }
                
                CaptureBuffer activeBuffer=captureBufferPool.active();
                
                short[] addresses=activeBuffer.getAddresses();
                int[] timestamps=activeBuffer.getTimestamps();
                
                long timeNowMs=System.currentTimeMillis();
                
                realTimeEventCounterStart=eventCounter;
                
                for(int i=0;i<bytesSent;i+=4){
                    if(eventCounter>AE_BUFFER_SIZE-1){
                        activeBuffer.overrunOccuredFlag=true;
//                                        log.warning("overrun");
                        return; // return, output event buffer is full and we cannot add any more events to it.
                        //no more events will be translated until the existing events have been consumed by acquireAvailableEventsFromDriver
                    }
                    // according to FX2 tech ref manual 10.2.8, words from GPIF databus are sent over usb as LSB then MSB.
                    // therefore AE07 come first, then AE8-15, then TS0-7, then TS8-15
                    // see this useful URL: http://www.rgagnon.com/javadetails/java-0026.html about converting singed bytes to int as unsigned
                    // address is LSB MSB
                    addresses[eventCounter]=(short)(0xffff&((short)aeBuffer[i]&0xff | ((short)aeBuffer[i+1]&0xff)<<8));
                    
                    // same for timestamp, LSB MSB
                    shortts=(aeBuffer[i+2]&0xff | ((aeBuffer[i+3]&0xff)<<8)); // this is 16 bit value of timestamp in TICK_US tick
                    
                    // shortts could be a negative short value, but each ts should be greater than the last one until 16 bit rollover
                    // tobi added following heuristic 12/05 to help deal with problem bit in timestamp counter that apparently gets read incorrectly
                    // occasionally, leading to excessive numbers of timestamp wraps
                    // if this bit is not set in the current timestamp but IS set in the lasttimestamp, don't count this as a wrap
//                    final int pat2=0x02ff, pat1=0x00ff;
//                    if(shortts<lastshortts &&  !((shortts&pat1)==pat1 && (lastshortts&pat2)==pat2) ){ // if new counter value is less than previous one, assume counter has wrapped around.
                    
                    // the preceeding special condition taken out after resoldering the Tmpdiff128 FX2 board that tobi had in pasadena was resoldered, this
                    // flakiness went away
                    
                    if(shortts<lastshortts){
                        // if new counter value is less than previous one, assume counter has wrapped around.
                        if(dontwrap){
                            dontwrap=false;
                        }else{
                            if(timeNowMs-lastWrapTimeMs<REAL_WRAP_TIME_MS){
                                // this is NOT a real wrap, caused by glitch in sampling counter output during count change or something wierd
                                long dt=timeNowMs-lastWrapTimeMs;
                                System.out.println("*** BAD WRAP: Event #"+eventCounter+" Real dt="+dt+" ms, shortts="
                                        +HexString.toString(shortts)+" lastshortts="
                                        +HexString.toString(lastshortts)+" wraps="+wrapAdd/0x10000L);
                                // if this is a bad wrap, then keep the last shortts instead of choosing the one that goes backwards in time
//                            shortts=lastshortts;
//                            badwrap=true;
                                // this has problem that lastshortts doesn't get updated, so there can be a lot of bad wraps signaled.
                            }else{
                                // this IS a real counter wrap
                                // now we need to increment the wrapAdd
                                lastWrapAdd=wrapAdd;
                                wrapAdd+=   0x10000*TICK_US_BOARD;	// we put the tick here to correctly detect big wraps // This is 0xFFFF +1; if we wrapped then increment wrap value by 2^16
//                                if(wrapAdd<lastWrapAdd) {
//                                    wrappedBig=true;
//                                }else {
//                                    wrappedBig=false;
//                                }
                                lastWrapTimeMs=timeNowMs;
//                                System.out.println("inc wrapAdd to "+wrapAdd/0x10000L+" wraps");
                            }
                        }
                    }
                    
                    lastshortts=shortts;	// save last timestamp to check for rollover
                    int thistimestamp=(int)(   TICK_US_BOARD*shortts  +wrapAdd    ); //*TICK_US; //add in the wrap offset and convert to 1us tick
                    
                    // don't let timestamps go backwards in time, UNLESS the wrapAdd has wrapped
                    if(thistimestamp<lasttimestamp && !( (wrapAdd & 0x80000000) !=0 ) ) {
                        thistimestamp=lasttimestamp;
                    }
                    
                    
                    if(false){
                        // if shortts is the same as last value, inc the timestamp by 1us to retain some order, at least for first 10 events
                        if(shortts==lastshortts){
                            if(tsinccounter++<10) thistimestamp++;
                        }else {
                            tsinccounter=0;
                        }
                    }
                    
                    timestamps[eventCounter]=thistimestamp;
                    lasttimestamp=thistimestamp;
                    eventCounter++;
                    activeBuffer.numEvents=eventCounter;
                }
                //            if(eventCounter<2){
                //                int j=i+1;
                //                System.out.println("aeBuffer["+i+"]="+HexString.byteToHexString(aeBuffer[i])+" aeBuffer["+j+"]="+HexString.byteToHexString(aeBuffer[i+1])
                //                +" addr="+HexString.shortToHexString(addresses[eventCounter-1]));
                //            }
                
                // here we do the realTimeFiltering. We finished capturing this buffer's worth of events, now process them
                realTimeFilter(eventCounter,addresses,timestamps);
                
            } // sync on captureBufferPool
        }
        
        /** Function to translate the UsbIoBuffer, when the USBAERmini2 board is used. Here,
         * the wrapAdd is increased, when an emtpy event is received, which has the timestamp bit 16
         * set to one.
         * therefore, for a valid event, only 15 bits of the 16 transmitted timestamp bits are valid, bit 16
         * is the status bit. overflow happens every 32 ms.
         * This way, no roll overs go by undetected, and the problem of invalid wraps doesn't arise.
         */
        protected void translateEvents_EmptyWrapEvent(UsbIoBuf b){
            
//            System.out.println("buf has "+b.BytesTransferred+" bytes");
            synchronized(captureBufferPool){
                if(captureBufferPool.active().overrunOccuredFlag) return;  // don't bother if there's already an overrun, consumer must get the events to clear this flag before there is more room for new events
                int shortts;
                int NumberOfWrapEvents;
                NumberOfWrapEvents=0;
                
                byte[] aeBuffer=b.BufferMem;
                //            byte lsb,msb;
                int bytesSent=b.BytesTransferred;
                if(bytesSent%4!=0){
//                System.out.println("CypressFX2.AEReader.translateEvents(): warning: "+bytesSent+" bytes sent, which is not multiple of 4");
                    bytesSent=(bytesSent/4)*4; // truncate off any extra part-event
                }
                
                short[] addresses=captureBufferPool.active().getAddresses();
                int[] timestamps=captureBufferPool.active().getTimestamps();
                
                for(int i=0;i<bytesSent;i+=4){
                    if(eventCounter>AE_BUFFER_SIZE-1){
                        captureBufferPool.active().overrunOccuredFlag=true;
//                                        log.warning("overrun");
                        return; // return, output event buffer is full and we cannot add any more events to it.
                        //no more events will be translated until the existing events have been consumed by acquireAvailableEventsFromDriver
                    }
                    
                    if((aeBuffer[i+3]&0x80)==0x80){ // timestamp bit 16 is one -> wrap
                        // now we need to increment the wrapAdd
                        wrapAdd+=0x8000L;	// This is 0x7FFF +1; if we wrapped then increment wrap value by 2^15
                        //System.out.println("received wrap event, index:" + eventCounter + " wrapAdd: "+ wrapAdd);
                        NumberOfWrapEvents++;
                    } else {
                        // address is LSB MSB
                        addresses[eventCounter]=(short)(0xffff&((short)aeBuffer[i]&0xff | ((short)aeBuffer[i+1]&0xff)<<8));
                        
                        // same for timestamp, LSB MSB
                        shortts=(aeBuffer[i+2]&0xff | ((aeBuffer[i+3]&0xff)<<8)); // this is 15 bit value of timestamp in TICK_US tick
                        
                        timestamps[eventCounter]=(int)(TICK_US_BOARD*(shortts+wrapAdd)); //*TICK_US; //add in the wrap offset and convert to 1us tick
                        eventCounter++;
                        captureBufferPool.active().numEvents=eventCounter;
                    }
                } // end for
                // if (NumberOfWrapEvents!=0) {
                //System.out.println("Number of wrap events received: "+ NumberOfWrapEvents);
                //}
                //System.out.println("wrapAdd : "+ wrapAdd);
            } // sync on captureBufferPool
        }
        
        public void bufErrorHandler(UsbIoBuf Buf) {
            if ( Buf.Status != USBIO_ERR_SUCCESS ) {
                // print error
                // suppress CANCELED because it is caused by ABORT_PIPE
                if ( Buf.Status != USBIO_ERR_CANCELED ) {
                    log.warning("USB buffer error: "+Buf.Status);
                }
                if(Buf.Status==USBIO_ERR_DEVICE_GONE){
                    log.warning("CypressFX2.bufErrorHandler(): device gone, shutting down buffer pool thread");
                    monitor.close();
                }
            }
        }
        
        // virtual function, called in the context of worker thread
        public void onThreadExit() {
            freeBuffers();
            // System.out.println(this+" event capture worker-thread terminated.\n");
            monitor.aeReaderRunning=false;
        }
        
        // overridden to change priority
        public void startThread(int MaxIoErrorCount) {
            log.info("CypressFX2.AEReader.startThread()");
            allocateBuffers(getFifoSize(), getNumBuffers());
            super.startThread(MaxIoErrorCount);
            T.setPriority(PRIORITY); // very important that this thread have priority or the acquisition will stall on device side for substantial amounts of time!
//            System.out.println(this+ " event capture worker-thread started");
            monitor.aeReaderRunning=true;
            getSupport().firePropertyChange("readerStarted",false,true);
        }
        
        public int getFifoSize() {
            return fifoSize;
        }
        
        public void setFifoSize(int fifoSize) {
            if(fifoSize<CYPRESS_FIFO_SIZE){
                log.warning("CypressFX2 fifo size clipped to device FIFO size "+CYPRESS_FIFO_SIZE);
                fifoSize=CYPRESS_FIFO_SIZE;
            }
            this.fifoSize = fifoSize;
            freeBuffers();
            allocateBuffers(fifoSize,numBuffers);
            prefs.putInt("CypressFX2.AEReader.fifoSize",fifoSize);
        }
        
        public int getNumBuffers() {
            return numBuffers;
        }
        
        public void setNumBuffers(int numBuffers) {
            this.numBuffers = numBuffers;
            freeBuffers();
            allocateBuffers(fifoSize,numBuffers);
            prefs.putInt("CypressFX2.AEReader.numBuffers",numBuffers);
        }

        // applies the real time event processors on the captured data
        // TODO: at present this is slightly redundant in that the most recently captured events are copied to a 
        // different AEPacketRaw, extracted to an EventPacket, and then processed. This effort is duplicated 
        // later in rendering. This should be fixed somehow.
        private void realTimeFilter(int eventCounter, short[] addresses, int[] timestamps) {
            if(getChip()==null || getChip().getRealTimeFilterChain()==null || getChip().getRealTimeFilterChain().isEmpty()) {
                realTimePacket=null;
                realTimeRawPacket=null;
                return;
            }
            
            // check if any filter is enabled
            boolean any=false;
            FilterChain c=getChip().getRealTimeFilterChain();
            for(EventFilter2D f:c){
                if(f.isFilterEnabled()) any=true;
            }
            if(!any) return;
            
            // initialize packets
            if(realTimeRawPacket==null) 
                realTimeRawPacket=new AEPacketRaw(getNumRealTimeEvents()); 
            else 
                realTimeRawPacket.ensureCapacity(getNumRealTimeEvents());

            // copy data to real time raw packet
            System.arraycopy(addresses,realTimeEventCounterStart,realTimeRawPacket.getAddresses(),0,getNumRealTimeEvents());
            System.arraycopy(timestamps,realTimeEventCounterStart,realTimeRawPacket.getTimestamps(),0,getNumRealTimeEvents());
            
            realTimeRawPacket.setNumEvents(getNumRealTimeEvents());
            // init extracted packet
            if(realTimePacket==null)
                realTimePacket=new EventPacket(chip.getEventClass());
            
            // extract events for this filter. This duplicates later effort during rendering and should be fixed for later.
            // at present this may mess up everything else because the output packet is reused.
            chip.getEventExtractor().extractPacket(realTimeRawPacket,realTimePacket);
            
            getChip().getRealTimeFilterChain().filterPacket(realTimePacket);
            
            
            
        }
    }
    
    int getNumRealTimeEvents(){
        return eventCounter-realTimeEventCounterStart;
    }
    
    void allocateAEBuffers(){
        synchronized(captureBufferPool){
            captureBufferPool.allocateMemory();
        }
    }
    
    /** @return the size of the buffer for AEs */
    public int getAEBufferSize() {
        return captureBufferPool.bufferSize;
    }
    
    /** set the size of the host buffer. Default is AE_BUFFER_SIZE. You can set this larger if you
     *have overruns because your host processing (e.g. rendering) is taking too long.
     *<p>
     *This call discards collected events.
     * @param AEBufferSize size of buffer in events
     */
    public void setAEBufferSize(int AEBufferSize) {
        captureBufferPool.bufferSize = AEBufferSize;
        allocateAEBuffers();
    }
    
    public void onAdd() {
        log.info("USBAEMonitor.onAdd(): device added");
    }
    
    public void onRemove() {
        log.info("USBAEMonitor.onRemove(): device removed");
    }
    
    /** start or stops the event acquisition. sends apropriate vendor request to
     * device and starts or stops the AEReader
     * @param enable boolean to enable or disable event acquisition
     */
    synchronized public void setEventAcquisitionEnabled(boolean enable) throws HardwareInterfaceException {
        setInEndpointEnabled(enable);
        if(enable) startAEReader(); else stopAEReader();
    }
    
    public boolean isEventAcquisitionEnabled() {
        return isInEndpointEnabled();
    }
    
    public String getTypeName() {
        return "CypressFX2";
    }
    
    /** the first USB string descriptor (Vendor name) (if available) */
    protected USB_STRING_DESCRIPTOR stringDescriptor1 = new USB_STRING_DESCRIPTOR();
    
    /** the second USB string descriptor (Product name) (if available) */
    protected USB_STRING_DESCRIPTOR stringDescriptor2 = new USB_STRING_DESCRIPTOR();
    
    /** the third USB string descriptor (Serial number) (if available) */
    protected USB_STRING_DESCRIPTOR stringDescriptor3 = new USB_STRING_DESCRIPTOR();
    
    protected int numberOfStringDescriptors=2;
    
    /** returns number of string descriptors
     * @return number of string descriptors: 2 for TmpDiff128, 3 for MonitorSequencer */
    public int getNumberOfStringDescriptors() {
        return numberOfStringDescriptors;
    }
    
    /** the USBIO device descriptor */
    protected USB_DEVICE_DESCRIPTOR deviceDescriptor = new USB_DEVICE_DESCRIPTOR();
    
    
    /** the UsbIo interface to the device. This is assigned on construction by the
     * factory which uses it to open the device. here is used for all USBIO access
     * to the device*/
    protected UsbIo gUsbIo=null;
    
    /** the devlist handle for USBIO */
    protected int gDevList; // 'handle' (an integer) to an internal device list static to UsbIo
    
    
//    void buildUsbInterfaceList(){
//        buildUsbIoList();
//        usbList=new ArrayList<USBInterface>();
//        for(UsbIo u:usbioList){
//            try{
////                open();
////                usbList.add(this);
////                CypressFX2 dev=new CypressFX2();
////                dev.gUsbIo=u;
////                dev.open();
//                openUsbIo(u);
//                usbList.add(this);
//            }catch(USBInterfaceException e){
//                return;
//            }
//        }
//    }
//
    
    /** checks if device has a string identifier that is a non-empty string
     *@return false if not, true if there is one
     */
    protected boolean hasStringIdentifier(){
        // get string descriptor
        status = gUsbIo.getStringDescriptor(stringDescriptor1,(byte)1,0);
        if (status != USBIO_ERR_SUCCESS) {
            return false;
        } else {
            if(stringDescriptor1.Str.length()>0) return true;
        }
        return false;
    }
    
    /** constrcuts a new USB connection, opens it. Does NOT start event acquisition.
     * @see #setEventAcquisitionEnabled
     */
    public void open() throws HardwareInterfaceException {
        log.info(Thread.currentThread()+": CypressFX2.open()");
        openUsbIo();
//        setEventAcquisitionEnabled(true); // don't enable anymore, do this instead in acquireAvailableEventsFromDriver if necessary
        HardwareInterfaceException.clearException();
    }
    
    /**
     * This method does the hard work of opening the device, downloading the firmware, making sure everything is OK.
     * This method is synchronized to prevent multiple threads from trying to open at the same time, e.g. a GUI thread and the main thread.
     *
     * Opening the device after it has already been opened has no effect.
     *
     * @see #close
     *@throws HardwareInterfaceException if there is a problem. Diagnostics are printed to stderr.
     */
    synchronized protected void openUsbIo() throws HardwareInterfaceException {
        
        //device has already been UsbIo Opened by now, in factory
        
        // opens the USBIOInterface device, configures it, binds a reader thread with buffer pool to read from the device and starts the thread reading events.
        // we got a UsbIo object when enumerating all devices and we also made a device list. the device has already been
        // opened from the UsbIo viewpoint, but it still needs firmware download, setting up pipes, etc.
        
        if(isOpened){
            log.warning("CypressFX2.openUsbIo(): already opened interface and setup device");
            return;
        }
        
        int status;
        
        gUsbIo=new UsbIo();
        gDevList=UsbIo.createDeviceList(GUID);
        status = gUsbIo.open(getInterfaceNumber(),gDevList,GUID);
        if (status != USBIO_ERR_SUCCESS) {
            UsbIo.destroyDeviceList(gDevList);
            throw new HardwareInterfaceException("CypressFX2.openUsbIo(): can't open USB device: "+UsbIo.errorText(status));
        }
        
        // get device descriptor (possibly before firmware download, when still bare cypress device or running off EEPROM firmware)
        status = gUsbIo.getDeviceDescriptor(deviceDescriptor);
        if (status != USBIO_ERR_SUCCESS) {
            UsbIo.destroyDeviceList(gDevList);
            throw new HardwareInterfaceException("CypressFX2.openUsbIo(): getDeviceDescriptor: "+UsbIo.errorText(status));
        } else {
            log.info("getDeviceDescriptor: Vendor ID (VID) "
                    + HexString.toString((short)deviceDescriptor.idVendor)
                    + " Product ID (PID) " + HexString.toString((short)deviceDescriptor.idProduct));
        }
        
        // possibly download binary firmware to Cypress RAM
        downloadFirmwareBinary();
        
        boolean success=false; int triesLeft=40;
        long delay=400;
//        System.out.print("Reopening after firmware download ");
        while(!success && triesLeft>0){
            try{Thread.currentThread().sleep(delay);}catch(InterruptedException e){}
            gDevList=UsbIo.createDeviceList(GUID);
            gUsbIo=new UsbIo();
            status = gUsbIo.open(getInterfaceNumber(),gDevList,GUID);
            if (status != USBIO_ERR_SUCCESS) {
                UsbIo.destroyDeviceList(gDevList);
                triesLeft--;
//                System.out.print("."); System.out.flush();
            }else{
                success=true;
            }
        }
//        System.out.println("done");
        if(!success) throw new HardwareInterfaceException("couldn't reopen device after firmware download and renumeration: "+UsbIo.errorText(status));
        
        try{
            unconfigureDevice(); // in case it was left configured from a terminated process
        }catch(HardwareInterfaceException e){
            log.warning("CypressFX2.open(): can't unconfigure,will try simulated disconnect");
            int cycleStatus=gUsbIo.cyclePort();
            if(cycleStatus!=USBIO_ERR_SUCCESS){
                throw new HardwareInterfaceException("Error cycling port: "+UsbIo.errorText(status));
            }
            throw new HardwareInterfaceException("couldn't unconfigure device");
        }
        
        // set configuration -- must do this BEFORE downloading firmware!
        USBIO_SET_CONFIGURATION Conf = new USBIO_SET_CONFIGURATION();
        Conf.ConfigurationIndex = CONFIG_INDEX;
        Conf.NbOfInterfaces = CONFIG_NB_OF_INTERFACES;
        Conf.InterfaceList[0].InterfaceIndex = CONFIG_INTERFACE;
        Conf.InterfaceList[0].AlternateSettingIndex = CONFIG_ALT_SETTING;
        Conf.InterfaceList[0].MaximumTransferSize = CONFIG_TRAN_SIZE;
        status = gUsbIo.setConfiguration(Conf);
        if (status != USBIO_ERR_SUCCESS) {
//            gUsbIo.destroyDeviceList(gDevList);
            //   if (status !=0xE0001005)
            throw new HardwareInterfaceException("CypressFX2.openUsbIo(): setting configuration after firmware download: "+UsbIo.errorText(status));
        }
        
        //        try{Thread.currentThread().sleep(100);} catch(InterruptedException e){}; // pause for renumeration
        
        //        System.out.println("after firmware download and reenumeration, descriptors are");
        // get device descriptor
        status = gUsbIo.getDeviceDescriptor(deviceDescriptor);
        if (status != USBIO_ERR_SUCCESS) {
            UsbIo.destroyDeviceList(gDevList);
            throw new HardwareInterfaceException("CypressFX2.openUsbIo(): getDeviceDescriptor: "+UsbIo.errorText(status));
        } else {
            log.info("getDeviceDescriptor: Vendor ID (VID) "
                    + HexString.toString((short)deviceDescriptor.idVendor)
                    + " Product ID (PID) " + HexString.toString((short)deviceDescriptor.idProduct));
        }
        
        if (deviceDescriptor.iSerialNumber!=0)
            this.numberOfStringDescriptors=3;
        
        // get string descriptor
        status = gUsbIo.getStringDescriptor(stringDescriptor1,(byte)1,0);
        if (status != USBIO_ERR_SUCCESS) {
            UsbIo.destroyDeviceList(gDevList);
            throw new HardwareInterfaceException("CypressFX2.openUsbIo(): getStringDescriptor: "+UsbIo.errorText(status));
        } else {
            log.info("getStringDescriptor 1: " + stringDescriptor1.Str);
        }
        
        // get string descriptor
        status = gUsbIo.getStringDescriptor(stringDescriptor2,(byte)2,0);
        if (status != USBIO_ERR_SUCCESS) {
            UsbIo.destroyDeviceList(gDevList);
            throw new HardwareInterfaceException("CypressFX2.openUsbIo(): getStringDescriptor: "+UsbIo.errorText(status));
        } else {
            log.info("getStringDescriptor 2: " + stringDescriptor2.Str);
        }
        
        if (this.numberOfStringDescriptors==3) {
            // get serial number string descriptor
            status = gUsbIo.getStringDescriptor(stringDescriptor3,(byte)3,0);
            if (status != USBIO_ERR_SUCCESS) {
                UsbIo.destroyDeviceList(gDevList);
                throw new HardwareInterfaceException("CypressFX2.openUsbIo(): getStringDescriptor: "+UsbIo.errorText(status));
            } else {
                log.info("getStringDescriptor 3: " + stringDescriptor3.Str);
            }
        }
        
        if(!gUsbIo.isOperatingAtHighSpeed()){
            log.warning("CypressFX2.openUsbIo(): Warning: device is not operating at USB 2.0 High Speed, performance will be limited to about 300 keps");
        }
        
        // get pipe information and extract the FIFO size
        USBIO_CONFIGURATION_INFO ConfigurationInfo = new USBIO_CONFIGURATION_INFO();
        status = gUsbIo.getConfigurationInfo(ConfigurationInfo);
        if (status != USBIO_ERR_SUCCESS) {
            UsbIo.destroyDeviceList(gDevList);
            throw new HardwareInterfaceException("CypressFX2.openUsbIo(): getConfigurationInfo: "+UsbIo.errorText(status));
        }
        
        if(ConfigurationInfo.NbOfPipes==0){
//            gUsbIo.cyclePort();
            throw new HardwareInterfaceException("CypressFX2.openUsbIo(): didn't find any pipes to bind to");
        }
        
        // start the thread that listens for device status information (e.g. timestamp reset)
        asyncStatusThread=new AsyncStatusThread(this);
        asyncStatusThread.start();
        
        isOpened=true;
        
    }
    
// unconfigure device in case it was still configured from a prior terminated process
    synchronized void unconfigureDevice() throws HardwareInterfaceException {
        int status;
//        System.out.println("CypressFX2RetinaBiasgen.unconfigureDevice()");
        status = gUsbIo.unconfigureDevice();
        if (status != USBIO_ERR_SUCCESS) {
            gUsbIo.destroyDeviceList(gDevList);
            //            throw new USBAEMonitorException("getStringDescriptor: "+gUsbIo.errorText(status));
            throw new HardwareInterfaceException("unconfigureDevice: "+UsbIo.errorText(status));
            //            System.out.println("getConfigurationInfo ok");
        }
        //        System.out.println("unconfigured device");
    }
    
    /** return the string USB descriptors for the device
     *@return String[] of length 2 of USB descriptor strings.
     */
    public String[] getStringDescriptors() {
        if(stringDescriptor1==null) {
            log.warning("USBAEMonitor: getStringDescriptors called but device has not been opened");
            String[] s=new String[numberOfStringDescriptors];
            for (int i=0;i<numberOfStringDescriptors;i++) {
                s[i]="";
            }
            return s;
        }
        String[] s=new String[numberOfStringDescriptors];
        s[0]=stringDescriptor1.Str;
        s[1]=stringDescriptor2.Str;
        if (numberOfStringDescriptors==3) {
            s[2]=stringDescriptor3.Str;
        }
        return s;
    }
    
    /** return the USB VID/PID of the interface
     *@return int[] of length 2 containing the Vendor ID (VID) and Product ID (PID) of the device. First element is VID, second element is PID.
     */
    public int[] getVIDPID() {
        if(deviceDescriptor==null) {
            log.warning("USBAEMonitor: getVIDPID called but device has not been opened");
            return new int[2];
        }
        int[] n=new int[2];
        n[0]=deviceDescriptor.idVendor;
        n[1]=deviceDescriptor.idProduct;
        return n;
    }
    
    
    public short getVID() {
        if(deviceDescriptor==null) {
            log.warning("USBAEMonitor: getVIDPID called but device has not been opened");
            return 0;
        }
        // int[] n=new int[2]; n is never used
        return (short)deviceDescriptor.idVendor;
    }
    
    public short getPID() {
        if(deviceDescriptor==null) {
            log.warning("USBAEMonitor: getVIDPID called but device has not been opened");
            return 0;
        }
        return (short)deviceDescriptor.idProduct;
    }
    
    /** @return bcdDevice (the binary coded decimel device version */
    public short getDID() { // this is not part of USB spec in device descriptor.
        return (short)deviceDescriptor.bcdDevice;
    }
    
    /** reports if interface is {@link #open}.
     * @return true if already open
     */
    public boolean isOpen() {
        return isOpened;
    }
    
    public byte[] loadBinaryFirmwareFile(String firmwareFilename) throws IOException{
        InputStream firmwareFileStream;
        byte[] FWBuffer;
        log.info("CypressFX2.loadFirmwareFile(): firmware filename is "+firmwareFilename);
        // load firmware file (this is binary file of 8051 firmware)
        try{
            firmwareFileStream=getClass().getResourceAsStream(firmwareFilename);
            if(firmwareFileStream==null) throw new IOException("can't load binary Cypress FX2 firmware file "+firmwareFilename);
            FWBuffer=new byte[firmwareFileStream.available()];
            log.info("CypressFX2.downloadFirmware(): firmware filename is "+firmwareFileStream.available()+" bytes long");
            firmwareFileStream.read(FWBuffer);
            firmwareFileStream.close();
        }catch(IOException e){
            close();
            log.warning(e.getMessage());
            throw new IOException("can't load binary Cypress FX2 firmware file "+firmwareFilename);
        }
        return FWBuffer;
    }
    
    /** downloads firmware to FX2 RAM. adapted from John Arthur's example, which comes from Cypress example.
     * Firmware file is a binary file produced by uVision2 (Keil) from source code for firmware.
     *<p>
     *Firmware that is actually downloaded depends on discovered PID of device. If the PID is discovered to be a bare CypressFX2, then
     *a dialog is shown that user can use to program the VID/PID of the device.
     *<p>
     *In addition, there is a problem if firmware is downloaded more than once to an FX2LP device between hard resets. Therefore if this method detects
     *that the device has string identitifers, it assumes the firmware has already been downloaded.
     *
     *
     * Firmware file is loaded as a resource from the jar archive.
     */
    synchronized void downloadFirmwareBinary(String firmwareFilename) throws HardwareInterfaceException {
        
        InputStream firmwareFile;  // firmware file
        byte[] FWBuffer; // buffer to hold contents of firmware file (binary 8051 code)
        
        try{
            FWBuffer=loadBinaryFirmwareFile(firmwareFilename);
        }catch(IOException e){
            close();
            log.warning(e.getMessage());
            throw new HardwareInterfaceException("can't load binary Cypress FX2 firmware file "+firmwareFilename);
        }
        
        set8051Reset(true);
        download8051RAM(0, FWBuffer);
        set8051Reset(false);
    }
    
    /** downloads firmware to FX2 RAM. adapted from John Arthur's example, which comes from Cypress example.
     * Firmware file is a binary file produced by uVision2 (Keil) from source code for firmware.
     *<p>
     *Firmware that is actually downloaded depends on discovered PID of device. If the PID is discovered to be a bare CypressFX2, then
     *a dialog is shown that user can use to program the VID/PID of the device.
     *<p>
     *In addition, there is a problem if firmware is downloaded more than once to an FX2LP device between hard resets. Therefore if this method detects
     *that the device has string identitifers, it assumes the firmware has already been downloaded.
     *
     *
     * Firmware file is loaded as a resource from the jar archive.
     */
    synchronized void downloadFirmwareBinary() throws HardwareInterfaceException {
        
        
        if(hasStringIdentifier()){
            log.info("CypressFX2.downloadFirmware(): device has string identifier already, not downloading firmware");
            return;
        }
        
        //  firmware load variables
        byte[] FWBuffer; // buffer to hold contents of firmware file (binary 8051 code)
        
        String firmwareFilename = getFirmwareFilenameBinaryFromVIDPID();
        
        try{
            FWBuffer=loadBinaryFirmwareFile(firmwareFilename);
        }catch(IOException e){
            close();
            log.warning(e.getMessage());
            throw new HardwareInterfaceException("can't load binary Cypress FX2 firmware file "+firmwareFilename);
        }
        
        set8051Reset(true);
        download8051RAM(0, FWBuffer);
        set8051Reset(false);
        
        
    } // downloadFirmwareBinary()
    
// returns the firmware filenmae corresponding to a VID/PID pair
// this filename is actually a full path to a resource on the classpath
    protected String getFirmwareFilenameBinaryFromVIDPID() {
        String firmwareFilename=null;
        if(getVIDPID()[1]==PID_DAREK_FX2_BOARD){
            firmwareFilename=FIRMWARE_FILENAME_DAREK_BOARD;
        } else if (getVIDPID()[1]==PID_USBAERmini2_without_firmware){
            firmwareFilename=FIRMWARE_FILENAME_MONITOR_SEQUENCER;
        }else if (getVIDPID()[1]==PID_USBAERmini2){
            firmwareFilename=FIRMWARE_FILENAME_MONITOR_SEQUENCER;
        }else{
            firmwareFilename=FIRMWARE_FILENAME_TMPDIFF128;
        }
        
        return firmwareFilename;
    }
    
    // returns the firmware filenmae corresponding to a VID/PID pair
    // this filename is actually a full path to a resource on the classpath
    protected String getFirmwareFilenameHexFromVIDPID() {
        String firmwareFilename=null;
        if (getVIDPID()[1]==PID_USBAERmini2_without_firmware){
            firmwareFilename=FIRMWARE_FILENAME_MONITOR_SEQUENCER_HEX;
        }else{
            firmwareFilename=FIRMWARE_FILENAME_TMPDIFF128_HEX;
        }
        return firmwareFilename;
    }
    
    /** downloads to RAM on FX2 using built-in vendor request to CPUCS
     * // remember to set8051Reset() before and after calling this method
     *@param address the starting address in the 8051 RAM
     *@param FWBuffer the data
     *@see #set8051Reset
     */
    protected void download8051RAM(int address, final byte[] FWBuffer)
    throws HardwareInterfaceException {
        
        /* From Fx2 tech ref guide, chapter 2 "endpoint 0"
         *
         *The USB endpoint-zero protocol provides a mechanism for mixing
         vendor-specific requests with standard device requests. Bits 6:5 of the bmRequestType
         field are set to 00 for a standard device request and to 10 for a vendor request.
         **/
        // need to perform the following steps:
        //
        //	1) reset the Cypress (write 0x01 into CPUCS register)
        //	2) send the firmware to Control Endpoint 0
        //	3) pull the Cypress out of reset (write 0x00 into the CPUCS register)
        
        // this is achieved by using the vendor request VENDOR_REQUEST_FIRMWARE, where the Value of the request is the
        // address to write to and the buffer passed to USBIO_CLASS_OR_VENDOR_REQUEST defines data to be written
        // starting at this address and the number of bytes to be written.
        // thus the same vendor request can reset the 8051 (one byte written to CPUCS) and download successive chunks
        // of code. finally the request can unreset the 8051.
        
        int result;
        USBIO_CLASS_OR_VENDOR_REQUEST vendorRequest=new USBIO_CLASS_OR_VENDOR_REQUEST();
        USBIO_DATA_BUFFER dataBuffer;
        int fwIndex;
        int numChunks;
        
        vendorRequest.Flags=UsbIoInterface.USBIO_SHORT_TRANSFER_OK;
        vendorRequest.Type=UsbIoInterface.RequestTypeVendor;  // this is a vendor, not generic USB, request
        vendorRequest.Recipient=UsbIoInterface.RecipientDevice; // device (not endpoint, interface, etc) receives it
        vendorRequest.RequestTypeReservedBits=0;    // set these bits to zero for Cypress-specific 'vendor request' rather that user defined
        vendorRequest.Request=VENDOR_REQUEST_FIRMWARE; // this is download/upload firmware request. really it is just a 'fill RAM request'
        vendorRequest.Index=0;
        
        //	2) send the firmware to Control Endpoint 0
        // when sending firmware, we need to break up the loaded fimware
        //		into MAX_CONTROL_XFER_SIZE blocks
        //
        // this means:
        //	a) the address to load it to needs to be changed (VendorRequest.Value)
        //	b) need a pointer that moves through FWbuffer (pBuffer)
        //	c) keep track of remaining bytes to transfer (FWsize_left);
        
        
        //send all but last chunk
        vendorRequest.Value = 0;			//address of firmware location
        dataBuffer=new USBIO_DATA_BUFFER(MAX_CONTROL_XFER_SIZE);
        dataBuffer.setNumberOfBytesToTransfer(dataBuffer.Buffer().length);
        fwIndex=0;
        numChunks=FWBuffer.length/MAX_CONTROL_XFER_SIZE;  // this is number of full chunks to send
        for(int i=0;i<numChunks;i++){
            System.arraycopy(FWBuffer, i*MAX_CONTROL_XFER_SIZE, dataBuffer.Buffer(), 0, MAX_CONTROL_XFER_SIZE);
            result=gUsbIo.classOrVendorOutRequest(dataBuffer,vendorRequest);
            if(result!=USBIO_ERR_SUCCESS){
                close();
                throw new HardwareInterfaceException("Error on downloading segment number "+i+" of 8051 firmware: "+UsbIo.errorText(result));
            }
            vendorRequest.Value += MAX_CONTROL_XFER_SIZE;			//change address of firmware location
        }
        
        // now send final (short) chunk
        int numBytesLeft=FWBuffer.length%MAX_CONTROL_XFER_SIZE;  // remainder
        if(numBytesLeft>0){
            dataBuffer=new USBIO_DATA_BUFFER(numBytesLeft);
            dataBuffer.setNumberOfBytesToTransfer(dataBuffer.Buffer().length);
            System.arraycopy(FWBuffer, numChunks*MAX_CONTROL_XFER_SIZE, dataBuffer.Buffer(), 0, numBytesLeft);
            
            // send remaining part of firmware
            result=gUsbIo.classOrVendorOutRequest(dataBuffer,vendorRequest);
            if(result!=USBIO_ERR_SUCCESS){
                close();
                throw new HardwareInterfaceException("Error on downloading final segment of 8051 firmware: "+UsbIo.errorText(result));
            }
        }
        
    }
    
    /**
     * sends vendor request to CPUCS register to set 8051 in CPU reset (or not)
     *@param value true to reset, false to run
     *@see #download8051RAM
     */
    protected void set8051Reset(boolean value)
    throws HardwareInterfaceException {
        
        int result;
        USBIO_DATA_BUFFER dataBuffer;
        USBIO_CLASS_OR_VENDOR_REQUEST vendorRequest;
        // make vendor request structure and populate it
        vendorRequest=new USBIO_CLASS_OR_VENDOR_REQUEST();
        
        vendorRequest.Flags=UsbIoInterface.USBIO_SHORT_TRANSFER_OK;
        vendorRequest.Type=UsbIoInterface.RequestTypeVendor;  // this is a vendor, not generic USB, request
        vendorRequest.Recipient=UsbIoInterface.RecipientDevice; // device (not endpoint, interface, etc) receives it
        vendorRequest.RequestTypeReservedBits=0;    // set these bits to zero for Cypress-specific 'vendor request' rather that user defined
        vendorRequest.Request=VENDOR_REQUEST_FIRMWARE; // this is download/upload firmware request. really it is just a 'fill RAM request'
        vendorRequest.Index=0;
        
        //	1) reset the Cypress (write 0x01 into CPUCS register)
        
        vendorRequest.Value=CPUCS; // we're writing to this RAM address, which is actually the only register that the host can write to
        dataBuffer=new USBIO_DATA_BUFFER(1); // make a new buffer to define the length of the request data correctly
        dataBuffer.Buffer()[0]= (byte)(value?1:0);            // 1 to reset, 0 to run
        dataBuffer.setNumberOfBytesToTransfer(dataBuffer.Buffer().length);
        result=gUsbIo.classOrVendorOutRequest(dataBuffer,vendorRequest);
        if(result!=USBIO_ERR_SUCCESS){
            close();
            throw new HardwareInterfaceException("Unable to reset 8051 for firmware download: "+UsbIo.errorText(result));
        }
        
    }
    
    
    /** @return timestamp tick in us
     * NOTE: DOES NOT RETURN THE TICK OF THE USBAERmini2 board*/
    final public int getTimestampTickUs() {
        return TICK_US;
    }
    
    /** returns last events from {@link #acquireAvailableEventsFromDriver}
     *@return the event packet
     */
    public AEPacketRaw getEvents() {
        return this.events;
    }
    
    /** sends a vender request without data, value and index are set to zero.
     *@param request the vendor request byte, identifies the request on the device
     */
    synchronized public void sendVendorRequest(byte request) throws HardwareInterfaceException {
        sendVendorRequest(request, (short)0, (short)0, null);
    }
    
    /** sends a vender request without any data.
     *@param request the vendor request byte, identifies the request on the device
     *@param value the value of the request (bValue USB field)
     *@param index the "index" of the request (bIndex USB field)
     */
    synchronized public void sendVendorRequest(byte request, short value, short index) throws HardwareInterfaceException {
        sendVendorRequest(request, value, index, null);
    }
    
    /** sends a vender request with data.
     *@param request the vendor request byte, identifies the request on the device
     *@param value the value of the request (bValue USB field)
     *@param index the "index" of the request (bIndex USB field)
     *@param dataBuffer the data which is to be transmitted to the device
     */
    synchronized public void sendVendorRequest(byte request, short value, short index, USBIO_DATA_BUFFER dataBuffer) throws HardwareInterfaceException {
        if (!isOpen()) {
            open();
        }
        
        // make vendor request structure and populate it
        USBIO_CLASS_OR_VENDOR_REQUEST VendorRequest=new USBIO_CLASS_OR_VENDOR_REQUEST();
        int status;
        
        VendorRequest.Flags=UsbIoInterface.USBIO_SHORT_TRANSFER_OK;
        VendorRequest.Type=UsbIoInterface.RequestTypeVendor;
        VendorRequest.Recipient=UsbIoInterface.RecipientDevice;
        VendorRequest.RequestTypeReservedBits=0;
        VendorRequest.Request= request;
        VendorRequest.Index= index;
        VendorRequest.Value= value;
        
        //System.out.println("request= " + request + " value: " + value);
        
        if (dataBuffer==null) {
            dataBuffer=new USBIO_DATA_BUFFER(1);
            dataBuffer.setNumberOfBytesToTransfer(dataBuffer.Buffer().length);
        } else {
            dataBuffer.setNumberOfBytesToTransfer(dataBuffer.Buffer().length);
        }
        
        status=gUsbIo.classOrVendorOutRequest(dataBuffer,VendorRequest);
        
        if(status!=USBIO_ERR_SUCCESS){
            throw new HardwareInterfaceException("Unable to send vendor request "+ request + ": " + UsbIo.errorText(status));
        }
        
        HardwareInterfaceException.clearException();
    }
    
    public AEReader getAeReader() {
        return aeReader;
    }
    
    public void setAeReader(AEReader aeReader) {
        this.aeReader = aeReader;
    }
    
    public int getFifoSize() {
        if(aeReader==null) return 0; else return aeReader.getFifoSize();
    }
    
    public void setFifoSize(int fifoSize) {
        if(aeReader==null) return;
        aeReader.shutdownThread();
        aeReader.setFifoSize(fifoSize);
        aeReader.startThread(3);
    }
    
    public int getNumBuffers() {
        if(aeReader==null) return 0; else return aeReader.getNumBuffers();
    }
    
    public void setNumBuffers(int numBuffers) {
        if(aeReader==null) return;
        aeReader.shutdownThread();
        aeReader.setNumBuffers(numBuffers);
        aeReader.startThread(3);
    }

//    /** adds a filter that operates on the data as it is captured in the AEReader thread 
//     @param f the filter
//     */
//    public void addRealTimeFilter(EventFilter2D f) {
////        realTimeFilterChain.add(f);
//    }
//
//    /** removes a filter that operates on the data as it is captured in the AEReader thread 
//     @param f the filter
//     */
//    public void removeRealTimeFilter(EventFilter2D f) {
////        realTimeFilterChain.remove(f);
//    }

//    /** @return filters that are applied to the events as they are captured */
//    public FilterChain getRealTimeFilterChain() {
//        return null;
////        return realTimeFilterChain;
//    }

    public void setChip(AEChip chip) {
        this.chip=chip;
    }

    public AEChip getChip() {
        return chip;
    }
    
} //CypressFX2

