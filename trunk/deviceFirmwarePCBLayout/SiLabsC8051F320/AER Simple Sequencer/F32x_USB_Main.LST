C51 COMPILER V7.05   F32X_USB_MAIN                                                         07/17/2008 19:03:25 PAGE 1   


C51 COMPILER V7.05, COMPILATION OF MODULE F32X_USB_MAIN
OBJECT MODULE PLACED IN F32x_USB_Main.OBJ
COMPILER INVOKED BY: C:\SiLabs\MCU\IDEfiles\C51\BIN\C51.exe F32x_USB_Main.c DB OE CD

stmt level    source

   1          /*
   2          hex cheat sheet
   3          0000    0x00
   4          0001    0x01
   5          0010    0x02
   6          
   7          0111    0x07
   8          1000    0x08
   9          1001    0x09
  10          1010    0x0a
  11          1011    0x0b
  12          1100    0x0c
  13          1101    0x0d
  14          1110    0x0e
  15          1111    0x0f
  16          
  17          */
  18          // this firmware is for implementing a simple sequencer that gets AE from the computer and sends them out 
             -using AER
  19          
  20          // Tarek jul 2008
  21          
  22          //-----------------------------------------------------------------------------
  23          // Includes
  24          //-----------------------------------------------------------------------------
  25          
  26          #include "c8051f320.h"
  27          #include "F32x_USB_Register.h"
  28          #include "F32x_USB_Main.h"
  29          #include "F32x_USB_Descriptor.h"
  30          
  31          
  32          // Globals Added by Tarek
  33          sbit    NOTREQ  = P0^1;         // !req line, input
  34          sbit    NOTACK  = P0^0;         // !ack line, output
  35          sbit    LedRed  =       P0^3;   //      LED='1' means ON
  36          sbit    LedGreen        =       P0^4;   //      These blink to indicate data transmission
  37          sbit    LedBlue = P0^5;
  38          #define LedRedOn() LedRed=0;
  39          #define LedRedOff()  LedRed=1;
  40          #define LedRedToggle() LedRed=!LedRed; // this probably doesn't work because it reads port and then writes
             - opposite, but since all ports are tied together somewhat it may not work
  41          #define LedGreenOn() LedGreen=0;
  42          #define LedGreenOff() LedGreen=1;
  43          #define LedGreenToggle() LedGreen=!LedGreen;
  44          #define LedBlueOn() LedBlue=0;
  45          #define LedBlueOff() LedBlue=1;
  46          #define LedBlueToggle() LedBlue=!LedBlue;
  47          
  48          
  49          idata BYTE Out_Packet[64];             // Last packet received from host
  50          idata BYTE In_Packet[64];              // Next packet to sent to host
  51          extern BYTE Ep_Status[];
  52          
  53          void    Port_Init(void);                        // Initialize Ports Pins and Enable Crossbar
C51 COMPILER V7.05   F32X_USB_MAIN                                                         07/17/2008 19:03:25 PAGE 2   

  54          void    Timer_Init(void);                       // Init timer to use for spike event times
  55          void    Usb0_Init(void);                        //              
  56          
  57          
  58          
  59          
  60          //-----------------------------------------------------------------------------
  61          // Main Routine
  62          //-----------------------------------------------------------------------------
  63          void main(void)
  64          {
  65   1              Port_Init();                    // Initialize Ports Pins and Enable Crossbar
  66   1              Timer_Init();                   // Init timer to use for spike event times
  67   1              //Usb0_Init();
  68   1              NOTREQ  =       1;
  69   1              
  70   1         while (1)
  71   1         {
  72   2              LedRedOn();
  73   2              LedGreenOn();
  74   2              LedBlueOn();
  75   2              Delay();
  76   2              LedRedOff();
  77   2              LedGreenOff();
  78   2              LedBlueOff();
  79   2         }
  80   1      }
  81          
  82          
  83          //-----------------------------------------------------------------------------
  84          // Usb0_Init
  85          //-----------------------------------------------------------------------------
  86          //
  87          // Return Value : None
  88          // Parameters   : None
  89          // 
  90          // - Initialize USB0
  91          // - Enable USB0 interrupts
  92          // - Enable USB0 transceiver
  93          // - Enable USB0 with suspend detection
  94          //-----------------------------------------------------------------------------
  95          void Usb0_Init(void)
  96          {
  97   1         BYTE Count;
  98   1      
  99   1         // Set initial values of In_Packet and Out_Packet to zero
 100   1         // Initialized here so that WDT doesn't kick in first
 101   1         for (Count = 0; Count < 64; Count++)
 102   1         {
 103   2            Out_Packet[Count] = 0;
 104   2            In_Packet[Count] = 0;
 105   2         }
 106   1      
 107   1      
 108   1         POLL_WRITE_BYTE(POWER,  0x08);      // Force Asynchronous USB Reset
 109   1         POLL_WRITE_BYTE(IN1IE,  0x07);      // Enable Endpoint 0-2 in interrupts
 110   1         POLL_WRITE_BYTE(OUT1IE, 0x07);      // Enable Endpoint 0-2 out interrupts
 111   1         POLL_WRITE_BYTE(CMIE,   0x07);      // Enable Reset,Resume,Suspend interrupts
 112   1      #ifdef _USB_LOW_SPEED_
                 USB0XCN = 0xC0;                     // Enable transceiver; select low speed
                 POLL_WRITE_BYTE(CLKREC, 0xA0);      // Enable clock recovery; single-step mode
                                                     // disabled; low speed mode enabled
C51 COMPILER V7.05   F32X_USB_MAIN                                                         07/17/2008 19:03:25 PAGE 3   

              #else
 117   1         USB0XCN = 0xE0;                     // Enable transceiver; select full speed
 118   1         POLL_WRITE_BYTE(CLKREC, 0x80);      // Enable clock recovery, single-step mode
 119   1                                             // disabled
 120   1      #endif // _USB_LOW_SPEED_
 121   1      
 122   1         EIE1 |= 0x02;                       // Enable USB0 Interrupts
 123   1         EA = 1;                             // Global Interrupt enable
 124   1                                             // Enable USB0 by clearing the USB 
 125   1                                             // Inhibit bit
 126   1         POLL_WRITE_BYTE(POWER,  0x01);      // and enable suspend detection
 127   1      }
 128          
 129          
 130          void    Timer_Init(void)
 131          {
 132   1      //----------------------------------------------------------------
 133   1      // Timers Configuration
 134   1      //----------------------------------------------------------------
 135   1      
 136   1          CKCON = 0x04; // t0 clked by sysclk=24MHz 0x00;   // Clock Control Register, timer 0 uses prescaled sy
             -sclk/12. sysclk is 24MHz.
 137   1          TMOD = 0x11;    // Timer Mode Register, timer0 and, timer1 16 bit 00010001
 138   1              TCON = 0x50;    // Timer Control Register , timer0 and 1 running
 139   1          TH0 = 0x00;             // Timer 0 High Byte, reload value. this is FE so that timer clocks FE FF 00, 2 cycle
             -s, 
 140   1          TL0 = 0x00;     // Timer 0 Low Byte
 141   1              
 142   1      //      CR=1;                   // run PCA counter/timer
 143   1      //      PCA0MD|=0x84;   // use timer0 overflow to clock PCA counter. leave wdt bit undisturbed. turn off PCA in i
             -dle.
 144   1      //      PCA0CPM0=0x10;  // negative edge on CEX0 captures PCA, which is req from sender
 145   1              
 146   1      }
 147          
 148          void    Port_Init(void)
 149          {  
 150   1      
 151   1      // P  1 212          O: bit 1 is ACK output, others are inputs (incl REQ on P0.0)
 152   1      // P2: bit 6,7 are LEDs are outputs
 153   1      // don't connect any internal functions to ports
 154   1      // no weak pullups, no internal functions to ports
 155   1      
 156   1      // following from silabs config wizard 2.05 bundled as utility with IDE
 157   1      // Config template saved as ConfigWizardTemplate.dat
 158   1      //----------------------------------------------------------------
 159   1      // CROSSBAR REGISTER CONFIGURATION
 160   1      //
 161   1      // NOTE: The crossbar register should be configured before any  
 162   1      // of the digital peripherals are enabled. The pinout of the 
 163   1      // device is dependent on the crossbar configuration so caution 
 164   1      // must be exercised when modifying the contents of the XBR0, 
 165   1      // XBR1 registers. For detailed information on 
 166   1      // Crossbar Decoder Configuration, refer to Application Note 
 167   1      // AN001, "Configuring the Port I/O Crossbar Decoder". 
 168   1      //----------------------------------------------------------------
 169   1      
 170   1      /*
 171   1      Step 1.  Select the input mode (analog or digital) for all Port pins, using the Port Input Mode register (
             -PnMDIN).
 172   1      Step 2.  Select the output mode (open-drain or push-pull) for all Port pins, using the Port Output Mode re
             -gister (PnMDOUT).
C51 COMPILER V7.05   F32X_USB_MAIN                                                         07/17/2008 19:03:25 PAGE 4   

 173   1      Step 3.  Select any pins to be skipped by the I/O Crossbar using the Port Skip registers (PnSKIP).
 174   1      Step 4.  Assign Port pins to desired peripherals (XBR0, XBR1).
 175   1      Step 5.  Enable the Crossbar (XBARE = ‘1’).
 176   1      */
 177   1      
 178   1      // Configure the XBRn Registers
 179   1      
 180   1              XBR0 = 0x00;    // 0000 0000 Crossbar Register 1. no peripherals are routed to output.
 181   1              XBR1 = 0x81;    // 1000 0001 Crossbar Register 2. no weak pullups, cex0 routed to port pins.
 182   1      
 183   1      
 184   1      // Select Pin I/0
 185   1      
 186   1      // NOTE: Some peripheral I/O pins can function as either inputs or 
 187   1      // outputs, depending on the configuration of the peripheral. By default,
 188   1      // the configuration utility will configure these I/O pins as push-pull 
 189   1      // outputs.
 190   1              // Port configuration (1 = Push Pull Output)
 191   1          P0MDIN = 0xFF;  // Input configuration for P0. Not using analog input.
 192   1          P1MDIN = 0xFF;  // Input configuration for P1
 193   1          P2MDIN = 0xFF;  // Input configuration for P2
 194   1          P3MDIN = 0xFF;  // Input configuration for P3
 195   1      
 196   1      
 197   1          P0MDOUT = 0x02; // Output configuration for P0, bit 0 is ack input, bit 1 is req output, 0000 0010, 
 198   1                                              // leds are bits 3,4,5 but are open drain, set bit low to pull down and turn on LED
 199   1          P1MDOUT = 0xFF; // Output configuration for P1  // P1 is used for AE lsb 8 bits
 200   1          P2MDOUT = 0xFF; // Output configuration for P2  // P2 is used for AE msb 8 bits
 201   1          P3MDOUT = 0x00; // Output configuration for P3 
 202   1      
 203   1      
 204   1      
 205   1      
 206   1          P0SKIP = 0x01;  //  0000 0001 Port 0 Crossbar Skip Register. Skip first pin so that bit 1 (req) P0.1 b
             -ecomes CEX0 input to PCA capture module
 207   1      
 208   1          P1SKIP = 0x00;  //  Port 1 Crossbar Skip Register
 209   1          P2SKIP = 0x00;  //  Port 2 Crossbar Skip Register
 210   1      
 211   1      
 212   1              XBR1|=0x40;     // 0100 0000 enable xbar
 213   1      
 214   1      // View port pinout
 215   1      
 216   1              // The current Crossbar configuration results in the 
 217   1              // following port pinout assignment:
 218   1              // Port 0
 219   1              // P0.0 = unassigned      (Open-Drain Output/Input)(Digital)
 220   1              // P0.1 = unassigned      (Push-Pull Output)(Digital)
 221   1              // P0.2 = unassigned      (Open-Drain Output/Input)(Digital)
 222   1              // P0.3 = unassigned      (Open-Drain Output/Input)(Digital)
 223   1              // P0.4 = unassigned      (Open-Drain Output/Input)(Digital)
 224   1              // P0.5 = unassigned      (Open-Drain Output/Input)(Digital)
 225   1              // P0.6 = unassigned      (Open-Drain Output/Input)(Digital)
 226   1              // P0.7 = unassigned      (Open-Drain Output/Input)(Digital)
 227   1      
 228   1          // Port 1
 229   1              // P1.0 = unassigned      (Open-Drain Output/Input)(Digital)
 230   1              // P1.1 = unassigned      (Open-Drain Output/Input)(Digital)
 231   1              // P1.2 = unassigned      (Open-Drain Output/Input)(Digital)
 232   1              // P1.3 = unassigned      (Open-Drain Output/Input)(Digital)
 233   1              // P1.4 = unassigned      (Open-Drain Output/Input)(Digital)
C51 COMPILER V7.05   F32X_USB_MAIN                                                         07/17/2008 19:03:25 PAGE 5   

 234   1              // P1.5 = unassigned      (Open-Drain Output/Input)(Digital)
 235   1              // P1.6 = unassigned      (Open-Drain Output/Input)(Digital)
 236   1              // P1.7 = unassigned      (Open-Drain Output/Input)(Digital)
 237   1      
 238   1          // Port 2
 239   1              // P2.0 = unassigned      (Open-Drain Output/Input)(Digital)
 240   1              // P2.1 = unassigned      (Open-Drain Output/Input)(Digital)
 241   1              // P2.2 = unassigned      (Open-Drain Output/Input)(Digital)
 242   1              // P2.3 = unassigned      (Open-Drain Output/Input)(Digital)
 243   1              // P2.4 = unassigned      (Open-Drain Output/Input)(Digital)
 244   1              // P2.5 = unassigned      (Open-Drain Output/Input)(Digital)
 245   1              // P2.6 = unassigned      (Push-Pull Output)(Digital)
 246   1              // P2.7 = unassigned      (Push-Pull Output)(Digital)
 247   1      
 248   1          // Port 3
 249   1              // P3.0 = unassigned      (Open-Drain Output/Input)(Digital)
 250   1      
 251   1      }
 252          
 253          //-----------------------------------------------------------------------------
 254          // Delay
 255          //-----------------------------------------------------------------------------
 256          //
 257          // Used for a small pause, approximately 80 us in Full Speed,
 258          // and 1 ms when clock is configured for Low Speed
 259          //
 260          //-----------------------------------------------------------------------------
 261          
 262          void Delay(void)
 263          {
 264   1         int x;
 265   1         for(x = 0;x < 150v00;x)
*** ERROR C141 IN LINE 265 OF F32X_USB_MAIN.C: syntax error near 'v00'
*** ERROR C202 IN LINE 265 OF F32X_USB_MAIN.C: 'v00': undefined identifier
*** ERROR C141 IN LINE 265 OF F32X_USB_MAIN.C: syntax error near ')'
 266   1            x++;
 267   1      }

C51 COMPILATION COMPLETE.  0 WARNING(S),  3 ERROR(S)
