$icc$ROM_ADDR:
C$$code_start:
    00000100 00003188	ANDEQ	R3,R0,R8,LSL #3
$icc$RAM_ADDR:
    00000104 40000000	ANDMI	R0,R0,R0
$icc$DATA_SIZE:
    00000108 00001180	ANDEQ	R1,R0,R0,LSL #3
$icc$URAM_ADDR:
    0000010C 40001180	ANDMI	R1,R0,R0,LSL #3
$icc$UDATA_SIZE:
    00000110 0000C220	ANDEQ	R12,R0,R0,LSR #4
$icc$VENROM_ADDR:
    00000114 00004308	ANDEQ	R4,R0,R8,LSL #6
$icc$VENRAM_ADDR:
    00000118 4000D3A0	ANDMI	SP,R0,R0,LSR #7
$icc$VENDATA_SIZE:
    0000011C 00000028	ANDEQ	R0,R0,R8,LSR #0
    00000120 4000FFFC	unimp(2)
    00000124 00000028	ANDEQ	R0,R0,R8,LSR #0
    00000128 00000028	ANDEQ	R0,R0,R8,LSR #0
_cstart:
    0000012C E51F1028	LDR	R1,[PC,#-0x28]
    00000130 E51F2028	LDR	R2,[PC,#-0x28]
    00000134 E1B03002	MOVS	R3,R2
    00000138 0A000003	BEQ	0000014C
    0000013C E3A05000	MOV	R5,#0
    00000140 E2533001	SUBS	R3,R3,#1
    00000144 E7C15003	STRB	R5,[R1,R3]
    00000148 1AFFFFFC	BNE	00000140
    0000014C E51F0054	LDR	R0,[PC,#-0x54]
    00000150 E51F1054	LDR	R1,[PC,#-0x54]
    00000154 E51F2054	LDR	R2,[PC,#-0x54]
    00000158 E1B03002	MOVS	R3,R2
    0000015C 0A000003	BEQ	00000170
    00000160 E2533001	SUBS	R3,R3,#1
    00000164 E7D05003	LDRB	R5,[R0,R3]
    00000168 E7C15003	STRB	R5,[R1,R3]
    0000016C 1AFFFFFB	BNE	00000160
    00000170 E51F0064	LDR	R0,[PC,#-0x64]
    00000174 E51F1064	LDR	R1,[PC,#-0x64]
    00000178 E51F2064	LDR	R2,[PC,#-0x64]
    0000017C E1B03002	MOVS	R3,R2
.debug_abbrev_end:
.debug_abbrev_length:
    00000180 0A000003	BEQ	00000194
    00000184 E2533001	SUBS	R3,R3,#1
    00000188 E7D05003	LDRB	R5,[R0,R3]
    0000018C E7C15003	STRB	R5,[R1,R3]
    00000190 1AFFFFFB	BNE	00000184
    00000194 E321F0D1	MSR	CPSR_c,0xD1
    00000198 E51FD080	LDR	SP,[PC,#-0x80]
    0000019C E51FC07C	LDR	R12,[PC,#-0x7C]
    000001A0 E04D000C	SUB	R0,SP,R12
    000001A4 E321F0D2	MSR	CPSR_c,0xD2
    000001A8 E1A0D000	MOV	SP,R0
    000001AC E51FC090	LDR	R12,[PC,#-0x90]
    000001B0 E04D000C	SUB	R0,SP,R12
    000001B4 E321F0D3	MSR	CPSR_c,0xD3
    000001B8 E1A0D000	MOV	SP,R0
    000001BC EB000123	BL	_main
_exit:
    000001C0 EAFFFFFE	B	_exit
FILE: ../../../../../../DOCUME~1/conradt/MYDOCU~1/Projects/DVS128/EDVS128_2106_Rev1.3//EDVS128_2106.c
(0001) #include "EDVS128_2106.h"
(0002) 
(0003) long ledState;	 			// 0:off, -1:on, -2:blinking, >0: timeOn
(0004) 
(0005) // *****************************************************************************
(0006) #pragma interrupt_handler defInterruptServiceRoutine
(0007) void defInterruptServiceRoutine(void) {
_defInterruptServiceRoutine:
$a:
    000001C4 E24EF004	SUB	PC,LR,#4
(0008) /* */
(0009) }
(0010) 
(0011) // *****************************************************************************
(0012) void initProcessor(void) {
(0013) 
(0014)   __DISABLE_INTERRUPT();
_initProcessor:
    000001C8 E10FC000	MRS	R12,CPSR
    000001CC E38CC080	ORR	R12,#0x80
    000001D0 E121F00C	MSR	CPSR_c,R255
(0015) 
(0016) // ************************************************************* PLL
(0017)   //PLL				   		  	// set frequency
(0018) 
(0019) #if PLL_CLOCK == 112
(0020)   SCB_PLLCFG = 0x26;			// multiplier 7(6+1), divider 2 --> Frequency 16.0 MHz * 7 ~ 112 MHz
(0021) #endif
(0022) #if PLL_CLOCK == 96
(0023)   SCB_PLLCFG = 0x25;			// multiplier 6(5+1), divider 2 --> Frequency 16.0 MHz * 6 ~  96 MHz
(0024) #endif
(0025) #if PLL_CLOCK == 80
(0026)   SCB_PLLCFG = 0x24;			// multiplier 5(4+1), divider 2 --> Frequency 16.0 MHz * 5 ~  80 MHz
(0027) #endif
(0028) #if PLL_CLOCK == 64
(0029)   SCB_PLLCFG = 0x23;			// multiplier 4(3+1), divider 2 --> Frequency 16.0 MHz * 4 ~  64 MHz
    000001D4 E3A00023	MOV	R0,#0x23
    000001D8 E59F1144	LDR	R1,[PC,#0x144]
    000001DC E5810000	STR	R0,[R1,#0]
(0030) #endif
(0031) #if PLL_CLOCK == 32
(0032)   SCB_PLLCFG = 0x21;			// multiplier 2(1+1), divider 2 --> Frequency 16.0 MHz * 2 ~  64 MHz
(0033) #endif
(0034) 
(0035)   SCB_PLLCON = 0x01;			// set PLL enable
    000001E0 E3A00001	MOV	R0,#1
    000001E4 E59F113C	LDR	R1,[PC,#0x13C]
    000001E8 E5810000	STR	R0,[R1,#0]
(0036) 
(0037)   SCB_PLLFEED = 0xAA;	 		// activate frequency
    000001EC E3A000AA	MOV	R0,#0xAA
    000001F0 E59F1134	LDR	R1,[PC,#0x134]
    000001F4 E5810000	STR	R0,[R1,#0]
(0038)   SCB_PLLFEED = 0x55;
    000001F8 E3A00055	MOV	R0,#0x55
    000001FC E59F1128	LDR	R1,[PC,#0x128]
    00000200 E5810000	STR	R0,[R1,#0]
(0039)   while ((SCB_PLLSTAT & 0x0400) == 0) {  			// wait till PLL locked
    00000204 E59F0124	LDR	R0,[PC,#0x124]
    00000208 E5900000	LDR	R0,[R0,#0]
    0000020C E3100E40	TST	R0,#0x400
    00000210 0AFFFFFB	BEQ	00000204
(0040)   };
(0041)   SCB_PLLCON = 0x03;			// set PLL connect & enable
    00000214 E3A00003	MOV	R0,#3
    00000218 E59F1108	LDR	R1,[PC,#0x108]
    0000021C E5810000	STR	R0,[R1,#0]
(0042) 
(0043)   SCB_PLLFEED = 0xAA;	 		// activate frequency
    00000220 E3A000AA	MOV	R0,#0xAA
    00000224 E59F1100	LDR	R1,[PC,#0x100]
    00000228 E5810000	STR	R0,[R1,#0]
(0044)   SCB_PLLFEED = 0x55;
    0000022C E3A00055	MOV	R0,#0x55
    00000230 E59F10F4	LDR	R1,[PC,#0xF4]
    00000234 E5810000	STR	R0,[R1,#0]
(0045)   
(0046)   // ****************************************** MAM (memory Acceleration Module)
(0047)   MAM_CR = 0;
    00000238 E3A00000	MOV	R0,#0
    0000023C E59F10F0	LDR	R1,[PC,#0xF0]
    00000240 E5810000	STR	R0,[R1,#0]
(0048)   MAM_TIM = 0x00000003;
    00000244 E3A00003	MOV	R0,#3
    00000248 E59F10E8	LDR	R1,[PC,#0xE8]
    0000024C E5810000	STR	R0,[R1,#0]
(0049)   MAM_CR = 0x00000002;
    00000250 E3A00002	MOV	R0,#2
    00000254 E59F10D8	LDR	R1,[PC,#0xD8]
    00000258 E5810000	STR	R0,[R1,#0]
(0050) 
(0051) // *************************************************** No wakeup from powerdown
(0052)   SCB_EXTWAKE=0x00000000;
    0000025C E3A00000	MOV	R0,#0
    00000260 E59F10D4	LDR	R1,[PC,#0xD4]
    00000264 E5810000	STR	R0,[R1,#0]
(0053) 
(0054) // ************************************************************* Bus clock
(0055) //  SCB_VPBDIV = 0x00000000; //peripheral clock divider, 1/4 of main clock
(0056) //  SCB_VAPBDIV = 0x00000002; //peripheral clock divider, 1/2 of main clock
(0057)   SCB_VPBDIV = 0x00000001; //peripheral clock divider, identical to main clock
    00000268 E3A00001	MOV	R0,#1
    0000026C E59F10CC	LDR	R1,[PC,#0xCC]
    00000270 E5810000	STR	R0,[R1,#0]
(0058) 
(0059)   // ********************************************************* interrupt vector
(0060)   VICIntSelect=0x00000000;
    00000274 E3A00000	MOV	R0,#0
    00000278 E59F10C4	LDR	R1,[PC,#0xC4]
    0000027C E5810000	STR	R0,[R1,#0]
(0061)   VICSoftInt = 0x00000000;
    00000280 E3A00000	MOV	R0,#0
    00000284 E59F10BC	LDR	R1,[PC,#0xBC]
    00000288 E5810000	STR	R0,[R1,#0]
(0062)   VICSoftIntClear = 0xFFFFFFFF;
    0000028C E3E00000	MVN	R0,R0,#0
    00000290 E59F10B4	LDR	R1,[PC,#0xB4]
    00000294 E5810000	STR	R0,[R1,#0]
(0063)   VICIntEnable=0x00000000;
    00000298 E3A00000	MOV	R0,#0
    0000029C E59F10AC	LDR	R1,[PC,#0xAC]
    000002A0 E5810000	STR	R0,[R1,#0]
(0064) 
(0065)   VICDefVectAddr=(unsigned)defInterruptServiceRoutine;
    000002A4 E59F00A8	LDR	R0,[PC,#0xA8]
    000002A8 E59F10A8	LDR	R1,[PC,#0xA8]
    000002AC E5810000	STR	R0,[R1,#0]
(0066)   __ENABLE_INTERRUPT();
    000002B0 E10FC000	MRS	R12,CPSR
    000002B4 E3CCC080	BIC	R12,#0x80
    000002B8 E121F00C	MSR	CPSR_c,R255
(0067)   
(0068)   
(0069)   // ************************************************************* IO ports
(0070)   // port setings
(0071)   SCB_SCS = 0x00000001;								// enable fast IO ports
    000002BC E3A00001	MOV	R0,#1
    000002C0 E59F1094	LDR	R1,[PC,#0x94]
    000002C4 E5810000	STR	R0,[R1,#0]
(0072)   FGPIO_IOMASK = 0x00000000;						// unmask ports
    000002C8 E3A00000	MOV	R0,#0
    000002CC E59F108C	LDR	R1,[PC,#0x8C]
    000002D0 E5810000	STR	R0,[R1,#0]
(0073) 
(0074)   FGPIO_IODIR  = 0x00000000;		 		  		// initially all pins input
    000002D4 E3A00000	MOV	R0,#0
    000002D8 E59F1084	LDR	R1,[PC,#0x84]
    000002DC E5810000	STR	R0,[R1,#0]
(0075)   FGPIO_IOCLR  = 0xFFFFFFFF;	  			   		// clear these pins
    000002E0 E3E00000	MVN	R0,R0,#0
    000002E4 E59F107C	LDR	R1,[PC,#0x7C]
    000002E8 E5810000	STR	R0,[R1,#0]
(0076) 
(0077)   PCB_PINSEL0 = 0x00000000;							// all pins to GPIO
    000002EC E3A00000	MOV	R0,#0
    000002F0 E59F1074	LDR	R1,[PC,#0x74]
    000002F4 E5810000	STR	R0,[R1,#0]
(0078)   PCB_PINSEL1 = 0x00000000;
    000002F8 E3A00000	MOV	R0,#0
    000002FC E59F106C	LDR	R1,[PC,#0x6C]
    00000300 E5810000	STR	R0,[R1,#0]
(0079) 	// individual functions will be added during their respective Init calls
(0080)   
(0081)   // ********************************************************* IO pins
(0082)   FGPIO_IOSET  = PIN_ISP;				// ISP (P0.14) pin to high
    00000304 E3A00C40	MOV	R0,#0x4000
    00000308 E59F1064	LDR	R1,[PC,#0x64]
    0000030C E5810000	STR	R0,[R1,#0]
(0083)   FGPIO_IODIR |= PIN_ISP;				// ISP (P0.14) pin to output
    00000310 E59F004C	LDR	R0,[PC,#0x4C]
    00000314 E5901000	LDR	R1,[R0,#0]
    00000318 E3811C40	ORR	R1,#0x4000
    0000031C E5801000	STR	R1,[R0,#0]
    00000320 E1A0F00E	MOV	PC,LR
(0084) }
(0085) 
(0086) // *****************************************************************************
(0087) void delayUS(unsigned long delayTimeUS) {
_delayUS:
  n                    --> R4
  m                    --> R5
  delayTimeUS          --> R0
$a:
    00000378 E1A0C00D	MOV	R12,SP
    0000037C E92D5030	STMDB	SP!,{R4,R5,R12,LR}
(0088)   unsigned long m,n;
(0089) #if PLL_CLOCK == 112
(0090) #define DELAY_1US	  ((unsigned short) 0x000A)			// at 7x16 = 112 MHz (should be 10.5)
(0091) #endif
(0092) #if PLL_CLOCK == 96
(0093) #define DELAY_1US	  ((unsigned short) 0x0009)			// at 6x16 = 96 MHz
(0094) #endif
(0095) #if PLL_CLOCK == 80
(0096) #define DELAY_1US	  ((unsigned short) 0x0007)			// at 5x16 = 80 MHz (should be 7.5)
(0097) #endif
(0098) #if PLL_CLOCK == 64
(0099) #define DELAY_1US	  ((unsigned short) 0x0006)			// at 4x16 = 64 MHz
(0100) #endif
(0101) #if PLL_CLOCK == 32
(0102) #define DELAY_1US	  ((unsigned short) 0x0003)			// at 2x16 = 32 MHz
(0103) #endif
(0104)   for (n=0; n<delayTimeUS; n++) {
    00000380 E3A04000	MOV	R4,#0
    00000384 EA000005	B	000003A0
(0105)     for (m=DELAY_1US; m; m--) {
    00000388 E3A05006	MOV	R5,#6
    0000038C EA000000	B	00000394
    00000390 E2455001	SUB	R5,R5,#1
    00000394 E3550000	CMP	R5,#0
    00000398 1AFFFFFC	BNE	00000390
    0000039C E2844001	ADD	R4,R4,#1
    000003A0 E1540000	CMP	R4,R0
    000003A4 3AFFFFF7	BCC	00000388
    000003A8 E8BDA030	LDMIA	SP!,{R4,R5,R13,PC}
(0106) 	}
(0107)   }
(0108) }
(0109) void delayMS(unsigned long delayTimeMS) {
_delayMS:
  n                    --> R4
  m                    --> R5
  delayTimeMS          --> R0
    000003AC E1A0C00D	MOV	R12,SP
    000003B0 E92D5030	STMDB	SP!,{R4,R5,R12,LR}
(0110)   unsigned long m,n;
(0111) #define DELAY_1MS	  ((unsigned short) ((0x5A)*PLL_CLOCK))
(0112)   for (n=0; n<delayTimeMS; n++) {
    000003B4 E3A04000	MOV	R4,#0
    000003B8 EA000005	B	000003D4
(0113)     for (m=DELAY_1MS; m; m--) {
    000003BC E3A05D5A	MOV	R5,#0x1680
    000003C0 EA000000	B	000003C8
    000003C4 E2455001	SUB	R5,R5,#1
    000003C8 E3550000	CMP	R5,#0
    000003CC 1AFFFFFC	BNE	000003C4
    000003D0 E2844001	ADD	R4,R4,#1
    000003D4 E1540000	CMP	R4,R0
    000003D8 3AFFFFF7	BCC	000003BC
    000003DC E8BDA030	LDMIA	SP!,{R4,R5,R13,PC}
(0114) 	}
(0115)   }
(0116) }
(0117) 
(0118) // *****************************************************************************
(0119) void LEDSetState(long state) {
_LEDSetState:
  state                --> R4
    000003E0 E1A0C00D	MOV	R12,SP
    000003E4 E92D5010	STMDB	SP!,{R4,R12,LR}
    000003E8 E1A04000	MOV	R4,R0
(0120)   ledState = state;
    000003EC E59F0028	LDR	R0,[PC,#0x28]
    000003F0 E5804000	STR	R4,[R0,#0]
(0121)   if (state!=0) {
    000003F4 E3540000	CMP	R4,#0
    000003F8 0A000003	BEQ	0000040C
(0122)     LED_ON();
    000003FC E3A00D80	MOV	R0,#0x2000
    00000400 E59F1018	LDR	R1,[PC,#24]
    00000404 E5810000	STR	R0,[R1,#0]
(0123)   } else {
    00000408 EA000002	B	00000418
(0124)     LED_OFF();
    0000040C E3A00D80	MOV	R0,#0x2000
    00000410 E59F100C	LDR	R1,[PC,#12]
    00000414 E5810000	STR	R0,[R1,#0]
(0125)   }
    00000418 E8BDA010	LDMIA	SP!,{R4,R13,PC}
(0126) }
(0127) void LEDInit(void) {
_LEDInit:
$a:
    00000428 E1A0C00D	MOV	R12,SP
    0000042C E92D5830	STMDB	SP!,{R4,R5,R11,R12,LR}
    00000430 E1A0B00D	MOV	R11,SP
(0128)   FGPIO_IODIR |= PIN_LED;			   	// set LEDs as output
    00000434 E59F4014	LDR	R4,[PC,#20]
    00000438 E5945000	LDR	R5,[R4,#0]
    0000043C E3855D80	ORR	R5,#0x2000
    00000440 E5845000	STR	R5,[R4,#0]
(0129)   LEDSetBlinking();
    00000444 E3E00000	MVN	R0,R0,#0
    00000448 EBFFFFE4	BL	_LEDSetState
    0000044C E89BA830	LDMIA	R11,{R4,R5,R11,R13,PC}
(0130) //  LEDSetOn();
(0131) }
(0132) 
(0133) // *****************************************************************************
(0134) void resetDevice(void) {
(0135) #ifdef INCLUDE_PWM246
(0136)   PWM246StopPWM();
(0137) #endif
(0138) 
(0139)   // convince WDT to trigger :)
(0140) 
(0141)   WD_WDTC  = 0xFF;	  	 	     // minimal time allowed
_resetDevice:
$a:
    00000454 E3A000FF	MOV	R0,#0xFF
    00000458 E59F102C	LDR	R1,[PC,#0x2C]
    0000045C E5810000	STR	R0,[R1,#0]
(0142)   WD_WDMOD = 0x03;				 // enable WDT and reset on underflow
    00000460 E3A00003	MOV	R0,#3
    00000464 E59F1024	LDR	R1,[PC,#0x24]
    00000468 E5810000	STR	R0,[R1,#0]
(0143)   		  					 		   // PCLCK at 60MHz -> Reset after 1000*(1/60MHz)
(0144)   WD_WDFEED = 0xAA;  	 		 // enable watch dog
    0000046C E3A000AA	MOV	R0,#0xAA
    00000470 E59F101C	LDR	R1,[PC,#28]
    00000474 E5810000	STR	R0,[R1,#0]
(0145)   WD_WDFEED = 0x55;
    00000478 E3A00055	MOV	R0,#0x55
    0000047C E59F1010	LDR	R1,[PC,#16]
    00000480 E5810000	STR	R0,[R1,#0]
(0146) 
(0147)   while (1) {	  						   // infinite loop, rest will trigger
    00000484 EAFFFFFE	B	00000484
    00000488 E1A0F00E	MOV	PC,LR
(0148)   };
(0149) }
(0150) 
(0151) // *****************************************************************************
(0152) void enterReprogrammingMode(void) {
$a:
_enterReprogrammingMode:
  bootloader_entry     --> R6
  newChar              --> R11,+1
    00000498 E1A0C00D	MOV	R12,SP
    0000049C E92D5870	STMDB	SP!,{R4,R5,R6,R11,R12,LR}
    000004A0 E1A0B00D	MOV	R11,SP
    000004A4 E24DD004	SUB	SP,SP,#4
(0153)   void (*bootloader_entry)(void) = (void*)0;
    000004A8 E3A06000	MOV	R6,#0
(0154)   volatile char newChar;
(0155) 
(0156) #ifdef INCLUDE_PWM246
(0157)   PWM246StopPWM();
(0158) #endif
(0159) 
(0160)   __DISABLE_INTERRUPT();
    000004AC E10FC000	MRS	R12,CPSR
    000004B0 E38CC080	ORR	R12,#0x80
    000004B4 E121F00C	MSR	CPSR_c,R255
(0161)   VICIntEnClr = 0xFFFFFFFF;            	// Clear all interrupts
    000004B8 E3E04000	MVN	R4,R0,#0
    000004BC E59F5130	LDR	R5,[PC,#0x130]
    000004C0 E5854000	STR	R4,[R5,#0]
(0162) 
(0163)   /* reset PINSEL (set all pins to GPIO) */
(0164)   SCB_SCS = 0x0000;					// disable fast IO ports
    000004C4 E3A04000	MOV	R4,#0
    000004C8 E59F5128	LDR	R5,[PC,#0x128]
    000004CC E5854000	STR	R4,[R5,#0]
(0165)   PCB_PINSEL0 = 0x00000000;			// all pins to IO
    000004D0 E3A04000	MOV	R4,#0
    000004D4 E59F5120	LDR	R5,[PC,#0x120]
    000004D8 E5854000	STR	R4,[R5,#0]
(0166)   PCB_PINSEL1 = 0x00000000;
    000004DC E3A04000	MOV	R4,#0
    000004E0 E59F5118	LDR	R5,[PC,#0x118]
    000004E4 E5854000	STR	R4,[R5,#0]
(0167) 
(0168)   /* reset GPIO, but drive P0.14 low (output) */
(0169)   GPIO_IODIR  = PIN_ISP;	   	   // only ISP (->P0.14) pin to output
    000004E8 E3A04C40	MOV	R4,#0x4000
    000004EC E59F5110	LDR	R5,[PC,#0x110]
    000004F0 E5854000	STR	R4,[R5,#0]
(0170)   GPIO_IOCLR  = PIN_ISP;           // ISP (->P0.14) pin to low
    000004F4 E3A04C40	MOV	R4,#0x4000
    000004F8 E59F5108	LDR	R5,[PC,#0x108]
    000004FC E5854000	STR	R4,[R5,#0]
(0171)   delayMS(20);
    00000500 E3A00014	MOV	R0,#20
    00000504 EBFFFFA8	BL	_delayMS
(0172) 
(0173)   /* power up all peripherals */
(0174)   SCB_PCONP = 0x000003be;     /* for LPC2104/5/6
    00000508 E59F40FC	LDR	R4,[PC,#0xFC]
    0000050C E59F50FC	LDR	R5,[PC,#0xFC]
    00000510 E5854000	STR	R4,[R5,#0]
(0175) 
(0176)   /* disconnect PLL */
(0177)   SCB_PLLCON = 0x00;
    00000514 E3A04000	MOV	R4,#0
    00000518 E59F50F4	LDR	R5,[PC,#0xF4]
    0000051C E5854000	STR	R4,[R5,#0]
(0178)   SCB_PLLFEED = 0xAA;
    00000520 E3A040AA	MOV	R4,#0xAA
    00000524 E59F50EC	LDR	R5,[PC,#0xEC]
    00000528 E5854000	STR	R4,[R5,#0]
(0179)   SCB_PLLFEED = 0x55;
    0000052C E3A04055	MOV	R4,#0x55
    00000530 E59F50E0	LDR	R5,[PC,#0xE0]
    00000534 E5854000	STR	R4,[R5,#0]
(0180) 
(0181)   /* set peripheral bus to 1/4th of the system clock */
(0182)   SCB_VPBDIV = 0x00;
    00000538 E3A04000	MOV	R4,#0
    0000053C E59F50D8	LDR	R5,[PC,#0xD8]
    00000540 E5854000	STR	R4,[R5,#0]
(0183) 
(0184)   /* map bootloader vectors */
(0185)   SCB_MEMMAP = 0;
    00000544 E3A04000	MOV	R4,#0
    00000548 E59F50D0	LDR	R5,[PC,#0xD0]
    0000054C E5854000	STR	R4,[R5,#0]
(0186) 
(0187)   /* clear WDT */
(0188)   WD_WDMOD = 0; 			  // disable WDT; ensure overflow-flag is false,
    00000550 E3A04000	MOV	R4,#0
    00000554 E59F50C8	LDR	R5,[PC,#0xC8]
    00000558 E5854000	STR	R4,[R5,#0]
(0189)   			  				  // otherwise BL is ignored
(0190) 
(0191)   /* clear fractional baud rate generator of serial port */
(0192)   UART0_FDR = 0x10;							// clear fractional baud rate
    0000055C E3A04010	MOV	R4,#16
    00000560 E59F50C0	LDR	R5,[PC,#0xC0]
    00000564 E5854000	STR	R4,[R5,#0]
(0193)   UART0_FCR = 0x00;							// disable the fifos
    00000568 E3A04000	MOV	R4,#0
    0000056C E59F50B8	LDR	R5,[PC,#0xB8]
    00000570 E5854000	STR	R4,[R5,#0]
    00000574 EA000002	B	00000584
(0194)   while (UART0_LSR & 0x01) {				// new char here?
(0195)     newChar = UART0_RBR;
    00000578 E59F40B0	LDR	R4,[PC,#0xB0]
    0000057C E5944000	LDR	R4,[R4,#0]
    00000580 E54B4001	STRB	R4,[R11,#-1]
    00000584 E59F40A8	LDR	R4,[PC,#0xA8]
    00000588 E5944000	LDR	R4,[R4,#0]
    0000058C E3140001	TST	R4,#1
    00000590 1AFFFFF8	BNE	00000578
(0196)   }
(0197) 
(0198)   /* reset T1 to default value */
(0199)   T1_CTCR = 0x00;				// increase time on PCLK
    00000594 E3A04000	MOV	R4,#0
    00000598 E59F5098	LDR	R5,[PC,#0x98]
    0000059C E5854000	STR	R4,[R5,#0]
(0200)   T1_PR	  = 0;					// prescale register, increment timer every 64000th PCLK == 1ms
    000005A0 E3A04000	MOV	R4,#0
    000005A4 E59F5090	LDR	R5,[PC,#0x90]
    000005A8 E5854000	STR	R4,[R5,#0]
(0201)   T1_MCR  = 0x00;				// match register, no action on any matches (later: reset on 0xFFFF) !!!
    000005AC E3A04000	MOV	R4,#0
    000005B0 E59F5088	LDR	R5,[PC,#0x88]
    000005B4 E5854000	STR	R4,[R5,#0]
(0202)   T1_CCR  = 0x00;				// react on external falling edge, generate interrupt
    000005B8 E3A04000	MOV	R4,#0
    000005BC E59F5080	LDR	R5,[PC,#0x80]
    000005C0 E5854000	STR	R4,[R5,#0]
(0203)   T1_TC	  = 0;					// reset counter to zero
    000005C4 E3A04000	MOV	R4,#0
    000005C8 E59F5078	LDR	R5,[PC,#0x78]
    000005CC E5854000	STR	R4,[R5,#0]
(0204)   T1_TCR  = 0x0;				// enable Timer/Counter 0
    000005D0 E3A04000	MOV	R4,#0
    000005D4 E59F5070	LDR	R5,[PC,#0x70]
    000005D8 E5854000	STR	R4,[R5,#0]
(0205) 
(0206)   // clear ISP pin, such that after ISP system returns to running mode
(0207)   GPIO_IODIR  = 0;	   	      // all pins back to input
    000005DC E3A04000	MOV	R4,#0
    000005E0 E59F501C	LDR	R5,[PC,#28]
    000005E4 E5854000	STR	R4,[R5,#0]
(0208) 
(0209)   /* jump to the bootloader address */
(0210)   bootloader_entry();
    000005E8 E1A0E00F	MOV	LR,PC
    000005EC E1A0F006	MOV	PC,R6
    000005F0 E89BA870	LDMIA	R11,{R4,R5,R6,R11,R13,PC}
(0211) }
(0212) 
(0213) 
(0214) // *****************************************************************************
(0215) // ************************************************************* Main
(0216) // *****************************************************************************
(0217) void main(void) {
_main:
$a:
    00000650 E92D4000	STMDB	SP!,{LR}
(0218)   (void) initProcessor();
    00000654 EBFFFEDB	BL	_initProcessor
(0219) 
(0220)   (void) DVS128ChipInit();
    00000658 EB00004F	BL	_DVS128ChipInit
(0221) 
(0222)   (void) LEDInit();
    0000065C EBFFFF71	BL	_LEDInit
(0223) 
(0224)   (void) UARTInit();
    00000660 EB0002C3	BL	_UARTInit
(0225) 
(0226) #ifdef INCLUDE_PWM246
(0227)   (void) PWM246Init();
(0228) #endif
(0229) 
(0230) #ifdef INCLUDE_TRACK_HF_LED
(0231)   (void) EP_TrackHFLInit();
(0232) #endif
(0233) 
(0234)   (void) mainloopInit();
    00000664 EB000002	BL	_mainloopInit
(0235) 
(0236)   (void) UARTShowVersion();
    00000668 EB0002F2	BL	_UARTShowVersion
(0237) 
(0238)   (void) mainloop();
    0000066C EB000ABB	BL	arm_to_ramfunc_branch_veneer__mainloop
    00000670 E8BD8000	LDMIA	SP!,{PC}
FILE: ../../../../../../DOCUME~1/conradt/MYDOCU~1/Projects/DVS128/EDVS128_2106_Rev1.3//MainLoop.c
(0001) #include "EDVS128_2106.h"
(0002) 
(0003) // *****************************************************************************
(0004) extern long ledState;	 			// 0:off, -1:on, -2:blinking, >0: timeOn
(0005) 
(0006) extern unsigned short eventBufferA[DVS_EVENTBUFFER_SIZE];		  // for event addresses
(0007) extern unsigned long  eventBufferT[DVS_EVENTBUFFER_SIZE];		  // for event time stamps
(0008) extern unsigned long  eventBufferWritePointer, eventBufferReadPointer;
(0009) 
(0010) extern unsigned long enableEventSending;
(0011) 
(0012) extern unsigned char commandLine[UART_COMMAND_LINE_MAX_LENGTH];
(0013) extern unsigned long commandLinePointer;
(0014) 
(0015) unsigned long transmitEventRateEnable;
(0016) 
(0017) unsigned char TXBuffer[256];							// events sending
(0018) unsigned long TXBufferIndex=0;
(0019) 
(0020) unsigned long eventCounterTotal, eventCounterOn, eventCounterOff;
(0021) unsigned long currentTimerValue,
(0022) 		 	  nextTimer1msValue, nextTimer2msValue, nextTimer10msValue, nextTimer100msValue, nextTimer1000msValue;
(0023) 
(0024) unsigned char dataForTransmission[16];
(0025) 
(0026) unsigned long eDVSDataFormat;
(0027) unsigned char hexLookupTable[16];
(0028) 
(0029) #ifdef INCLUDE_TRACK_HF_LED
(0030)   extern unsigned short tsMemory[128][128];
(0031)   extern unsigned long trackingHFLCenterX[4], trackingHFLCenterY[4], trackingHFLCenterC[4];
(0032)   extern unsigned long trackingHFLDesiredTimeDiff[4];
(0033)   extern unsigned long transmitTrackHFLED;
(0034)   #ifdef INCLUDE_TRACK_HF_LED_SERVO_OUT
(0035)     extern unsigned long TrackHFL_PWM0, TrackHFL_PWM1;
(0036)     extern unsigned long EP_TrackHFP_ServoEnabled;
(0037)   #endif
(0038) #endif
(0039) 
(0040) #ifdef INCLUDE_PIXEL_CUTOUT_REGION
(0041)   extern unsigned long pixelCutoutMinX, pixelCutoutMaxX, pixelCutoutMinY, pixelCutoutMaxY;
(0042) #endif
(0043) 
(0044) // *****************************************************************************
(0045) // *****************************************************************************
(0046) void mainloopInit(void) {
$a:
_mainloopInit:
  n                    --> R4
    00000674 E1A0C00D	MOV	R12,SP
    00000678 E92D5010	STMDB	SP!,{R4,R12,LR}
(0047)   unsigned long n;
(0048) 
(0049)   eventCounterTotal = 0;
    0000067C E3A00000	MOV	R0,#0
    00000680 E59F1078	LDR	R1,[PC,#0x78]
    00000684 E5810000	STR	R0,[R1,#0]
(0050)   eventCounterOn = 0;
    00000688 E3A00000	MOV	R0,#0
    0000068C E59F1070	LDR	R1,[PC,#0x70]
    00000690 E5810000	STR	R0,[R1,#0]
(0051)   eventCounterOff = 0;
    00000694 E3A00000	MOV	R0,#0
    00000698 E59F1068	LDR	R1,[PC,#0x68]
    0000069C E5810000	STR	R0,[R1,#0]
(0052) 
(0053)   transmitEventRateEnable = 0;			// default: disable automatic EPS control
    000006A0 E3A00000	MOV	R0,#0
    000006A4 E59F1060	LDR	R1,[PC,#0x60]
    000006A8 E5810000	STR	R0,[R1,#0]
(0054) 
(0055)   eDVSDataFormat = EDVS_DATA_FORMAT_DEFAULT;
    000006AC E3A0001F	MOV	R0,#31
    000006B0 E59F1058	LDR	R1,[PC,#0x58]
    000006B4 E5810000	STR	R0,[R1,#0]
(0056) 
(0057)   for (n=0; n<10; n++) { hexLookupTable[n]   ='0'+n; }
    000006B8 E3A04000	MOV	R4,#0
    000006BC EA000003	B	000006D0
    000006C0 E59F004C	LDR	R0,[PC,#0x4C]
    000006C4 E2841030	ADD	R1,R4,#0x30
    000006C8 E7C41000	STRB	R1,[R4,R0]
    000006CC E2844001	ADD	R4,R4,#1
    000006D0 E354000A	CMP	R4,#10
    000006D4 3AFFFFF9	BCC	000006C0
(0058)   for (n=0; n< 6; n++) { hexLookupTable[n+10]='A'+n; }
    000006D8 E3A04000	MOV	R4,#0
    000006DC EA000004	B	000006F4
    000006E0 E284000A	ADD	R0,R4,#10
    000006E4 E59F1028	LDR	R1,[PC,#0x28]
    000006E8 E2842041	ADD	R2,R4,#0x41
    000006EC E7C02001	STRB	R2,[R0,R1]
    000006F0 E2844001	ADD	R4,R4,#1
    000006F4 E3540006	CMP	R4,#6
    000006F8 3AFFFFF8	BCC	000006E0
    000006FC E8BDA010	LDMIA	SP!,{R4,R13,PC}
(0059) }
(0060) 
(0061) // *****************************************************************************
(0062) #pragma ramfunc transmitSpecialData
(0063) void transmitSpecialData(unsigned long l) {
$a:
_transmitSpecialData:
  n                    --> R4
  l                    --> R5
    40000004 E1A0C00D	MOV	R12,SP
    40000008 E92D5030	STMDB	SP!,{R4,R5,R12,LR}
    4000000C E1A05000	MOV	R5,R0
(0064)   unsigned long n;
(0065) 
(0066)   for (n=(TXBufferIndex+l); n>l; n--) {		  // shift data "up"
    40000010 E59F0074	LDR	R0,[PC,#0x74]
    40000014 E5900000	LDR	R0,[R0,#0]
    40000018 E0804005	ADD	R4,R0,R5
    4000001C EA000005	B	40000038
(0067)     TXBuffer[n] = TXBuffer[n-(l+1)];
    40000020 E59F0068	LDR	R0,[PC,#0x68]
    40000024 E2851001	ADD	R1,R5,#1
    40000028 E0441001	SUB	R1,R4,R1
    4000002C E7D11000	LDRB	R1,[R1,R0]
    40000030 E7C41000	STRB	R1,[R4,R0]
    40000034 E2444001	SUB	R4,R4,#1
    40000038 E1540005	CMP	R4,R5
    4000003C 8AFFFFF7	BHI	40000020
(0068)   }
(0069) 
(0070)   for (n=0; n<l; n++) {				  		  // fill data in
    40000040 E3A04000	MOV	R4,#0
    40000044 EA000004	B	4000005C
(0071)     TXBuffer[n] = dataForTransmission[n];
    40000048 E59F0040	LDR	R0,[PC,#0x40]
    4000004C E59F1040	LDR	R1,[PC,#0x40]
    40000050 E7D41001	LDRB	R1,[R4,R1]
    40000054 E7C41000	STRB	R1,[R4,R0]
    40000058 E2844001	ADD	R4,R4,#1
    4000005C E1540005	CMP	R4,R5
    40000060 3AFFFFF8	BCC	40000048
(0072)   }
(0073)   TXBuffer[l] = 0x80 + (l&0x0F);			  // 0x8y: start of special sequence of length y
    40000064 E59F0024	LDR	R0,[PC,#0x24]
    40000068 E205100F	AND	R1,R5,#15
    4000006C E2811080	ADD	R1,R1,#0x80
    40000070 E7C51000	STRB	R1,[R5,R0]
(0074) 
(0075)   TXBufferIndex += (l+1);
    40000074 E59F0010	LDR	R0,[PC,#16]
    40000078 E2851001	ADD	R1,R5,#1
    4000007C E5902000	LDR	R2,[R0,#0]
    40000080 E0821001	ADD	R1,R2,R1
    40000084 E5801000	STR	R1,[R0,#0]
    40000088 E8BDA030	LDMIA	SP!,{R4,R5,R13,PC}
(0076) }
(0077) 
(0078) // *****************************************************************************
(0079) #pragma ramfunc swapByteOrderInMemory
(0080) void swapByteOrderInMemory(char *c, unsigned long l) {
_swapByteOrderInMemory:
  tmp                  --> R6
  cr                   --> R5
  l                    --> R5
  c                    --> R4
$a:
    40000098 E1A0C00D	MOV	R12,SP
    4000009C E92D5070	STMDB	SP!,{R4,R5,R6,R12,LR}
    400000A0 E1A04000	MOV	R4,R0
    400000A4 E1A05001	MOV	R5,R1
(0081)   char *cr;
(0082)   unsigned char tmp;
(0083) 
(0084)   cr=c+l-1;						// point to end of sequence
    400000A8 E0850004	ADD	R0,R5,R4
    400000AC E3E01000	MVN	R1,R0,#0
    400000B0 E0805001	ADD	R5,R0,R1
    400000B4 EA000006	B	400000D4
(0085) 
(0086)   while (c<cr) {
(0087)     tmp = *c;
    400000B8 E5D46000	LDRB	R6,[R4,#0]
(0088) 	*c = *cr;
    400000BC E5D50000	LDRB	R0,[R5,#0]
    400000C0 E5C40000	STRB	R0,[R4,#0]
(0089) 	*cr = tmp;
    400000C4 E5C56000	STRB	R6,[R5,#0]
(0090)     c++;
    400000C8 E2844001	ADD	R4,R4,#1
(0091) 	cr--;
    400000CC E3E00000	MVN	R0,R0,#0
    400000D0 E0855000	ADD	R5,R5,R0
    400000D4 E1A00005	MOV	R0,R5
    400000D8 E1A01004	MOV	R1,R4
    400000DC E1510000	CMP	R1,R0
    400000E0 3AFFFFF4	BCC	400000B8
    400000E4 E8BDA070	LDMIA	SP!,{R4,R5,R6,R13,PC}
(0092)   }
(0093) 
(0094) }
(0095) 	  
(0096) // *****************************************************************************
(0097) // *****************************************************************************
(0098) #pragma ramfunc mainloop
(0099) void mainloop(void) {
$a:
$a:
_mainloop:
  newChar              --> R8
  lastDVSEventTime     --> R7
  newDVSEvent          --> R8
  eventT               --> R8
  eventA               --> R9
  newDVSEventTime      --> R9
    400000E8 E1A0C00D	MOV	R12,SP
    400000EC E92D5BF0	STMDB	SP!,{R4,R5,R6,R7,R8,R9,R11,R12,LR}
    400000F0 E1A0B00D	MOV	R11,SP
    400000F4 E24DD008	SUB	SP,SP,#8
(0100)   unsigned long newChar;
(0101)   unsigned long newDVSEvent;
(0102)   unsigned long lastDVSEventTime, newDVSEventTime;
(0103)   unsigned long eventA, eventT;
(0104) 
(0105)   nextTimer1msValue = T0_TC + 100; 		 	   // start reporting after 1000 ms
    400000F8 E59F4000	LDR	R4,[PC,#0]
    400000FC E1A0F00F	MOV	PC,PC
    40000100 E0004008	AND	R4,R0,R8
    40000104 E5944000	LDR	R4,[R4,#0]
    40000108 E2844064	ADD	R4,R4,#0x64
    4000010C E59F5000	LDR	R5,[PC,#0]
    40000110 E1A0F00F	MOV	PC,PC
    40000114 400011B8	STRMIH	R1,[R0],-R8
    40000118 E5854000	STR	R4,[R5,#0]
(0106)   nextTimer2msValue = nextTimer1msValue; 	   // same time here
    4000011C E59F4000	LDR	R4,[PC,#0]
    40000120 E1A0F00F	MOV	PC,PC
    40000124 400011B8	STRMIH	R1,[R0],-R8
    40000128 E5944000	LDR	R4,[R4,#0]
    4000012C E59F5000	LDR	R5,[PC,#0]
    40000130 E1A0F00F	MOV	PC,PC
    40000134 400011B4	STRMIH	R1,[R0],-R4
    40000138 E5854000	STR	R4,[R5,#0]
(0107)   nextTimer10msValue = nextTimer1msValue; 	   // same time here
    4000013C E59F4000	LDR	R4,[PC,#0]
    40000140 E1A0F00F	MOV	PC,PC
    40000144 400011B8	STRMIH	R1,[R0],-R8
    40000148 E5944000	LDR	R4,[R4,#0]
    4000014C E59F5000	LDR	R5,[PC,#0]
    40000150 E1A0F00F	MOV	PC,PC
    40000154 400011B0	STRMIH	R1,[R0],-R0
    40000158 E5854000	STR	R4,[R5,#0]
(0108)   nextTimer100msValue = nextTimer1msValue; 	   // same time here
    4000015C E59F4000	LDR	R4,[PC,#0]
    40000160 E1A0F00F	MOV	PC,PC
    40000164 400011B8	STRMIH	R1,[R0],-R8
    40000168 E5944000	LDR	R4,[R4,#0]
    4000016C E59F5000	LDR	R5,[PC,#0]
    40000170 E1A0F00F	MOV	PC,PC
    40000174 400011AC	ANDMI	R1,R0,R12,LSR #3
    40000178 E5854000	STR	R4,[R5,#0]
(0109)   nextTimer1000msValue = nextTimer1msValue;    // same time here
    4000017C E59F4000	LDR	R4,[PC,#0]
    40000180 E1A0F00F	MOV	PC,PC
    40000184 400011B8	STRMIH	R1,[R0],-R8
    40000188 E5944000	LDR	R4,[R4,#0]
    4000018C E59F5000	LDR	R5,[PC,#0]
    40000190 E1A0F00F	MOV	PC,PC
    40000194 400011A8	ANDMI	R1,R0,R8,LSR #3
    40000198 E5854000	STR	R4,[R5,#0]
(0110) 
(0111) // *****************************************************************************
(0112) //    Main Loop Start
(0113) // *****************************************************************************
(0114) MLStart:
(0115) 
(0116) // *****************************************************************************
(0117) //    LEDIterate();
(0118) // *****************************************************************************
(0119) #ifndef TIME_OPTIMIZED
(0120)   if (ledState) {
    4000019C E59F4000	LDR	R4,[PC,#0]
    400001A0 E1A0F00F	MOV	PC,PC
    400001A4 40001180	ANDMI	R1,R0,R0,LSL #3
    400001A8 E5944000	LDR	R4,[R4,#0]
    400001AC E3540000	CMP	R4,#0
    400001B0 0A000040	BEQ	400002B8
(0121)     if (ledState > 0) {
    400001B4 E59F4000	LDR	R4,[PC,#0]
    400001B8 E1A0F00F	MOV	PC,PC
    400001BC 40001180	ANDMI	R1,R0,R0,LSL #3
    400001C0 E5944000	LDR	R4,[R4,#0]
    400001C4 E3540000	CMP	R4,#0
    400001C8 DA000016	BLE	40000228
(0122)       ledState--;
    400001CC E59F4000	LDR	R4,[PC,#0]
    400001D0 E1A0F00F	MOV	PC,PC
    400001D4 40001180	ANDMI	R1,R0,R0,LSL #3
    400001D8 E5945000	LDR	R5,[R4,#0]
    400001DC E2455001	SUB	R5,R5,#1
    400001E0 E5845000	STR	R5,[R4,#0]
(0123) 	  if (ledState == 1) {
    400001E4 E59F4000	LDR	R4,[PC,#0]
    400001E8 E1A0F00F	MOV	PC,PC
    400001EC 40001180	ANDMI	R1,R0,R0,LSL #3
    400001F0 E5944000	LDR	R4,[R4,#0]
    400001F4 E3540001	CMP	R4,#1
    400001F8 1A00002E	BNE	400002B8
(0124) 	    ledState = 0;
    400001FC E3A04000	MOV	R4,#0
    40000200 E59F5000	LDR	R5,[PC,#0]
    40000204 E1A0F00F	MOV	PC,PC
    40000208 40001180	ANDMI	R1,R0,R0,LSL #3
    4000020C E5854000	STR	R4,[R5,#0]
(0125) 	    LED_OFF();
    40000210 E3A04D80	MOV	R4,#0x2000
    40000214 E59F5000	LDR	R5,[PC,#0]
    40000218 E1A0F00F	MOV	PC,PC
    4000021C 3FFFC018	SWICC	0xFFC018
    40000220 E5854000	STR	R4,[R5,#0]
(0126) 	  }
(0127)     } else {
    40000224 EA000023	B	400002B8
(0128)       ledState++;
    40000228 E59F4000	LDR	R4,[PC,#0]
    4000022C E1A0F00F	MOV	PC,PC
    40000230 40001180	ANDMI	R1,R0,R0,LSL #3
    40000234 E5945000	LDR	R5,[R4,#0]
    40000238 E2855001	ADD	R5,R5,#1
    4000023C E5845000	STR	R5,[R4,#0]
(0129) 	  if (ledState == 0) {
    40000240 E59F4000	LDR	R4,[PC,#0]
    40000244 E1A0F00F	MOV	PC,PC
    40000248 40001180	ANDMI	R1,R0,R0,LSL #3
    4000024C E5944000	LDR	R4,[R4,#0]
    40000250 E3540000	CMP	R4,#0
    40000254 1A000017	BNE	400002B8
(0130) 	    LED_TOGGLE();
    40000258 E59F4000	LDR	R4,[PC,#0]
    4000025C E1A0F00F	MOV	PC,PC
    40000260 3FFFC014	SWICC	0xFFC014
    40000264 E5944000	LDR	R4,[R4,#0]
    40000268 E3140D80	TST	R4,#0x2000
    4000026C 0A000005	BEQ	40000288
    40000270 E3A04D80	MOV	R4,#0x2000
    40000274 E59F5000	LDR	R5,[PC,#0]
    40000278 E1A0F00F	MOV	PC,PC
    4000027C 3FFFC01C	SWICC	0xFFC01C
    40000280 E5854000	STR	R4,[R5,#0]
    40000284 EA000004	B	4000029C
    40000288 E3A04D80	MOV	R4,#0x2000
    4000028C E59F5000	LDR	R5,[PC,#0]
    40000290 E1A0F00F	MOV	PC,PC
    40000294 3FFFC018	SWICC	0xFFC018
    40000298 E5854000	STR	R4,[R5,#0]
(0131)   	    ledState = ((long) -50000);
    4000029C E59F4000	LDR	R4,[PC,#0]
    400002A0 E1A0F00F	MOV	PC,PC
    400002A4 FFFF3CB0	?[70)
    400002A8 E59F5000	LDR	R5,[PC,#0]
    400002AC E1A0F00F	MOV	PC,PC
    400002B0 40001180	ANDMI	R1,R0,R0,LSL #3
    400002B4 E5854000	STR	R4,[R5,#0]
(0132)       }
(0133)     }
(0134)   }
(0135) #endif  // #ifndef TIME_OPTIMIZED
(0136) 
(0137) // *****************************************************************************
(0138) //    UARTIterate();
(0139) // *****************************************************************************
(0140)   if (UART0_LSR & 0x01) {				   // char arrived?
    400002B8 E59F4000	LDR	R4,[PC,#0]
    400002BC E1A0F00F	MOV	PC,PC
    400002C0 E000C014	AND	R12,R0,R4
    400002C4 E5944000	LDR	R4,[R4,#0]
    400002C8 E3140001	TST	R4,#1
    400002CC 0A000006	BEQ	400002EC
(0141)     newChar = UART0_RBR;
    400002D0 E59F4000	LDR	R4,[PC,#0]
    400002D4 E1A0F00F	MOV	PC,PC
    400002D8 E000C000	AND	R12,R0,R0
    400002DC E5948000	LDR	R8,[R4,#0]
(0142)     UARTParseNewChar(newChar);
    400002E0 E1A04008	MOV	R4,R8
    400002E4 E20400FF	AND	R0,R4,#0xFF
    400002E8 EB00342C	BL	ramfunc_to_arm_branch_veneer__UARTParseNewChar
(0143)   }
(0144) 
(0145) // *****************************************************************************
(0146) //    fetchEventsIterate();
(0147) // *****************************************************************************
(0148) DVSFetchNewEvents:
(0149)   newDVSEventTime = T1_CR0;
    400002EC E59F4000	LDR	R4,[PC,#0]
    400002F0 E1A0F00F	MOV	PC,PC
    400002F4 E000802C	AND	R8,R0,R12,LSR #0
    400002F8 E5949000	LDR	R9,[R4,#0]
(0150) 
(0151)   if (lastDVSEventTime != newDVSEventTime) {
    400002FC E1570009	CMP	R7,R9
    40000300 0A000039	BEQ	400003EC
(0152) 
(0153)     newDVSEvent = (FGPIO_IOPIN & PIN_ALL_ADDR) >> 16;			// fetch event
    40000304 E59F4000	LDR	R4,[PC,#0]
    40000308 E1A0F00F	MOV	PC,PC
    4000030C 7FFF0000	SWIVC	0xFF0000
    40000310 E59F5000	LDR	R5,[PC,#0]
    40000314 E1A0F00F	MOV	PC,PC
    40000318 3FFFC014	SWICC	0xFFC014
    4000031C E5955000	LDR	R5,[R5,#0]
    40000320 E0054004	AND	R4,R5,R4
    40000324 E1A08824	MOV	R8,R4,LSR #16
(0154)     lastDVSEventTime = newDVSEventTime;
    40000328 E1A07009	MOV	R7,R9
(0155) 
(0156) #ifdef INCLUDE_PIXEL_CUTOUT_REGION
(0157)     {
(0158) 	  unsigned long pX = ((newDVSEvent>>8) & 0x7F);
(0159) 	  unsigned long pY = ((newDVSEvent)    & 0x7F);
(0160) 
(0161) 	  if ((pixelCutoutMinX <= pX) && (pixelCutoutMaxX >= pX) &&
(0162) 	  	  (pixelCutoutMinY <= pY) && (pixelCutoutMaxY >= pY)) {
(0163) #endif
(0164) 
(0165) 														// increase write pointer
(0166)     eventBufferWritePointer = ((eventBufferWritePointer+1) & DVS_EVENTBUFFER_MASK);
    4000032C E59F4878	LDR	R4,[PC,#0x878]
    40000330 E59F5878	LDR	R5,[PC,#0x878]
    40000334 E5946000	LDR	R6,[R4,#0]
    40000338 E2866001	ADD	R6,R6,#1
    4000033C E0065005	AND	R5,R6,R5
    40000340 E5845000	STR	R5,[R4,#0]
(0167)     eventBufferA[eventBufferWritePointer] = newDVSEvent;   	 	// store event
    40000344 E59F4860	LDR	R4,[PC,#0x860]
    40000348 E5944000	LDR	R4,[R4,#0]
    4000034C E3A05002	MOV	R5,#2
    40000350 E0040495	MUL	R4,R5,R4
    40000354 E59F5858	LDR	R5,[PC,#0x858]
    40000358 E1A06008	MOV	R6,R8
    4000035C E18460B5	STRH	R6,[R4,R5]
(0168)     eventBufferT[eventBufferWritePointer] = newDVSEventTime;	// store event time
    40000360 E59F4844	LDR	R4,[PC,#0x844]
    40000364 E5944000	LDR	R4,[R4,#0]
    40000368 E3A05004	MOV	R5,#4
    4000036C E0040495	MUL	R4,R5,R4
    40000370 E59F5840	LDR	R5,[PC,#0x840]
    40000374 E7849005	STR	R9,[R4,R5]
(0169) 
(0170) 	
(0171)     if (eventBufferWritePointer == eventBufferReadPointer) {
    40000378 E59F483C	LDR	R4,[PC,#0x83C]
    4000037C E5944000	LDR	R4,[R4,#0]
    40000380 E59F5824	LDR	R5,[PC,#0x824]
    40000384 E5955000	LDR	R5,[R5,#0]
    40000388 E1550004	CMP	R5,R4
    4000038C 1A000007	BNE	400003B0
(0172)       eventBufferReadPointer = ((eventBufferReadPointer+1) & DVS_EVENTBUFFER_MASK);
    40000390 E59F4824	LDR	R4,[PC,#0x824]
    40000394 E59F5814	LDR	R5,[PC,#0x814]
    40000398 E5946000	LDR	R6,[R4,#0]
    4000039C E2866001	ADD	R6,R6,#1
    400003A0 E0065005	AND	R5,R6,R5
    400003A4 E5845000	STR	R5,[R4,#0]
(0173) 
(0174)       LEDSetState(1000);	   							// indicate buffer overflow by LED (will turn out after some 10th of seconds)
    400003A8 E3A00FFA	MOV	R0,#0x3E8
    400003AC EB0033FD	BL	ramfunc_to_arm_branch_veneer__LEDSetState
(0175) 
(0176) #ifdef INCLUDE_MARK_BUFFEROVERFLOW
(0177)       eventBufferA[eventBufferWritePointer] |= OVERFLOW_BIT; // high bit set denotes buffer overflow
(0178) #endif
(0179)     }
(0180) 
(0181) #ifdef INCLUDE_TRACK_HF_LED
(0182)     {
(0183) 
(0184) #ifndef INCLUDE_PIXEL_CUTOUT_REGION
(0185) 	  unsigned long pX = ((newDVSEvent>>8) & 0x7F);	  		// if not yet computed, do here
(0186) 	  unsigned long pY = ((newDVSEvent)    & 0x7F);
(0187) #endif
(0188) 	  unsigned long pP = ((newDVSEvent>>7) & 0x01);			// extract polarity
(0189) 	  unsigned long newDVSEventTimeUS;
(0190) 	  signed long eventTimeDiff, targetTimeDiff;
(0191) 	  signed long factorOld, factorNew;
(0192) 	  signed long dX, dY, dXY;
(0193) 	  long n;
(0194) 
(0195) 	  newDVSEventTimeUS = (newDVSEventTime>>TIMESTAMP_SHIFTBITS);	    // keep "requested" part of timestamp
(0196) 	  newDVSEventTimeUS &= 0xFFFF;
(0197) 
(0198) 	  if (pP==0) {	  						  					   		// consider only "on"-events
(0199) 	    eventTimeDiff = newDVSEventTimeUS - tsMemory[pX][pY];			// compute time difference between consecutive on events
(0200) 		if (eventTimeDiff < 0) eventTimeDiff += BIT(16);				// in case of overrun -> fix
(0201) 	    tsMemory[pX][pY] = ((unsigned short) newDVSEventTimeUS);		// remember current time
(0202) 
(0203) 		pX = pX<<8;
(0204) 		pY = pY<<8;
(0205) 
(0206) 		for (n=0; n<4; n++) {
(0207) 		  targetTimeDiff = trackingHFLDesiredTimeDiff[n]-eventTimeDiff; 	// compute time Difference to target Frequency -> [-x ... +x]
(0208) 		  if (targetTimeDiff<0) targetTimeDiff=-targetTimeDiff;				// change to absolute difference -> [0 ... +x]
(0209) 
(0210) 		  if (targetTimeDiff<32) {											// too far away? ignore this event!
(0211) 		    targetTimeDiff = targetTimeDiff*targetTimeDiff;					// square timeDiff to penalize larger distances -> [0 ... 4096]
(0212) 
(0213) 			dX = ((((signed long) trackingHFLCenterX[n]) - ((signed long) pX))>>8); if (dX<0) dX=-dX;		// compute spatial distance between new and old pixel
(0214) 			dY = ((((signed long) trackingHFLCenterY[n]) - ((signed long) pY))>>8); if (dY<0) dY=-dY;
(0215) 
(0216) 			dX = dX*dX*dX;
(0217) 			dY = dY*dY*dY;
(0218) 			dXY = dX + dY;
(0219) 
(0220) //#define MAX_DIFF (52*64)
(0221) #define MAX_DIFF (8*64)
(0222) 			if (dXY>MAX_DIFF) dXY=MAX_DIFF;
(0223) 			
(0224) 			factorNew = (4*64*64) - targetTimeDiff - dXY;	   			  	// contribution of "new" position [0..4096]
(0225) 			if (factorNew<0) factorNew=0;
(0226) 
(0227) 		    factorOld =   65536 - factorNew;								// contribution of "old" position
(0228) 
(0229) 		    trackingHFLCenterX[n] = ((factorOld * trackingHFLCenterX[n]) + (factorNew * pX)) >> 16;		// update estimate of source
(0230) 		    trackingHFLCenterY[n] = ((factorOld * trackingHFLCenterY[n]) + (factorNew * pY)) >> 16;		// update estimate of source
(0231) 
(0232) 		    trackingHFLCenterC[n] = (((65536-(64)) * trackingHFLCenterC[n]) + (64* (16*factorNew))) >> 16;	// update certainty [0..65536]
(0233) 		  }
(0234) 		}
(0235)       }
(0236) 
(0237)     }
(0238) #endif
(0239) 
(0240)     eventCounterTotal++;
    400003B0 E59F4808	LDR	R4,[PC,#0x808]
    400003B4 E5945000	LDR	R5,[R4,#0]
    400003B8 E2855001	ADD	R5,R5,#1
    400003BC E5845000	STR	R5,[R4,#0]
(0241)     if (newDVSEvent & MEM_ADDR_P) {
    400003C0 E3180080	TST	R8,#0x80
    400003C4 0A000004	BEQ	400003DC
(0242)       eventCounterOff++;
    400003C8 E59F47F4	LDR	R4,[PC,#0x7F4]
    400003CC E5945000	LDR	R5,[R4,#0]
    400003D0 E2855001	ADD	R5,R5,#1
    400003D4 E5845000	STR	R5,[R4,#0]
(0243)     } else {
    400003D8 EA000003	B	400003EC
(0244)       eventCounterOn++;
    400003DC E59F47E4	LDR	R4,[PC,#0x7E4]
    400003E0 E5945000	LDR	R5,[R4,#0]
    400003E4 E2855001	ADD	R5,R5,#1
    400003E8 E5845000	STR	R5,[R4,#0]
(0245)     }
(0246) #ifdef INCLUDE_PIXEL_CUTOUT_REGION
(0247)     }
(0248)   }
(0249) #endif
(0250)   }
(0251) 
(0252) 
(0253) 
(0254) // *****************************************************************************
(0255) // *****************************************************************************
(0256)   currentTimerValue = T0_TC;
    400003EC E59F47D8	LDR	R4,[PC,#0x7D8]
    400003F0 E5944000	LDR	R4,[R4,#0]
    400003F4 E59F57D4	LDR	R5,[PC,#0x7D4]
    400003F8 E5854000	STR	R4,[R5,#0]
(0257) 
(0258) // *****************************************************************************
(0259) //    stuff to do every 1ms
(0260) // *****************************************************************************
(0261)   if (currentTimerValue >= nextTimer1msValue) {
    400003FC E59F47D0	LDR	R4,[PC,#0x7D0]
    40000400 E5944000	LDR	R4,[R4,#0]
    40000404 E59F57C4	LDR	R5,[PC,#0x7C4]
    40000408 E5955000	LDR	R5,[R5,#0]
    4000040C E1550004	CMP	R5,R4
    40000410 3A000076	BCC	400005F0
(0262)     nextTimer1msValue += 1; 				      // start the next 1ms interval
    40000414 E59F47B8	LDR	R4,[PC,#0x7B8]
    40000418 E5945000	LDR	R5,[R4,#0]
    4000041C E2855001	ADD	R5,R5,#1
    40000420 E5845000	STR	R5,[R4,#0]
(0263) 
(0264) #ifdef INCLUDE_TRACK_HF_LED
(0265) 	{
(0266) 	  long n;
(0267)       for (n=0; n<4; n++) {
(0268) 		trackingHFLCenterC[n] = (((65536-(64*64)) * trackingHFLCenterC[n]) + (0)) >> 16;  	  	 	// decay certainty
(0269)       }
(0270) 	}
(0271) #endif
(0272) 
(0273) #ifdef INCLUDE_TRACK_HF_LED
(0274)   #ifdef INCLUDE_TRACK_HF_LED_SERVO_OUT
(0275) 
(0276)     if (EP_TrackHFP_ServoEnabled) {
(0277) 
(0278)       if ((trackingHFLCenterC[2]) > 512) {
(0279) 		TrackHFL_PWM0 -= ( (((signed long) (trackingHFLCenterX[2])) - ((signed long) (16384+500)) ) >> 10);
(0280) 		TrackHFL_PWM1 -= ( (((signed long) (trackingHFLCenterY[2])) - ((signed long) (16384-1000)) ) >> 10);
(0281) 
(0282)     #ifdef INCLUDE_TRACK_HF_LED_LASERPOINTER
(0283)         FGPIO_IOCLR  = PIN_TRACK_HFL_LASER;		// low -> laser on
(0284)     #endif
(0285) 
(0286)       } else {
(0287) 
(0288) 	    signed long error;
(0289) 		error = (((signed long) 6000)-((signed long) TrackHFL_PWM0));
(0290) 		if (error > 0) TrackHFL_PWM0++;
(0291) 		if (error < 0) TrackHFL_PWM0--;
(0292) 
(0293) 		error = (((signed long) 5200)-((signed long) TrackHFL_PWM1));
(0294) 		if (error > 0) TrackHFL_PWM1++;
(0295) 		if (error < 0) TrackHFL_PWM1--;
(0296) 
(0297)     #ifdef INCLUDE_TRACK_HF_LED_LASERPOINTER
(0298)         FGPIO_IOSET  = PIN_TRACK_HFL_LASER;		// high -> laser off
(0299)     #endif
(0300)       }
(0301) 
(0302)       // limit max and min values
(0303) #define SERVO_CENTER 6000
(0304) #define SERVO_DELTA  2500
(0305) 
(0306)       if (TrackHFL_PWM0 < (SERVO_CENTER-SERVO_DELTA)) TrackHFL_PWM0 = (SERVO_CENTER-SERVO_DELTA);
(0307)       if (TrackHFL_PWM1 < (SERVO_CENTER-SERVO_DELTA)) TrackHFL_PWM1 = (SERVO_CENTER-SERVO_DELTA);
(0308) 
(0309)       if (TrackHFL_PWM0 > (SERVO_CENTER+SERVO_DELTA)) TrackHFL_PWM0 = (SERVO_CENTER+SERVO_DELTA);
(0310)       if (TrackHFL_PWM1 > (SERVO_CENTER+SERVO_DELTA)) TrackHFL_PWM1 = (SERVO_CENTER+SERVO_DELTA);
(0311) 
(0312) //      PWM246SetSignal(1, TrackHFL_PWM1);
(0313) //      PWM246SetSignal(2, TrackHFL_PWM0);
(0314)       PWM_MR4 = TrackHFL_PWM1;		// update PWM4
(0315)       PWM_MR6 = TrackHFL_PWM0;		// update PWM6
(0316)       PWM_LER = BIT(4) | BIT(6);	// allow changes of MR4 and MR6 on next counter reset
(0317)     }
(0318)   #endif
(0319) #endif
(0320) 
(0321) //}  // end of 1ms
(0322) 
(0323) 
(0324) // *****************************************************************************
(0325) //    stuff to do every 2ms
(0326) // *****************************************************************************
(0327)   if (currentTimerValue >= nextTimer2msValue) {
    40000424 E59F47AC	LDR	R4,[PC,#0x7AC]
    40000428 E5944000	LDR	R4,[R4,#0]
    4000042C E59F579C	LDR	R5,[PC,#0x79C]
    40000430 E5955000	LDR	R5,[R5,#0]
    40000434 E1550004	CMP	R5,R4
    40000438 3A00006C	BCC	400005F0
(0328)     nextTimer2msValue += 2; 				      // start the next 2ms interval
    4000043C E59F4794	LDR	R4,[PC,#0x794]
    40000440 E5945000	LDR	R5,[R4,#0]
    40000444 E2855002	ADD	R5,R5,#2
    40000448 E5845000	STR	R5,[R4,#0]
(0329) //  }  // end of 2ms
(0330) 
(0331) 
(0332) // *****************************************************************************
(0333) //    stuff to do every 10ms
(0334) // *****************************************************************************
(0335)   if (currentTimerValue >= nextTimer10msValue) {
    4000044C E59F4788	LDR	R4,[PC,#0x788]
    40000450 E5944000	LDR	R4,[R4,#0]
    40000454 E59F5774	LDR	R5,[PC,#0x774]
    40000458 E5955000	LDR	R5,[R5,#0]
    4000045C E1550004	CMP	R5,R4
    40000460 3A000062	BCC	400005F0
(0336)     nextTimer10msValue += 10; 				 	 // start the next 10ms interval
    40000464 E59F4770	LDR	R4,[PC,#0x770]
    40000468 E5945000	LDR	R5,[R4,#0]
    4000046C E285500A	ADD	R5,R5,#10
    40000470 E5845000	STR	R5,[R4,#0]
(0337) 
(0338) // ** report tracked object position
(0339) #ifdef INCLUDE_TRACK_HF_LED
(0340)     if (transmitTrackHFLED) {
(0341) 	  dataForTransmission[ 0] = (trackingHFLCenterX[0]) >> 8;
(0342) 	  dataForTransmission[ 1] = (trackingHFLCenterY[0]) >> 8;
(0343) 	  dataForTransmission[ 2] = ((trackingHFLCenterC[0]) >> 8) & 0xFF;		// [0..255]
(0344) 
(0345) 	  dataForTransmission[ 3] = (trackingHFLCenterX[1]) >> 8;
(0346) 	  dataForTransmission[ 4] = (trackingHFLCenterY[1]) >> 8;
(0347) 	  dataForTransmission[ 5] = ((trackingHFLCenterC[1]) >> 8) & 0xFF;		// [0..255]
(0348) 
(0349) 	  dataForTransmission[ 6] = (trackingHFLCenterX[2]) >> 8;
(0350) 	  dataForTransmission[ 7] = (trackingHFLCenterY[2]) >> 8;
(0351) 	  dataForTransmission[ 8] = ((trackingHFLCenterC[2]) >> 8) & 0xFF;		// [0..255]
(0352) 
(0353) 	  dataForTransmission[ 9] = (trackingHFLCenterX[3]) >> 8;
(0354) 	  dataForTransmission[10] = (trackingHFLCenterY[3]) >> 8;
(0355) 	  dataForTransmission[11] = ((trackingHFLCenterC[3]) >> 8) & 0xFF;		// [0..255]
(0356) 
(0357) 	  transmitSpecialData(12);
(0358)     }
(0359) #endif
(0360) 
(0361) //  }  // end of 10ms
(0362) 
(0363) 
(0364) // *****************************************************************************
(0365) //    stuff to do every 100ms
(0366) // *****************************************************************************
(0367)   if (currentTimerValue >= nextTimer100msValue) {
    40000474 E59F4764	LDR	R4,[PC,#0x764]
    40000478 E5944000	LDR	R4,[R4,#0]
    4000047C E59F574C	LDR	R5,[PC,#0x74C]
    40000480 E5955000	LDR	R5,[R5,#0]
    40000484 E1550004	CMP	R5,R4
    40000488 3A000058	BCC	400005F0
(0368)     nextTimer100msValue += 100; 				// start the next 100ms interval
    4000048C E59F474C	LDR	R4,[PC,#0x74C]
    40000490 E5945000	LDR	R5,[R4,#0]
    40000494 E2855064	ADD	R5,R5,#0x64
    40000498 E5845000	STR	R5,[R4,#0]
(0369) 
(0370) 					   	  					   // ** report counted events
(0371)     if (transmitEventRateEnable) {
    4000049C E59F4740	LDR	R4,[PC,#0x740]
    400004A0 E5944000	LDR	R4,[R4,#0]
    400004A4 E3540000	CMP	R4,#0
    400004A8 0A00003D	BEQ	400005A4
(0372) 	  dataForTransmission[0] = ((((unsigned long) eventCounterOff  )    ) & 0x3F) + 32;
    400004AC E59F4710	LDR	R4,[PC,#0x710]
    400004B0 E5944000	LDR	R4,[R4,#0]
    400004B4 E204403F	AND	R4,R4,#0x3F
    400004B8 E2844020	ADD	R4,R4,#0x20
    400004BC E59F5724	LDR	R5,[PC,#0x724]
    400004C0 E5C54000	STRB	R4,[R5,#0]
(0373) 	  dataForTransmission[1] = ((((unsigned long) eventCounterOff  )>> 6) & 0x3F) + 32;
    400004C4 E59F46F8	LDR	R4,[PC,#0x6F8]
    400004C8 E5944000	LDR	R4,[R4,#0]
    400004CC E1A04324	MOV	R4,R4,LSR #6
    400004D0 E204403F	AND	R4,R4,#0x3F
    400004D4 E2844020	ADD	R4,R4,#0x20
    400004D8 E59F570C	LDR	R5,[PC,#0x70C]
    400004DC E5C54000	STRB	R4,[R5,#0]
(0374) 	  dataForTransmission[2] = ((((unsigned long) eventCounterOff  )>>12) & 0x3F) + 32;
    400004E0 E59F46DC	LDR	R4,[PC,#0x6DC]
    400004E4 E5944000	LDR	R4,[R4,#0]
    400004E8 E1A04624	MOV	R4,R4,LSR #12
    400004EC E204403F	AND	R4,R4,#0x3F
    400004F0 E2844020	ADD	R4,R4,#0x20
    400004F4 E59F56F4	LDR	R5,[PC,#0x6F4]
    400004F8 E5C54000	STRB	R4,[R5,#0]
(0375) 	  dataForTransmission[3] = ((((unsigned long) eventCounterOn   )    ) & 0x3F) + 32;
    400004FC E59F46C4	LDR	R4,[PC,#0x6C4]
    40000500 E5944000	LDR	R4,[R4,#0]
    40000504 E204403F	AND	R4,R4,#0x3F
    40000508 E2844020	ADD	R4,R4,#0x20
    4000050C E59F56E0	LDR	R5,[PC,#0x6E0]
    40000510 E5C54000	STRB	R4,[R5,#0]
(0376) 	  dataForTransmission[4] = ((((unsigned long) eventCounterOn   )>> 6) & 0x3F) + 32;
    40000514 E59F46AC	LDR	R4,[PC,#0x6AC]
    40000518 E5944000	LDR	R4,[R4,#0]
    4000051C E1A04324	MOV	R4,R4,LSR #6
    40000520 E204403F	AND	R4,R4,#0x3F
    40000524 E2844020	ADD	R4,R4,#0x20
    40000528 E59F56C8	LDR	R5,[PC,#0x6C8]
    4000052C E5C54000	STRB	R4,[R5,#0]
(0377) 	  dataForTransmission[5] = ((((unsigned long) eventCounterOn   )>>12) & 0x3F) + 32;
    40000530 E59F4690	LDR	R4,[PC,#0x690]
    40000534 E5944000	LDR	R4,[R4,#0]
    40000538 E1A04624	MOV	R4,R4,LSR #12
    4000053C E204403F	AND	R4,R4,#0x3F
    40000540 E2844020	ADD	R4,R4,#0x20
    40000544 E59F56B0	LDR	R5,[PC,#0x6B0]
    40000548 E5C54000	STRB	R4,[R5,#0]
(0378) 	  dataForTransmission[6] = ((((unsigned long) eventCounterTotal)    ) & 0x3F) + 32;
    4000054C E59F466C	LDR	R4,[PC,#0x66C]
    40000550 E5944000	LDR	R4,[R4,#0]
    40000554 E204403F	AND	R4,R4,#0x3F
    40000558 E2844020	ADD	R4,R4,#0x20
    4000055C E59F569C	LDR	R5,[PC,#0x69C]
    40000560 E5C54000	STRB	R4,[R5,#0]
(0379) 	  dataForTransmission[7] = ((((unsigned long) eventCounterTotal)>> 6) & 0x3F) + 32;
    40000564 E59F4654	LDR	R4,[PC,#0x654]
    40000568 E5944000	LDR	R4,[R4,#0]
    4000056C E1A04324	MOV	R4,R4,LSR #6
    40000570 E204403F	AND	R4,R4,#0x3F
    40000574 E2844020	ADD	R4,R4,#0x20
    40000578 E59F5684	LDR	R5,[PC,#0x684]
    4000057C E5C54000	STRB	R4,[R5,#0]
(0380) 	  dataForTransmission[8] = ((((unsigned long) eventCounterTotal)>>12) & 0x3F) + 32;
    40000580 E59F4638	LDR	R4,[PC,#0x638]
    40000584 E5944000	LDR	R4,[R4,#0]
    40000588 E1A04624	MOV	R4,R4,LSR #12
    4000058C E204403F	AND	R4,R4,#0x3F
    40000590 E2844020	ADD	R4,R4,#0x20
    40000594 E59F566C	LDR	R5,[PC,#0x66C]
    40000598 E5C54000	STRB	R4,[R5,#0]
(0381) 	  transmitSpecialData(9);
    4000059C E3A00009	MOV	R0,#9
    400005A0 EBFFFE97	BL	_transmitSpecialData
(0382)     }
(0383)     eventCounterTotal = 0;
    400005A4 E3A04000	MOV	R4,#0
    400005A8 E59F5610	LDR	R5,[PC,#0x610]
    400005AC E5854000	STR	R4,[R5,#0]
(0384)     eventCounterOn    = 0;
    400005B0 E3A04000	MOV	R4,#0
    400005B4 E59F560C	LDR	R5,[PC,#0x60C]
    400005B8 E5854000	STR	R4,[R5,#0]
(0385)     eventCounterOff   = 0;
    400005BC E3A04000	MOV	R4,#0
    400005C0 E59F55FC	LDR	R5,[PC,#0x5FC]
    400005C4 E5854000	STR	R4,[R5,#0]
(0386) 
(0387) //  }  // end of 100ms
(0388) 
(0389) 
(0390) // *****************************************************************************
(0391) //    stuff to do every 1000ms
(0392) // *****************************************************************************
(0393)   if (currentTimerValue >= nextTimer1000msValue) {
    400005C8 E59F463C	LDR	R4,[PC,#0x63C]
    400005CC E5944000	LDR	R4,[R4,#0]
    400005D0 E59F55F8	LDR	R5,[PC,#0x5F8]
    400005D4 E5955000	LDR	R5,[R5,#0]
    400005D8 E1550004	CMP	R5,R4
    400005DC 3A000003	BCC	400005F0
(0394)     nextTimer1000msValue += 1000; 			   // start the next 1000ms interval
    400005E0 E59F4624	LDR	R4,[PC,#0x624]
    400005E4 E5945000	LDR	R5,[R4,#0]
    400005E8 E2855FFA	ADD	R5,R5,#0x3E8
    400005EC E5845000	STR	R5,[R4,#0]
(0395) 
(0396)   }  // end of 1000ms
(0397)   }  // end of  100ms
(0398)   }  // end of   10ms
(0399)   }  // end of    2ms
(0400)   }  // end of    1ms
(0401) 
(0402) 
(0403) // *****************************************************************************
(0404) //    stuff left to send?
(0405) // *****************************************************************************
(0406) MainLoopSendEvents:
(0407)   if ((FGPIO_IOPIN & PIN_UART0_RTS) !=0 ) {			// no rts stop signal
    400005F0 E59F4618	LDR	R4,[PC,#0x618]
    400005F4 E5944000	LDR	R4,[R4,#0]
    400005F8 E3140F40	TST	R4,#0x100
    400005FC 0A00000A	BEQ	4000062C
(0408) 	goto MLProcessEvents;
    40000600 EA000011	B	4000064C
(0409)   }
(0410) 
(0411)   while ((TXBufferIndex) && (UART0_LSR & BIT(5))) {
(0412)     TXBufferIndex--;
    40000604 E59F4608	LDR	R4,[PC,#0x608]
    40000608 E5945000	LDR	R5,[R4,#0]
    4000060C E2455001	SUB	R5,R5,#1
    40000610 E5845000	STR	R5,[R4,#0]
(0413)     UART0_THR = TXBuffer[TXBufferIndex];
    40000614 E59F45FC	LDR	R4,[PC,#0x5FC]
    40000618 E59F55F4	LDR	R5,[PC,#0x5F4]
    4000061C E5955000	LDR	R5,[R5,#0]
    40000620 E7D54004	LDRB	R4,[R5,R4]
    40000624 E59F55F0	LDR	R5,[PC,#0x5F0]
    40000628 E5854000	STR	R4,[R5,#0]
    4000062C E59F45E0	LDR	R4,[PC,#0x5E0]
    40000630 E5944000	LDR	R4,[R4,#0]
    40000634 E3540000	CMP	R4,#0
    40000638 0A000003	BEQ	4000064C
    4000063C E59F45DC	LDR	R4,[PC,#0x5DC]
    40000640 E5944000	LDR	R4,[R4,#0]
    40000644 E3140020	TST	R4,#0x20
    40000648 1AFFFFED	BNE	40000604
(0414)   }
(0415) 
(0416) // *****************************************************************************
(0417) //    processEventsIterate();
(0418) // *****************************************************************************
(0419) MLProcessEvents:
(0420) 
(0421) // *****************************************************************************
(0422) //    fetchNewEvent();  (and process event)
(0423) // *****************************************************************************
(0424)   if (TXBufferIndex) {										// wait for TX to finish sending!
    4000064C E59F45C0	LDR	R4,[PC,#0x5C0]
    40000650 E5944000	LDR	R4,[R4,#0]
    40000654 E3540000	CMP	R4,#0
(0425)     goto MLStart;
    40000658 1AFFFECF	BNE	4000019C
(0426)   }
(0427)   if (eventBufferWritePointer == eventBufferReadPointer) {	// more events in buffer to process?
    4000065C E59F4558	LDR	R4,[PC,#0x558]
    40000660 E5944000	LDR	R4,[R4,#0]
    40000664 E59F5540	LDR	R5,[PC,#0x540]
    40000668 E5955000	LDR	R5,[R5,#0]
    4000066C E1550004	CMP	R5,R4
(0428)     goto MLStart;
    40000670 0AFFFEC9	BEQ	4000019C
(0429)   }
(0430)    		 		 			  	 						 	// fetch event
(0431)   eventBufferReadPointer = ((eventBufferReadPointer+1) & DVS_EVENTBUFFER_MASK);
    40000674 E59F4540	LDR	R4,[PC,#0x540]
    40000678 E59F5530	LDR	R5,[PC,#0x530]
    4000067C E5946000	LDR	R6,[R4,#0]
    40000680 E2866001	ADD	R6,R6,#1
    40000684 E0065005	AND	R5,R6,R5
    40000688 E5845000	STR	R5,[R4,#0]
(0432)   eventA = eventBufferA[eventBufferReadPointer];
    4000068C E59F4528	LDR	R4,[PC,#0x528]
    40000690 E5944000	LDR	R4,[R4,#0]
    40000694 E3A05002	MOV	R5,#2
    40000698 E0040495	MUL	R4,R5,R4
    4000069C E59F5510	LDR	R5,[PC,#0x510]
    400006A0 E19440B5	LDRH	R4,[R4,R5]
    400006A4 E1A09004	MOV	R9,R4
(0433)   eventT = eventBufferT[eventBufferReadPointer];
    400006A8 E59F450C	LDR	R4,[PC,#0x50C]
    400006AC E5944000	LDR	R4,[R4,#0]
    400006B0 E3A05004	MOV	R5,#4
    400006B4 E0040495	MUL	R4,R5,R4
    400006B8 E59F54F8	LDR	R5,[PC,#0x4F8]
    400006BC E7948005	LDR	R8,[R4,R5]
(0434) 
(0435)   if (enableEventSending) {
    400006C0 E59F455C	LDR	R4,[PC,#0x55C]
    400006C4 E5944000	LDR	R4,[R4,#0]
    400006C8 E3540000	CMP	R4,#0
    400006CC 0AFFFEB2	BEQ	4000019C
(0436)     switch (eDVSDataFormat) {
    400006D0 E59F4550	LDR	R4,[PC,#0x550]
    400006D4 E5944000	LDR	R4,[R4,#0]
    400006D8 E3540003	CMP	R4,#3
    400006DC CA000004	BGT	400006F4
    400006E0 E3A05004	MOV	R5,#4
    400006E4 E0040495	MUL	R4,R5,R4
    400006E8 E59F553C	LDR	R5,[PC,#0x53C]
    400006EC E7944005	LDR	R4,[R4,R5]
    400006F0 E1A0F004	MOV	PC,R4
    400006F4 E59F452C	LDR	R4,[PC,#0x52C]
    400006F8 E5944000	LDR	R4,[R4,#0]
    400006FC E3540014	CMP	R4,#20
    40000700 BAFFFEA5	BLT	4000019C
    40000704 E3540020	CMP	R4,#0x20
    40000708 CAFFFEA3	BGT	4000019C
    4000070C E3A05004	MOV	R5,#4
    40000710 E0040495	MUL	R4,R5,R4
    40000714 E59F5514	LDR	R5,[PC,#0x514]
    40000718 E7944005	LDR	R4,[R4,R5]
    4000071C E1A0F004	MOV	PC,R4
(0437) 
(0438) 	case EDVS_DATA_FORMAT_BIN:
(0439)       TXBuffer[1] = ((eventA>>8) & 0xFF);				  // 1st byte to send (Y-address)
    40000720 E1A04429	MOV	R4,R9,LSR #8
    40000724 E20440FF	AND	R4,R4,#0xFF
    40000728 E59F5504	LDR	R5,[PC,#0x504]
    4000072C E5C54000	STRB	R4,[R5,#0]
(0440)       TXBuffer[0] = ((eventA)    & 0xFF);				  // 2nd byte to send (X-address)
    40000730 E20940FF	AND	R4,R9,#0xFF
    40000734 E59F54DC	LDR	R5,[PC,#0x4DC]
    40000738 E5C54000	STRB	R4,[R5,#0]
(0441)       TXBufferIndex = 2; break;
    4000073C E3A04002	MOV	R4,#2
    40000740 E59F54CC	LDR	R5,[PC,#0x4CC]
    40000744 E5854000	STR	R4,[R5,#0]
    40000748 EAFFFE93	B	4000019C
(0442) 
(0443)     case EDVS_DATA_FORMAT_BIN_TS2B:
(0444)       TXBuffer[3] = ((eventA>>8) & 0xFF);				  // 1st byte to send (Y-address)
    4000074C E1A04429	MOV	R4,R9,LSR #8
    40000750 E20440FF	AND	R4,R4,#0xFF
    40000754 E59F54DC	LDR	R5,[PC,#0x4DC]
    40000758 E5C54000	STRB	R4,[R5,#0]
(0445)       TXBuffer[2] = ((eventA)    & 0xFF);				  // 2nd byte to send (X-address)
    4000075C E20940FF	AND	R4,R9,#0xFF
    40000760 E59F54D4	LDR	R5,[PC,#0x4D4]
    40000764 E5C54000	STRB	R4,[R5,#0]
(0446)       TXBuffer[1] = ((eventT>> (TIMESTAMP_SHIFTBITS+8)) & 0xFF);	// 3rd byte to send (time stamp high byte)
    40000768 E1A04728	MOV	R4,R8,LSR #14
    4000076C E20440FF	AND	R4,R4,#0xFF
    40000770 E59F54BC	LDR	R5,[PC,#0x4BC]
    40000774 E5C54000	STRB	R4,[R5,#0]
(0447)       TXBuffer[0] = ((eventT>> (TIMESTAMP_SHIFTBITS)  ) & 0xFF);	// 4th byte to send (time stamp low byte)
    40000778 E1A04328	MOV	R4,R8,LSR #6
    4000077C E20440FF	AND	R4,R4,#0xFF
    40000780 E59F5490	LDR	R5,[PC,#0x490]
    40000784 E5C54000	STRB	R4,[R5,#0]
(0448)       TXBufferIndex = 4; break;
    40000788 E3A04004	MOV	R4,#4
    4000078C E59F5480	LDR	R5,[PC,#0x480]
    40000790 E5854000	STR	R4,[R5,#0]
    40000794 EAFFFE80	B	4000019C
(0449) 
(0450)     case EDVS_DATA_FORMAT_BIN_TS3B:
(0451)       TXBuffer[4] = ((eventA>>8) & 0xFF);				  // 1st byte to send (Y-address)
    40000798 E1A04429	MOV	R4,R9,LSR #8
    4000079C E20440FF	AND	R4,R4,#0xFF
    400007A0 E59F5498	LDR	R5,[PC,#0x498]
    400007A4 E5C54000	STRB	R4,[R5,#0]
(0452)       TXBuffer[3] = ((eventA)    & 0xFF);				  // 2nd byte to send (X-address)
    400007A8 E20940FF	AND	R4,R9,#0xFF
    400007AC E59F5484	LDR	R5,[PC,#0x484]
    400007B0 E5C54000	STRB	R4,[R5,#0]
(0453)       TXBuffer[2] = ((eventT>> (TIMESTAMP_SHIFTBITS+16)) & 0xFF);	// 3rd byte to send (time stamp high byte)
    400007B4 E1A04B28	MOV	R4,R8,LSR #22
    400007B8 E20440FF	AND	R4,R4,#0xFF
    400007BC E59F5478	LDR	R5,[PC,#0x478]
    400007C0 E5C54000	STRB	R4,[R5,#0]
(0454)       TXBuffer[1] = ((eventT>> (TIMESTAMP_SHIFTBITS+ 8)) & 0xFF);	// 4th byte to send (time stamp)
    400007C4 E1A04728	MOV	R4,R8,LSR #14
    400007C8 E20440FF	AND	R4,R4,#0xFF
    400007CC E59F5460	LDR	R5,[PC,#0x460]
    400007D0 E5C54000	STRB	R4,[R5,#0]
(0455)       TXBuffer[0] = ((eventT>> (TIMESTAMP_SHIFTBITS)   ) & 0xFF);	// 5th byte to send (time stamp low byte)
    400007D4 E1A04328	MOV	R4,R8,LSR #6
    400007D8 E20440FF	AND	R4,R4,#0xFF
    400007DC E59F5434	LDR	R5,[PC,#0x434]
    400007E0 E5C54000	STRB	R4,[R5,#0]
(0456)       TXBufferIndex = 5; break;
    400007E4 E3A04005	MOV	R4,#5
    400007E8 E59F5424	LDR	R5,[PC,#0x424]
    400007EC E5854000	STR	R4,[R5,#0]
    400007F0 EAFFFE69	B	4000019C
(0457) 
(0458)     case EDVS_DATA_FORMAT_BIN_TS4B:
(0459)       TXBuffer[5] = ((eventA>> ( 8)) & 0xFF);			  // 1st byte to send (Y-address)
    400007F4 E1A04429	MOV	R4,R9,LSR #8
    400007F8 E20440FF	AND	R4,R4,#0xFF
    400007FC E59F5440	LDR	R5,[PC,#0x440]
    40000800 E5C54000	STRB	R4,[R5,#0]
(0460)       TXBuffer[4] = ((eventA)        & 0xFF);			  // 2nd byte to send (X-address)
    40000804 E20940FF	AND	R4,R9,#0xFF
    40000808 E59F5430	LDR	R5,[PC,#0x430]
    4000080C E5C54000	STRB	R4,[R5,#0]
(0461)       TXBuffer[3] = ((eventT>> (24)) & 0xFF);			  // 3rd byte to send (time stamp high byte)
    40000810 E1A04C28	MOV	R4,R8,LSR #24
    40000814 E20440FF	AND	R4,R4,#0xFF
    40000818 E59F5418	LDR	R5,[PC,#0x418]
    4000081C E5C54000	STRB	R4,[R5,#0]
(0462)       TXBuffer[2] = ((eventT>> (16)) & 0xFF);			  // 4th byte to send (time stamp)
    40000820 E1A04828	MOV	R4,R8,LSR #16
    40000824 E20440FF	AND	R4,R4,#0xFF
    40000828 E59F540C	LDR	R5,[PC,#0x40C]
    4000082C E5C54000	STRB	R4,[R5,#0]
(0463)       TXBuffer[1] = ((eventT>> ( 8)) & 0xFF);			  // 5th byte to send (time stamp)
    40000830 E1A04428	MOV	R4,R8,LSR #8
    40000834 E20440FF	AND	R4,R4,#0xFF
    40000838 E59F53F4	LDR	R5,[PC,#0x3F4]
    4000083C E5C54000	STRB	R4,[R5,#0]
(0464)       TXBuffer[0] = ((eventT       ) & 0xFF);			  // 6th byte to send (time stamp low byte)
    40000840 E20840FF	AND	R4,R8,#0xFF
    40000844 E59F53CC	LDR	R5,[PC,#0x3CC]
    40000848 E5C54000	STRB	R4,[R5,#0]
(0465)       TXBufferIndex = 6; break;
    4000084C E3A04006	MOV	R4,#6
    40000850 E59F53BC	LDR	R5,[PC,#0x3BC]
    40000854 E5854000	STR	R4,[R5,#0]
    40000858 EAFFFE4F	B	4000019C
(0466) 
(0467)     case EDVS_DATA_FORMAT_HEX:
(0468)       TXBuffer[3] = hexLookupTable[((eventA>>12) & 0x0F)]; // 1st byte to send
    4000085C E59F43E4	LDR	R4,[PC,#0x3E4]
    40000860 E1A05629	MOV	R5,R9,LSR #12
    40000864 E205500F	AND	R5,R5,#15
    40000868 E7D54004	LDRB	R4,[R5,R4]
    4000086C E59F53C4	LDR	R5,[PC,#0x3C4]
    40000870 E5C54000	STRB	R4,[R5,#0]
(0469)       TXBuffer[2] = hexLookupTable[((eventA>> 8) & 0x0F)]; // 2nd byte to send
    40000874 E59F43CC	LDR	R4,[PC,#0x3CC]
    40000878 E1A05429	MOV	R5,R9,LSR #8
    4000087C E205500F	AND	R5,R5,#15
    40000880 E7D54004	LDRB	R4,[R5,R4]
    40000884 E59F53B0	LDR	R5,[PC,#0x3B0]
    40000888 E5C54000	STRB	R4,[R5,#0]
(0470)       TXBuffer[1] = hexLookupTable[((eventA>> 4) & 0x0F)]; // 3rd byte to send
    4000088C E59F43B4	LDR	R4,[PC,#0x3B4]
    40000890 E1A05229	MOV	R5,R9,LSR #4
    40000894 E205500F	AND	R5,R5,#15
    40000898 E7D54004	LDRB	R4,[R5,R4]
    4000089C E59F5390	LDR	R5,[PC,#0x390]
    400008A0 E5C54000	STRB	R4,[R5,#0]
(0471)       TXBuffer[0] = hexLookupTable[((eventA    ) & 0x0F)]; // 4th byte to send
    400008A4 E59F439C	LDR	R4,[PC,#0x39C]
    400008A8 E209500F	AND	R5,R9,#15
    400008AC E7D54004	LDRB	R4,[R5,R4]
    400008B0 E59F5360	LDR	R5,[PC,#0x360]
    400008B4 E5C54000	STRB	R4,[R5,#0]
(0472) 	  TXBufferIndex = 4; break;
    400008B8 E3A04004	MOV	R4,#4
    400008BC E59F5350	LDR	R5,[PC,#0x350]
    400008C0 E5854000	STR	R4,[R5,#0]
    400008C4 EAFFFE34	B	4000019C
(0473) 
(0474) 	case EDVS_DATA_FORMAT_HEX_TS:
(0475)       TXBuffer[7] = hexLookupTable[((eventA>>12) & 0x0F)]; // 1st byte to send
    400008C8 E59F4378	LDR	R4,[PC,#0x378]
    400008CC E1A05629	MOV	R5,R9,LSR #12
    400008D0 E205500F	AND	R5,R5,#15
    400008D4 E7D54004	LDRB	R4,[R5,R4]
    400008D8 E59F536C	LDR	R5,[PC,#0x36C]
    400008DC E5C54000	STRB	R4,[R5,#0]
(0476)       TXBuffer[6] = hexLookupTable[((eventA>> 8) & 0x0F)]; // 2nd byte to send
    400008E0 E59F4360	LDR	R4,[PC,#0x360]
    400008E4 E1A05429	MOV	R5,R9,LSR #8
    400008E8 E205500F	AND	R5,R5,#15
    400008EC E7D54004	LDRB	R4,[R5,R4]
    400008F0 E59F5358	LDR	R5,[PC,#0x358]
    400008F4 E5C54000	STRB	R4,[R5,#0]
(0477)       TXBuffer[5] = hexLookupTable[((eventA>> 4) & 0x0F)]; // 3rd byte to send
    400008F8 E59F4348	LDR	R4,[PC,#0x348]
    400008FC E1A05229	MOV	R5,R9,LSR #4
    40000900 E205500F	AND	R5,R5,#15
    40000904 E7D54004	LDRB	R4,[R5,R4]
    40000908 E59F5334	LDR	R5,[PC,#0x334]
    4000090C E5C54000	STRB	R4,[R5,#0]
(0478)       TXBuffer[4] = hexLookupTable[((eventA    ) & 0x0F)]; // 4th byte to send
    40000910 E59F4330	LDR	R4,[PC,#0x330]
    40000914 E209500F	AND	R5,R9,#15
    40000918 E7D54004	LDRB	R4,[R5,R4]
    4000091C E59F531C	LDR	R5,[PC,#0x31C]
    40000920 E5C54000	STRB	R4,[R5,#0]
(0479)       TXBuffer[3] = hexLookupTable[((eventT>>12) & 0x0F)]; // 5th byte to send
    40000924 E59F431C	LDR	R4,[PC,#0x31C]
    40000928 E1A05628	MOV	R5,R8,LSR #12
    4000092C E205500F	AND	R5,R5,#15
    40000930 E7D54004	LDRB	R4,[R5,R4]
    40000934 E59F52FC	LDR	R5,[PC,#0x2FC]
    40000938 E5C54000	STRB	R4,[R5,#0]
(0480)       TXBuffer[2] = hexLookupTable[((eventT>> 8) & 0x0F)]; // 6th byte to send
    4000093C E59F4304	LDR	R4,[PC,#0x304]
    40000940 E1A05428	MOV	R5,R8,LSR #8
    40000944 E205500F	AND	R5,R5,#15
    40000948 E7D54004	LDRB	R4,[R5,R4]
    4000094C E59F52E8	LDR	R5,[PC,#0x2E8]
    40000950 E5C54000	STRB	R4,[R5,#0]
(0481)       TXBuffer[1] = hexLookupTable[((eventT>> 4) & 0x0F)]; // 7th byte to send
    40000954 E59F42EC	LDR	R4,[PC,#0x2EC]
    40000958 E1A05228	MOV	R5,R8,LSR #4
    4000095C E205500F	AND	R5,R5,#15
    40000960 E7D54004	LDRB	R4,[R5,R4]
    40000964 E59F52C8	LDR	R5,[PC,#0x2C8]
    40000968 E5C54000	STRB	R4,[R5,#0]
(0482)       TXBuffer[0] = hexLookupTable[((eventT)     & 0x0F)]; // 8th byte to send
    4000096C E59F42D4	LDR	R4,[PC,#0x2D4]
    40000970 E208500F	AND	R5,R8,#15
    40000974 E7D54004	LDRB	R4,[R5,R4]
    40000978 E59F5298	LDR	R5,[PC,#0x298]
    4000097C E5C54000	STRB	R4,[R5,#0]
(0483) 	  TXBufferIndex = 8; break;
    40000980 E3A04008	MOV	R4,#8
    40000984 E59F5288	LDR	R5,[PC,#0x288]
    40000988 E5854000	STR	R4,[R5,#0]
    4000098C EAFFFE02	B	4000019C
(0484) 
(0485)     case EDVS_DATA_FORMAT_HEX_RET:
(0486)       TXBuffer[4] = hexLookupTable[((eventA>>12) & 0x0F)]; // 1st byte to send
    40000990 E59F42B0	LDR	R4,[PC,#0x2B0]
    40000994 E1A05629	MOV	R5,R9,LSR #12
    40000998 E205500F	AND	R5,R5,#15
    4000099C E7D54004	LDRB	R4,[R5,R4]
    400009A0 E59F5298	LDR	R5,[PC,#0x298]
    400009A4 E5C54000	STRB	R4,[R5,#0]
(0487)       TXBuffer[3] = hexLookupTable[((eventA>> 8) & 0x0F)]; // 2nd byte to send
    400009A8 E59F4298	LDR	R4,[PC,#0x298]
    400009AC E1A05429	MOV	R5,R9,LSR #8
    400009B0 E205500F	AND	R5,R5,#15
    400009B4 E7D54004	LDRB	R4,[R5,R4]
    400009B8 E59F5278	LDR	R5,[PC,#0x278]
    400009BC E5C54000	STRB	R4,[R5,#0]
(0488)       TXBuffer[2] = hexLookupTable[((eventA>> 4) & 0x0F)]; // 3rd byte to send
    400009C0 E59F4280	LDR	R4,[PC,#0x280]
    400009C4 E1A05229	MOV	R5,R9,LSR #4
    400009C8 E205500F	AND	R5,R5,#15
    400009CC E7D54004	LDRB	R4,[R5,R4]
    400009D0 E59F5264	LDR	R5,[PC,#0x264]
    400009D4 E5C54000	STRB	R4,[R5,#0]
(0489)       TXBuffer[1] = hexLookupTable[((eventA    ) & 0x0F)]; // 4th byte to send
    400009D8 E59F4268	LDR	R4,[PC,#0x268]
    400009DC E209500F	AND	R5,R9,#15
    400009E0 E7D54004	LDRB	R4,[R5,R4]
    400009E4 E59F5248	LDR	R5,[PC,#0x248]
    400009E8 E5C54000	STRB	R4,[R5,#0]
(0490) 	  TXBuffer[0] = '\n';		   						  // return
    400009EC E3A0400A	MOV	R4,#10
    400009F0 E59F5220	LDR	R5,[PC,#0x220]
    400009F4 E5C54000	STRB	R4,[R5,#0]
(0491) 	  TXBufferIndex = 4; break;
    400009F8 E3A04004	MOV	R4,#4
    400009FC E59F5210	LDR	R5,[PC,#0x210]
    40000A00 E5854000	STR	R4,[R5,#0]
    40000A04 EAFFFDE4	B	4000019C
(0492) 
(0493)     case EDVS_DATA_FORMAT_HEX_TS_RET:
(0494)       TXBuffer[8] = hexLookupTable[((eventA>>12) & 0x0F)]; // 1st byte to send
    40000A08 E59F4238	LDR	R4,[PC,#0x238]
    40000A0C E1A05629	MOV	R5,R9,LSR #12
    40000A10 E205500F	AND	R5,R5,#15
    40000A14 E7D54004	LDRB	R4,[R5,R4]
    40000A18 E59F5234	LDR	R5,[PC,#0x234]
    40000A1C E5C54000	STRB	R4,[R5,#0]
(0495)       TXBuffer[7] = hexLookupTable[((eventA>> 8) & 0x0F)]; // 2nd byte to send
    40000A20 E59F4220	LDR	R4,[PC,#0x220]
    40000A24 E1A05429	MOV	R5,R9,LSR #8
    40000A28 E205500F	AND	R5,R5,#15
    40000A2C E7D54004	LDRB	R4,[R5,R4]
    40000A30 E59F5214	LDR	R5,[PC,#0x214]
    40000A34 E5C54000	STRB	R4,[R5,#0]
(0496)       TXBuffer[6] = hexLookupTable[((eventA>> 4) & 0x0F)]; // 3rd byte to send
    40000A38 E59F4208	LDR	R4,[PC,#0x208]
    40000A3C E1A05229	MOV	R5,R9,LSR #4
    40000A40 E205500F	AND	R5,R5,#15
    40000A44 E7D54004	LDRB	R4,[R5,R4]
    40000A48 E59F5200	LDR	R5,[PC,#0x200]
    40000A4C E5C54000	STRB	R4,[R5,#0]
(0497)       TXBuffer[5] = hexLookupTable[((eventA    ) & 0x0F)]; // 4th byte to send
    40000A50 E59F41F0	LDR	R4,[PC,#0x1F0]
    40000A54 E209500F	AND	R5,R9,#15
    40000A58 E7D54004	LDRB	R4,[R5,R4]
    40000A5C E59F51E0	LDR	R5,[PC,#0x1E0]
    40000A60 E5C54000	STRB	R4,[R5,#0]
(0498)       TXBuffer[4] = hexLookupTable[((eventT>>12) & 0x0F)]; // 5th byte to send
    40000A64 E59F41DC	LDR	R4,[PC,#0x1DC]
    40000A68 E1A05628	MOV	R5,R8,LSR #12
    40000A6C E205500F	AND	R5,R5,#15
    40000A70 E7D54004	LDRB	R4,[R5,R4]
    40000A74 E59F51C4	LDR	R5,[PC,#0x1C4]
    40000A78 E5C54000	STRB	R4,[R5,#0]
(0499)       TXBuffer[3] = hexLookupTable[((eventT>> 8) & 0x0F)]; // 6th byte to send
    40000A7C E59F41C4	LDR	R4,[PC,#0x1C4]
    40000A80 E1A05428	MOV	R5,R8,LSR #8
    40000A84 E205500F	AND	R5,R5,#15
    40000A88 E7D54004	LDRB	R4,[R5,R4]
    40000A8C E59F51A4	LDR	R5,[PC,#0x1A4]
    40000A90 E5C54000	STRB	R4,[R5,#0]
(0500)       TXBuffer[2] = hexLookupTable[((eventT>> 4) & 0x0F)]; // 7th byte to send
    40000A94 E59F41AC	LDR	R4,[PC,#0x1AC]
    40000A98 E1A05228	MOV	R5,R8,LSR #4
    40000A9C E205500F	AND	R5,R5,#15
    40000AA0 E7D54004	LDRB	R4,[R5,R4]
    40000AA4 E59F5190	LDR	R5,[PC,#0x190]
    40000AA8 E5C54000	STRB	R4,[R5,#0]
(0501)       TXBuffer[1] = hexLookupTable[((eventT)     & 0x0F)]; // 8th byte to send
    40000AAC E59F4194	LDR	R4,[PC,#0x194]
    40000AB0 E208500F	AND	R5,R8,#15
    40000AB4 E7D54004	LDRB	R4,[R5,R4]
    40000AB8 E59F5174	LDR	R5,[PC,#0x174]
    40000ABC E5C54000	STRB	R4,[R5,#0]
(0502) 	  TXBuffer[0] = '\n';		   						  // return
    40000AC0 E3A0400A	MOV	R4,#10
    40000AC4 E59F514C	LDR	R5,[PC,#0x14C]
    40000AC8 E5C54000	STRB	R4,[R5,#0]
(0503) 	  TXBufferIndex = 9; break;
    40000ACC E3A04009	MOV	R4,#9
    40000AD0 E59F513C	LDR	R5,[PC,#0x13C]
    40000AD4 E5854000	STR	R4,[R5,#0]
    40000AD8 EAFFFDAF	B	4000019C
(0504) 
(0505)     case EDVS_DATA_FORMAT_ASCII:
(0506) 	  sprintf(TXBuffer, "%1d %3d %3d\n", ((eventA>>7) & 0x01), ((eventA>>8) & 0x7F), ((eventA) & 0x7F));
    40000ADC E59F0134	LDR	R0,[PC,#0x134]
    40000AE0 E59F1170	LDR	R1,[PC,#0x170]
    40000AE4 E1A043A9	MOV	R4,R9,LSR #7
    40000AE8 E2042001	AND	R2,R4,#1
    40000AEC E1A04429	MOV	R4,R9,LSR #8
    40000AF0 E204307F	AND	R3,R4,#0x7F
    40000AF4 E209407F	AND	R4,R9,#0x7F
    40000AF8 E58D4000	STR	R4,[SP,#0]
    40000AFC EB00322B	BL	ramfunc_to_arm_branch_veneer__sprintf
(0507) 	  swapByteOrderInMemory(TXBuffer, 10);
    40000B00 E59F0110	LDR	R0,[PC,#0x110]
    40000B04 E3A0100A	MOV	R1,#10
    40000B08 EBFFFD62	BL	_swapByteOrderInMemory
(0508) 	  TXBufferIndex = 10; break;
    40000B0C E3A0400A	MOV	R4,#10
    40000B10 E59F50FC	LDR	R5,[PC,#0xFC]
    40000B14 E5854000	STR	R4,[R5,#0]
    40000B18 EAFFFD9F	B	4000019C
(0509) 
(0510) 	case EDVS_DATA_FORMAT_ASCII_TS:
(0511) 	  sprintf(TXBuffer, "%1d %3d %3d %8ld\n", ((eventA>>7) & 0x01), ((eventA>>8) & 0x7F), ((eventA) & 0x7F), ((eventT>>TIMESTAMP_SHIFTBITS)));
    40000B1C E59F00F4	LDR	R0,[PC,#0xF4]
    40000B20 E59F1134	LDR	R1,[PC,#0x134]
    40000B24 E1A043A9	MOV	R4,R9,LSR #7
    40000B28 E2042001	AND	R2,R4,#1
    40000B2C E1A04429	MOV	R4,R9,LSR #8
    40000B30 E204307F	AND	R3,R4,#0x7F
    40000B34 E209407F	AND	R4,R9,#0x7F
    40000B38 E58D4000	STR	R4,[SP,#0]
    40000B3C E1A04328	MOV	R4,R8,LSR #6
    40000B40 E58D4004	STR	R4,[SP,#4]
    40000B44 EB00321B	BL	4000D3B8
(0512) 	  swapByteOrderInMemory(TXBuffer, 19);
    40000B48 E59F00C8	LDR	R0,[PC,#0xC8]
    40000B4C E3A01013	MOV	R1,#19
    40000B50 EBFFFD50	BL	_swapByteOrderInMemory
(0513) 	  TXBufferIndex = 19; break;
    40000B54 E3A04013	MOV	R4,#19
    40000B58 E59F50B4	LDR	R5,[PC,#0xB4]
    40000B5C E5854000	STR	R4,[R5,#0]
    40000B60 EAFFFD8D	B	4000019C
(0514) 
(0515) 	case EDVS_DATA_FORMAT_ASCII_TSHS:
(0516) 	  sprintf(TXBuffer, "%1d %3d %3d %10lu\n", ((eventA>>7) & 0x01), ((eventA>>8) & 0x7F), ((eventA) & 0x7F), ((eventT)));
    40000B64 E59F00AC	LDR	R0,[PC,#0xAC]
    40000B68 E59F10F0	LDR	R1,[PC,#0xF0]
    40000B6C E1A043A9	MOV	R4,R9,LSR #7
    40000B70 E2042001	AND	R2,R4,#1
    40000B74 E1A04429	MOV	R4,R9,LSR #8
    40000B78 E204307F	AND	R3,R4,#0x7F
    40000B7C E209407F	AND	R4,R9,#0x7F
    40000B80 E58D4000	STR	R4,[SP,#0]
    40000B84 E58D8004	STR	R8,[SP,#4]
    40000B88 EB00320C	BL	4000D3C0
(0517) 	  swapByteOrderInMemory(TXBuffer, 21);
    40000B8C E59F0084	LDR	R0,[PC,#0x84]
    40000B90 E3A01015	MOV	R1,#21
    40000B94 EBFFFD3F	BL	_swapByteOrderInMemory
(0518) 	  TXBufferIndex = 21; break;
    40000B98 E3A04015	MOV	R4,#21
    40000B9C E59F5070	LDR	R5,[PC,#0x70]
    40000BA0 E5854000	STR	R4,[R5,#0]
(0519)     }
(0520)   }
(0521) 
(0522) // *****************************************************************************
(0523) //    End of Main Loop
(0524) // *****************************************************************************
(0525) goto MLStart;
    40000BA4 EAFFFD7C	B	4000019C
    40000BA8 E89BABF0	LDMIA	R11,{R4,R5,R6,R7,R8,R9,R11,R13,PC}
FILE: ../../../../../../DOCUME~1/conradt/MYDOCU~1/Projects/DVS128/EDVS128_2106_Rev1.3//DVS128Chip.c
(0001) #include "EDVS128_2106.h"
(0002) 
(0003) //#define DEFAULT_BIAS_SET		0			// "BIAS_DEFAULT"
(0004) #define DEFAULT_BIAS_SET		1			// "BIAS_BRAGFOST"
(0005) //#define DEFAULT_BIAS_SET		2			// "BIAS_FAST"
(0006) //#define DEFAULT_BIAS_SET		3			// "BIAS_STEREO_PAIR"
(0007) //#define DEFAULT_BIAS_SET		4			// "BIAS_MINI_DVS"
(0008) 
(0009) // *****************************************************************************
(0010) extern unsigned char dataForTransmission[16];
(0011) 
(0012) // *****************************************************************************
(0013) unsigned long biasMatrix[12];
(0014) 
(0015) // *****************************************************************************
(0016) unsigned long enableEventSending;
(0017) unsigned long newEvent;
(0018) unsigned long x, y, p;
(0019) 
(0020) unsigned short eventBufferA[DVS_EVENTBUFFER_SIZE];		  // for event addresses
(0021) unsigned long  eventBufferT[DVS_EVENTBUFFER_SIZE];		  // for event time stamps
(0022) unsigned long eventBufferWritePointer;
(0023) unsigned long eventBufferReadPointer;
(0024) 
(0025) #ifdef INCLUDE_PIXEL_CUTOUT_REGION
(0026) unsigned long pixelCutoutMinX, pixelCutoutMaxX, pixelCutoutMinY, pixelCutoutMaxY;
(0027) #endif
(0028) 
(0029) // *****************************************************************************
(0030) void DVS128ChipInit(void) {
$a:
_DVS128ChipInit:
    0000079C E1A0C00D	MOV	R12,SP
    000007A0 E92D5870	STMDB	SP!,{R4,R5,R6,R11,R12,LR}
    000007A4 E1A0B00D	MOV	R11,SP
(0031)   FGPIO_IOSET  = PIN_RESET_DVS;					// DVS array reset to high
    000007A8 E3A04C80	MOV	R4,#0x8000
    000007AC E59F5134	LDR	R5,[PC,#0x134]
    000007B0 E5854000	STR	R4,[R5,#0]
(0032)   FGPIO_IODIR |= PIN_RESET_DVS;					// DVS array reset pin to output
    000007B4 E59F4130	LDR	R4,[PC,#0x130]
    000007B8 E5945000	LDR	R5,[R4,#0]
    000007BC E3855C80	ORR	R5,#0x8000
    000007C0 E5845000	STR	R5,[R4,#0]
(0033) 
(0034) //  FGPIO_IOSET  = PIN_DVS_ACKN;				// ackn to high	   	  // let DVS handshake itself, only grab addresses from bus
(0035) //  FGPIO_IODIR |= PIN_DVS_ACKN;				// ackn to output port
(0036) 
(0037)   FGPIO_IOSET  = (PIN_BIAS_LATCH);				// set pins to bias setup as outputs
    000007C4 E3A04D40	MOV	R4,#0x1000
    000007C8 E59F5118	LDR	R5,[PC,#0x118]
    000007CC E5854000	STR	R4,[R5,#0]
(0038)   FGPIO_IOCLR  = (PIN_BIAS_CLOCK | PIN_BIAS_DATA);
    000007D0 E59F4118	LDR	R4,[PC,#0x118]
    000007D4 E59F5118	LDR	R5,[PC,#0x118]
    000007D8 E5854000	STR	R4,[R5,#0]
(0039)   FGPIO_IODIR |= (PIN_BIAS_LATCH | PIN_BIAS_DATA | PIN_BIAS_CLOCK);
    000007DC E59F4108	LDR	R4,[PC,#0x108]
    000007E0 E59F5110	LDR	R5,[PC,#0x110]
    000007E4 E5946000	LDR	R6,[R4,#0]
    000007E8 E1865005	ORR	R5,R5
    000007EC E5845000	STR	R5,[R4,#0]
(0040) 
(0041)   FGPIO_IOCLR  = PIN_RESET_DVS;					// DVS array reset to low
    000007F0 E3A04C80	MOV	R4,#0x8000
    000007F4 E59F50F8	LDR	R5,[PC,#0xF8]
    000007F8 E5854000	STR	R4,[R5,#0]
(0042)   delayMS(10); 	 								// 10ms delay
    000007FC E3A0000A	MOV	R0,#10
    00000800 EBFFFEE9	BL	_delayMS
(0043)   FGPIO_IOSET  = PIN_RESET_DVS;					// DVS array reset to high
    00000804 E3A04C80	MOV	R4,#0x8000
    00000808 E59F50D8	LDR	R5,[PC,#0xD8]
    0000080C E5854000	STR	R4,[R5,#0]
(0044)   delayMS(1); 	 								// 1ms delay
    00000810 E3A00001	MOV	R0,#1
    00000814 EBFFFEE4	BL	_delayMS
(0045) 
(0046)   DVS128BiasLoadDefaultSet(DEFAULT_BIAS_SET);	// load default bias settings
    00000818 E3A00001	MOV	R0,#1
    0000081C EB000079	BL	_DVS128BiasLoadDefaultSet
(0047)   DVS128BiasFlush();							// transfer bias settings to chip
    00000820 EB000A50	BL	arm_to_ramfunc_branch_veneer__DVS128BiasFlush
(0048) 
(0049)   // *****************************************************************************
(0050)   eventBufferWritePointer=0;					// initialize eventBuffer
    00000824 E3A04000	MOV	R4,#0
    00000828 E59F50CC	LDR	R5,[PC,#0xCC]
    0000082C E5854000	STR	R4,[R5,#0]
(0051)   eventBufferReadPointer=0;
    00000830 E3A04000	MOV	R4,#0
    00000834 E59F50C4	LDR	R5,[PC,#0xC4]
    00000838 E5854000	STR	R4,[R5,#0]
(0052) 
(0053)   // *****************************************************************************
(0054)   enableEventSending=0;
    0000083C E3A04000	MOV	R4,#0
    00000840 E59F50BC	LDR	R5,[PC,#0xBC]
    00000844 E5854000	STR	R4,[R5,#0]
(0055)   DVS128FetchEventsEnable(FALSE);
    00000848 E3A00000	MOV	R0,#0
    0000084C EB00003A	BL	_DVS128FetchEventsEnable
(0056) 
(0057) #ifdef INCLUDE_PIXEL_CUTOUT_REGION
(0058)   pixelCutoutMinX = 0;
(0059)   pixelCutoutMaxX = 127;
(0060)   pixelCutoutMinY = 0;
(0061)   pixelCutoutMaxY = 127;
(0062) #endif
(0063) 
(0064) 
(0065)   // *****************************************************************************
(0066)   // ** initialize timer 0 (1us clock)
(0067)   // *****************************************************************************
(0068)   T0_PR = (1000*PLL_CLOCK)-1;	// prescaler: run at 1ms clock rate
    00000850 E59F40B0	LDR	R4,[PC,#0xB0]
    00000854 E59F50B0	LDR	R5,[PC,#0xB0]
    00000858 E5854000	STR	R4,[R5,#0]
(0069)   T0_CTCR = 0x00;				// increase time on every T-CLK
    0000085C E3A04000	MOV	R4,#0
    00000860 E59F50A8	LDR	R5,[PC,#0xA8]
    00000864 E5854000	STR	R4,[R5,#0]
(0070) 
(0071)   T0_MCR  = 0x00;				// match register, no special action, simply count until 2^32-1 and restart
    00000868 E3A04000	MOV	R4,#0
    0000086C E59F50A0	LDR	R5,[PC,#0xA0]
    00000870 E5854000	STR	R4,[R5,#0]
(0072)   T0_TC	  = 0;					// reset counter to zero
    00000874 E3A04000	MOV	R4,#0
    00000878 E59F5098	LDR	R5,[PC,#0x98]
    0000087C E5854000	STR	R4,[R5,#0]
(0073)   T0_TCR  = 0x01;				// enable Timer/Counter 0
    00000880 E3A04001	MOV	R4,#1
    00000884 E59F5090	LDR	R5,[PC,#0x90]
    00000888 E5854000	STR	R4,[R5,#0]
(0074) 
(0075) 
(0076)   // *****************************************************************************
(0077)   // ** initialize timer 1 (system main clock)
(0078)   // *****************************************************************************
(0079)   T1_PR = 0;					// prescaler: run at main clock speed!
    0000088C E3A04000	MOV	R4,#0
    00000890 E59F5088	LDR	R5,[PC,#0x88]
    00000894 E5854000	STR	R4,[R5,#0]
(0080)   T1_CTCR = 0x00;				// increase time on every T-CLK
    00000898 E3A04000	MOV	R4,#0
    0000089C E59F5080	LDR	R5,[PC,#0x80]
    000008A0 E5854000	STR	R4,[R5,#0]
(0081) 
(0082) //  T1_MR0 = BIT(16);			// match register: count only up to 2^16 = 0..65535
(0083) //  T1_MR0 = 50000;				// match register: count only up 2us * 50.000 = 100.000us = 100ms
(0084) //  T1_MCR  = 0x02;				// match register, reset counter on match with T1_MR0
(0085) 
(0086)   T1_MCR  = 0x00;				// match register, no special action, simply count until 2^32-1 and restart
    000008A4 E3A04000	MOV	R4,#0
    000008A8 E59F5078	LDR	R5,[PC,#0x78]
    000008AC E5854000	STR	R4,[R5,#0]
(0087)   T1_CCR  = BIT(1);				// capture TC in CR0 on falling edge of CAP0.1 (PIN_DVS_REQUEST)
    000008B0 E3A04002	MOV	R4,#2
    000008B4 E59F5070	LDR	R5,[PC,#0x70]
    000008B8 E5854000	STR	R4,[R5,#0]
(0088)   PCB_PINSEL0 |= BIT(21);		// set P0.10 to capture register CAP0.1
    000008BC E59F406C	LDR	R4,[PC,#0x6C]
    000008C0 E5945000	LDR	R5,[R4,#0]
    000008C4 E3855980	ORR	R5,#0x200000
    000008C8 E5845000	STR	R5,[R4,#0]
(0089) 
(0090)   T1_TC	  = 0;					// reset counter to zero
    000008CC E3A04000	MOV	R4,#0
    000008D0 E59F505C	LDR	R5,[PC,#0x5C]
    000008D4 E5854000	STR	R4,[R5,#0]
(0091)   T1_TCR  = 0x01;				// enable Timer/Counter 1
    000008D8 E3A04001	MOV	R4,#1
    000008DC E59F5054	LDR	R5,[PC,#0x54]
    000008E0 E5854000	STR	R4,[R5,#0]
    000008E4 E89BA870	LDMIA	R11,{R4,R5,R6,R11,R13,PC}
(0092) }
(0093) 
(0094) // *****************************************************************************
(0095) void DVS128FetchEventsEnable(unsigned char flag) {
$a:
_DVS128FetchEventsEnable:
  flag                 --> R6
    0000093C E1A0C00D	MOV	R12,SP
    00000940 E92D5870	STMDB	SP!,{R4,R5,R6,R11,R12,LR}
    00000944 E1A0B00D	MOV	R11,SP
    00000948 E1A06000	MOV	R6,R0
(0096)   if (flag) {
    0000094C E21640FF	ANDS	R4,R6,#0xFF
    00000950 0A000005	BEQ	0000096C
(0097)     LEDSetOff();
    00000954 E3A00000	MOV	R0,#0
    00000958 EBFFFEA0	BL	_LEDSetState
(0098)     enableEventSending = 1;
    0000095C E3A04001	MOV	R4,#1
    00000960 E59F501C	LDR	R5,[PC,#28]
    00000964 E5854000	STR	R4,[R5,#0]
(0099)   } else {
    00000968 EA000004	B	00000980
(0100)     LEDSetBlinking();
    0000096C E3E00000	MVN	R0,R0,#0
    00000970 EBFFFE9A	BL	_LEDSetState
(0101)     enableEventSending = 0;
    00000974 E3A04000	MOV	R4,#0
    00000978 E59F5004	LDR	R5,[PC,#4]
    0000097C E5854000	STR	R4,[R5,#0]
(0102)   }
    00000980 E89BA870	LDMIA	R11,{R4,R5,R6,R11,R13,PC}
(0103) }
(0104) 
(0105) // *****************************************************************************
(0106) void DVS128BiasSet(unsigned long biasID, unsigned long biasValue) {
_DVS128BiasSet:
  biasValue            --> R4
  biasID               --> R5
$a:
    00000988 E1A0C00D	MOV	R12,SP
    0000098C E92D5830	STMDB	SP!,{R4,R5,R11,R12,LR}
    00000990 E1A0B00D	MOV	R11,SP
    00000994 E1A05000	MOV	R5,R0
    00000998 E1A04001	MOV	R4,R1
(0107)   if (biasID < 12) {
    0000099C E355000C	CMP	R5,#12
    000009A0 2A000003	BCS	000009B4
(0108)     biasMatrix[biasID] = biasValue;
    000009A4 E3A00004	MOV	R0,#4
    000009A8 E0000590	MUL	R0,R0,R5
    000009AC E59F1004	LDR	R1,[PC,#4]
    000009B0 E7804001	STR	R4,[R0,R1]
(0109)   }
    000009B4 E89BA830	LDMIA	R11,{R4,R5,R11,R13,PC}
(0110) }
(0111) // *****************************************************************************
(0112) unsigned long DVS128BiasGet(unsigned long biasID) {
_DVS128BiasGet:
  biasID               --> R4
$a:
    000009BC E1A0C00D	MOV	R12,SP
    000009C0 E92D5810	STMDB	SP!,{R4,R11,R12,LR}
    000009C4 E1A0B00D	MOV	R11,SP
    000009C8 E1A04000	MOV	R4,R0
(0113)   if (biasID < 12) {
    000009CC E354000C	CMP	R4,#12
    000009D0 2A000004	BCS	000009E8
(0114)     return(biasMatrix[biasID]);
    000009D4 E3A01004	MOV	R1,#4
    000009D8 E0010491	MUL	R1,R1,R4
    000009DC E59F200C	LDR	R2,[PC,#12]
    000009E0 E7910002	LDR	R0,[R1,R2]
    000009E4 EA000000	B	000009EC
(0115)   }
(0116)   return(0);
    000009E8 E3A00000	MOV	R0,#0
    000009EC E89BA810	LDMIA	R11,{R4,R11,R13,PC}
(0117) }
(0118) 
(0119) // *****************************************************************************
(0120) void DVS128BiasLoadDefaultSet(unsigned long biasSetID) {
_DVS128BiasLoadDefaultSet:
  biasSetID            --> R4
$a:
    00000A08 E1A0C00D	MOV	R12,SP
    00000A0C E92D5810	STMDB	SP!,{R4,R11,R12,LR}
    00000A10 E1A0B00D	MOV	R11,SP
    00000A14 E1A04000	MOV	R4,R0
(0121) 
(0122)   switch (biasSetID) {
    00000A18 E3A01004	MOV	R1,#4
    00000A1C E3540004	CMP	R4,#4
    00000A20 CA0000BB	BGT	00000D14
    00000A24 E0000491	MUL	R0,R1,R4
    00000A28 E59F12E8	LDR	R1,[PC,#0x2E8]
    00000A2C E7900001	LDR	R0,[R0,R1]
    00000A30 E1A0F000	MOV	PC,R0
(0123) 
(0124)   case 0:  // 12 bias values of 24 bits each 								BIAS_DEFAULT
(0125)     biasMatrix[ 0]=	    1067; // 0x00042B,	  		// Tmpdiff128.IPot.cas
    00000A34 E59F02E0	LDR	R0,[PC,#0x2E0]
    00000A38 E59F12E0	LDR	R1,[PC,#0x2E0]
    00000A3C E5810000	STR	R0,[R1,#0]
(0126)     biasMatrix[ 1]=	   12316; // 0x00301C,			// Tmpdiff128.IPot.injGnd
    00000A40 E59F02DC	LDR	R0,[PC,#0x2DC]
    00000A44 E59F12DC	LDR	R1,[PC,#0x2DC]
    00000A48 E5810000	STR	R0,[R1,#0]
(0127)     biasMatrix[ 2]=	16777215; // 0xFFFFFF,			// Tmpdiff128.IPot.reqPd
    00000A4C E3E004FF	MVN	R0,R0,#0xFF000000
    00000A50 E59F12D4	LDR	R1,[PC,#0x2D4]
    00000A54 E5810000	STR	R0,[R1,#0]
(0128)     biasMatrix[ 3]=	 5579732; // 0x5523D4,			// Tmpdiff128.IPot.puX
    00000A58 E59F02D0	LDR	R0,[PC,#0x2D0]
    00000A5C E59F12D0	LDR	R1,[PC,#0x2D0]
    00000A60 E5810000	STR	R0,[R1,#0]
(0129)     biasMatrix[ 4]=	     151; // 0x000097,			// Tmpdiff128.IPot.diffOff
    00000A64 E3A00097	MOV	R0,#0x97
    00000A68 E59F12C8	LDR	R1,[PC,#0x2C8]
    00000A6C E5810000	STR	R0,[R1,#0]
(0130)     biasMatrix[ 5]=	  427594; // 0x06864A,			// Tmpdiff128.IPot.req
    00000A70 E59F02C4	LDR	R0,[PC,#0x2C4]
    00000A74 E59F12C4	LDR	R1,[PC,#0x2C4]
    00000A78 E5810000	STR	R0,[R1,#0]
(0131)     biasMatrix[ 6]=	       0; // 0x000000,			// Tmpdiff128.IPot.refr
    00000A7C E3A00000	MOV	R0,#0
    00000A80 E59F12BC	LDR	R1,[PC,#0x2BC]
    00000A84 E5810000	STR	R0,[R1,#0]
(0132)     biasMatrix[ 7]=	16777215; // 0xFFFFFF,			// Tmpdiff128.IPot.puY
    00000A88 E3E004FF	MVN	R0,R0,#0xFF000000
    00000A8C E59F12B4	LDR	R1,[PC,#0x2B4]
    00000A90 E5810000	STR	R0,[R1,#0]
(0133)     biasMatrix[ 8]=	  296253; // 0x04853D,			// Tmpdiff128.IPot.diffOn
    00000A94 E59F02B0	LDR	R0,[PC,#0x2B0]
    00000A98 E59F12B0	LDR	R1,[PC,#0x2B0]
    00000A9C E5810000	STR	R0,[R1,#0]
(0134)     biasMatrix[ 9]=	    3624; // 0x000E28,			// Tmpdiff128.IPot.diff
    00000AA0 E59F02AC	LDR	R0,[PC,#0x2AC]
    00000AA4 E59F12AC	LDR	R1,[PC,#0x2AC]
    00000AA8 E5810000	STR	R0,[R1,#0]
(0135)     biasMatrix[10]=	      39; // 0x000027,			// Tmpdiff128.IPot.foll
    00000AAC E3A00027	MOV	R0,#0x27
    00000AB0 E59F12A4	LDR	R1,[PC,#0x2A4]
    00000AB4 E5810000	STR	R0,[R1,#0]
(0136)     biasMatrix[11]=        4; // 0x000004			// Tmpdiff128.IPot.Pr
    00000AB8 E3A00004	MOV	R0,#4
    00000ABC E59F129C	LDR	R1,[PC,#0x29C]
    00000AC0 E5810000	STR	R0,[R1,#0]
(0137)     break;
    00000AC4 EA000092	B	00000D14
(0138) 
(0139)   case 1:  // 12 bias values of 24 bits each 								BIAS_BRAGFOST
(0140)     biasMatrix[ 0]=        1067;	  		// Tmpdiff128.IPot.cas
    00000AC8 E59F024C	LDR	R0,[PC,#0x24C]
    00000ACC E59F124C	LDR	R1,[PC,#0x24C]
    00000AD0 E5810000	STR	R0,[R1,#0]
(0141)     biasMatrix[ 1]=       12316;			// Tmpdiff128.IPot.injGnd
    00000AD4 E59F0248	LDR	R0,[PC,#0x248]
    00000AD8 E59F1248	LDR	R1,[PC,#0x248]
    00000ADC E5810000	STR	R0,[R1,#0]
(0142)     biasMatrix[ 2]=    16777215;			// Tmpdiff128.IPot.reqPd
    00000AE0 E3E004FF	MVN	R0,R0,#0xFF000000
    00000AE4 E59F1240	LDR	R1,[PC,#0x240]
    00000AE8 E5810000	STR	R0,[R1,#0]
(0143)     biasMatrix[ 3]=     5579731;			// Tmpdiff128.IPot.puX
    00000AEC E59F0270	LDR	R0,[PC,#0x270]
    00000AF0 E59F123C	LDR	R1,[PC,#0x23C]
    00000AF4 E5810000	STR	R0,[R1,#0]
(0144)     biasMatrix[ 4]=          60;			// Tmpdiff128.IPot.diffOff
    00000AF8 E3A0003C	MOV	R0,#0x3C
    00000AFC E59F1234	LDR	R1,[PC,#0x234]
    00000B00 E5810000	STR	R0,[R1,#0]
(0145)     biasMatrix[ 5]=      427594;			// Tmpdiff128.IPot.req
    00000B04 E59F0230	LDR	R0,[PC,#0x230]
    00000B08 E59F1230	LDR	R1,[PC,#0x230]
    00000B0C E5810000	STR	R0,[R1,#0]
(0146)     biasMatrix[ 6]=           0;			// Tmpdiff128.IPot.refr
    00000B10 E3A00000	MOV	R0,#0
    00000B14 E59F1228	LDR	R1,[PC,#0x228]
    00000B18 E5810000	STR	R0,[R1,#0]
(0147)     biasMatrix[ 7]=    16777215;			// Tmpdiff128.IPot.puY
    00000B1C E3E004FF	MVN	R0,R0,#0xFF000000
    00000B20 E59F1220	LDR	R1,[PC,#0x220]
    00000B24 E5810000	STR	R0,[R1,#0]
(0148)     biasMatrix[ 8]=      567391;			// Tmpdiff128.IPot.diffOn
    00000B28 E59F0238	LDR	R0,[PC,#0x238]
    00000B2C E59F121C	LDR	R1,[PC,#0x21C]
    00000B30 E5810000	STR	R0,[R1,#0]
(0149)     biasMatrix[ 9]=        6831;			// Tmpdiff128.IPot.diff
    00000B34 E59F0230	LDR	R0,[PC,#0x230]
    00000B38 E59F1218	LDR	R1,[PC,#0x218]
    00000B3C E5810000	STR	R0,[R1,#0]
(0150)     biasMatrix[10]=          39;			// Tmpdiff128.IPot.foll
    00000B40 E3A00027	MOV	R0,#0x27
    00000B44 E59F1210	LDR	R1,[PC,#0x210]
    00000B48 E5810000	STR	R0,[R1,#0]
(0151)     biasMatrix[11]=           4;			// Tmpdiff128.IPot.Pr
    00000B4C E3A00004	MOV	R0,#4
    00000B50 E59F1208	LDR	R1,[PC,#0x208]
    00000B54 E5810000	STR	R0,[R1,#0]
(0152)     break;
    00000B58 EA00006D	B	00000D14
(0153) 
(0154)   case 2:  // 12 bias values of 24 bits each 								BIAS_FAST
(0155)     biasMatrix[ 0]=        1966;	  		// Tmpdiff128.IPot.cas
    00000B5C E59F020C	LDR	R0,[PC,#0x20C]
    00000B60 E59F11B8	LDR	R1,[PC,#0x1B8]
    00000B64 E5810000	STR	R0,[R1,#0]
(0156)     biasMatrix[ 1]=     1137667;			// Tmpdiff128.IPot.injGnd
    00000B68 E59F0204	LDR	R0,[PC,#0x204]
    00000B6C E59F11B4	LDR	R1,[PC,#0x1B4]
    00000B70 E5810000	STR	R0,[R1,#0]
(0157)     biasMatrix[ 2]=    16777215;			// Tmpdiff128.IPot.reqPd
    00000B74 E3E004FF	MVN	R0,R0,#0xFF000000
    00000B78 E59F11AC	LDR	R1,[PC,#0x1AC]
    00000B7C E5810000	STR	R0,[R1,#0]
(0158)     biasMatrix[ 3]=     8053457;			// Tmpdiff128.IPot.puX
    00000B80 E59F01F0	LDR	R0,[PC,#0x1F0]
    00000B84 E59F11A8	LDR	R1,[PC,#0x1A8]
    00000B88 E5810000	STR	R0,[R1,#0]
(0159)     biasMatrix[ 4]=         133;			// Tmpdiff128.IPot.diffOff
    00000B8C E3A00085	MOV	R0,#0x85
    00000B90 E59F11A0	LDR	R1,[PC,#0x1A0]
    00000B94 E5810000	STR	R0,[R1,#0]
(0160)     biasMatrix[ 5]=      160712;			// Tmpdiff128.IPot.req
    00000B98 E59F01DC	LDR	R0,[PC,#0x1DC]
    00000B9C E59F119C	LDR	R1,[PC,#0x19C]
    00000BA0 E5810000	STR	R0,[R1,#0]
(0161)     biasMatrix[ 6]=         944;			// Tmpdiff128.IPot.refr
    00000BA4 E3A00FEC	MOV	R0,#0x3B0
    00000BA8 E59F1194	LDR	R1,[PC,#0x194]
    00000BAC E5810000	STR	R0,[R1,#0]
(0162)     biasMatrix[ 7]=    16777215;			// Tmpdiff128.IPot.puY
    00000BB0 E3E004FF	MVN	R0,R0,#0xFF000000
    00000BB4 E59F118C	LDR	R1,[PC,#0x18C]
    00000BB8 E5810000	STR	R0,[R1,#0]
(0163)     biasMatrix[ 8]=      205255;			// Tmpdiff128.IPot.diffOn
    00000BBC E59F01BC	LDR	R0,[PC,#0x1BC]
    00000BC0 E59F1188	LDR	R1,[PC,#0x188]
    00000BC4 E5810000	STR	R0,[R1,#0]
(0164)     biasMatrix[ 9]=        3207;			// Tmpdiff128.IPot.diff
    00000BC8 E59F01B4	LDR	R0,[PC,#0x1B4]
    00000BCC E59F1184	LDR	R1,[PC,#0x184]
    00000BD0 E5810000	STR	R0,[R1,#0]
(0165)     biasMatrix[10]=         278;			// Tmpdiff128.IPot.foll
    00000BD4 E59F01AC	LDR	R0,[PC,#0x1AC]
    00000BD8 E59F117C	LDR	R1,[PC,#0x17C]
    00000BDC E5810000	STR	R0,[R1,#0]
(0166)     biasMatrix[11]=         217;			// Tmpdiff128.IPot.Pr
    00000BE0 E3A000D9	MOV	R0,#0xD9
    00000BE4 E59F1174	LDR	R1,[PC,#0x174]
    00000BE8 E5810000	STR	R0,[R1,#0]
(0167)     break;
    00000BEC EA000048	B	00000D14
(0168) 
(0169)   case 3:  // 12 bias values of 24 bits each 								BIAS_STEREO_PAIR
(0170)     biasMatrix[ 0]=        1966;
    00000BF0 E59F0178	LDR	R0,[PC,#0x178]
    00000BF4 E59F1124	LDR	R1,[PC,#0x124]
    00000BF8 E5810000	STR	R0,[R1,#0]
(0171)     biasMatrix[ 1]=     1135792;
    00000BFC E59F0188	LDR	R0,[PC,#0x188]
    00000C00 E59F1120	LDR	R1,[PC,#0x120]
    00000C04 E5810000	STR	R0,[R1,#0]
(0172)     biasMatrix[ 2]=    16769632;
    00000C08 E59F0180	LDR	R0,[PC,#0x180]
    00000C0C E59F1118	LDR	R1,[PC,#0x118]
    00000C10 E5810000	STR	R0,[R1,#0]
(0173)     biasMatrix[ 3]=     8061894;
    00000C14 E59F0178	LDR	R0,[PC,#0x178]
    00000C18 E59F1114	LDR	R1,[PC,#0x114]
    00000C1C E5810000	STR	R0,[R1,#0]
(0174)     biasMatrix[ 4]=         133;
    00000C20 E3A00085	MOV	R0,#0x85
    00000C24 E59F110C	LDR	R1,[PC,#0x10C]
    00000C28 E5810000	STR	R0,[R1,#0]
(0175)     biasMatrix[ 5]=      160703;
    00000C2C E59F0164	LDR	R0,[PC,#0x164]
    00000C30 E59F1108	LDR	R1,[PC,#0x108]
    00000C34 E5810000	STR	R0,[R1,#0]
(0176)     biasMatrix[ 6]=         935;
    00000C38 E59F015C	LDR	R0,[PC,#0x15C]
    00000C3C E59F1100	LDR	R1,[PC,#0x100]
    00000C40 E5810000	STR	R0,[R1,#0]
(0177)     biasMatrix[ 7]=    16769632;
    00000C44 E59F0144	LDR	R0,[PC,#0x144]
    00000C48 E59F10F8	LDR	R1,[PC,#0xF8]
    00000C4C E5810000	STR	R0,[R1,#0]
(0178)     biasMatrix[ 8]=      205244;
    00000C50 E59F0148	LDR	R0,[PC,#0x148]
    00000C54 E59F10F4	LDR	R1,[PC,#0xF4]
    00000C58 E5810000	STR	R0,[R1,#0]
(0179)     biasMatrix[ 9]=        3207;
    00000C5C E59F0120	LDR	R0,[PC,#0x120]
    00000C60 E59F10F0	LDR	R1,[PC,#0xF0]
    00000C64 E5810000	STR	R0,[R1,#0]
(0180)     biasMatrix[10]=         267;
    00000C68 E59F0134	LDR	R0,[PC,#0x134]
    00000C6C E59F10E8	LDR	R1,[PC,#0xE8]
    00000C70 E5810000	STR	R0,[R1,#0]
(0181)     biasMatrix[11]=         217;
    00000C74 E3A000D9	MOV	R0,#0xD9
    00000C78 E59F10E0	LDR	R1,[PC,#0xE0]
    00000C7C E5810000	STR	R0,[R1,#0]
(0182)     break;
    00000C80 EA000023	B	00000D14
(0183) 
(0184)   case 4:  // 12 bias values of 24 bits each 								BIAS_MINI_DVS
(0185)     biasMatrix[ 0]=        1966;
    00000C84 E59F00E4	LDR	R0,[PC,#0xE4]
    00000C88 E59F1090	LDR	R1,[PC,#0x90]
    00000C8C E5810000	STR	R0,[R1,#0]
(0186)     biasMatrix[ 1]=     1137667;
    00000C90 E59F00DC	LDR	R0,[PC,#0xDC]
    00000C94 E59F108C	LDR	R1,[PC,#0x8C]
    00000C98 E5810000	STR	R0,[R1,#0]
(0187)     biasMatrix[ 2]=    16777215;
    00000C9C E3E004FF	MVN	R0,R0,#0xFF000000
    00000CA0 E59F1084	LDR	R1,[PC,#0x84]
    00000CA4 E5810000	STR	R0,[R1,#0]
(0188)     biasMatrix[ 3]=     8053458;
    00000CA8 E59F00F8	LDR	R0,[PC,#0xF8]
    00000CAC E59F1080	LDR	R1,[PC,#0x80]
    00000CB0 E5810000	STR	R0,[R1,#0]
(0189)     biasMatrix[ 4]=          62;
    00000CB4 E3A0003E	MOV	R0,#0x3E
    00000CB8 E59F1078	LDR	R1,[PC,#0x78]
    00000CBC E5810000	STR	R0,[R1,#0]
(0190)     biasMatrix[ 5]=      160712;
    00000CC0 E59F00B4	LDR	R0,[PC,#0xB4]
    00000CC4 E59F1074	LDR	R1,[PC,#0x74]
    00000CC8 E5810000	STR	R0,[R1,#0]
(0191)     biasMatrix[ 6]=         944;
    00000CCC E3A00FEC	MOV	R0,#0x3B0
    00000CD0 E59F106C	LDR	R1,[PC,#0x6C]
    00000CD4 E5810000	STR	R0,[R1,#0]
(0192)     biasMatrix[ 7]=    16777215;
    00000CD8 E3E004FF	MVN	R0,R0,#0xFF000000
    00000CDC E59F1064	LDR	R1,[PC,#0x64]
    00000CE0 E5810000	STR	R0,[R1,#0]
(0193)     biasMatrix[ 8]=      480988;
    00000CE4 E59F00C0	LDR	R0,[PC,#0xC0]
    00000CE8 E59F1060	LDR	R1,[PC,#0x60]
    00000CEC E5810000	STR	R0,[R1,#0]
(0194)     biasMatrix[ 9]=        3207;
    00000CF0 E59F008C	LDR	R0,[PC,#0x8C]
    00000CF4 E59F105C	LDR	R1,[PC,#0x5C]
    00000CF8 E5810000	STR	R0,[R1,#0]
(0195)     biasMatrix[10]=         278;
    00000CFC E59F0084	LDR	R0,[PC,#0x84]
    00000D00 E59F1054	LDR	R1,[PC,#0x54]
    00000D04 E5810000	STR	R0,[R1,#0]
(0196)     biasMatrix[11]=         217;
    00000D08 E3A000D9	MOV	R0,#0xD9
    00000D0C E59F104C	LDR	R1,[PC,#0x4C]
    00000D10 E5810000	STR	R0,[R1,#0]
(0197)     break;
    00000D14 E89BA810	LDMIA	R11,{R4,R11,R13,PC}
(0198) 
(0199)   }
(0200) }
(0201) 
(0202) // *****************************************************************************
(0203) #pragma ramfunc DVS128BiasFlush
(0204) #define BOUT(x)  {if (x) FGPIO_IOSET = biasPIN; else FGPIO_IOCLR = biasPIN; FGPIO_IOSET = clockPIN; FGPIO_IOCLR = clockPIN; }
(0205) 
(0206) void DVS128BiasFlush(void) {
_DVS128BiasFlush:
  biasIndex            --> R6
  biasPIN              --> R4
  currentBias          --> R7
  clockPIN             --> R5
$a:
    40000C64 E1A0C00D	MOV	R12,SP
    40000C68 E92D58F0	STMDB	SP!,{R4,R5,R6,R7,R11,R12,LR}
    40000C6C E1A0B00D	MOV	R11,SP
(0207)   unsigned long biasIndex, currentBias;
(0208)   unsigned long biasPIN, clockPIN;	   		// use local references to pins to save time
(0209)   		   				 					// the c compiler assigns up to four local registers (R4-R7),
(0210) 											// so use them for four local variables
(0211)   biasPIN = PIN_BIAS_DATA;
    40000C70 E3A04D80	MOV	R4,#0x2000
(0212)   clockPIN = PIN_BIAS_CLOCK;
    40000C74 E3A05480	MOV	R5,#0x80000000
(0213) 
(0214)   for (biasIndex=0; biasIndex<12; biasIndex++) {
    40000C78 E3A06000	MOV	R6,#0
    40000C7C EA00010C	B	400010B4
(0215)     currentBias = biasMatrix[biasIndex];
    40000C80 E3A00004	MOV	R0,#4
    40000C84 E0000690	MUL	R0,R0,R6
    40000C88 E59F1448	LDR	R1,[PC,#0x448]
    40000C8C E7907001	LDR	R7,[R0,R1]
(0216) 
(0217) 	BOUT(currentBias & 0x800000);
    40000C90 E3170880	TST	R7,#0x800000
    40000C94 0A000002	BEQ	40000CA4
    40000C98 E59F043C	LDR	R0,[PC,#0x43C]
    40000C9C E5804000	STR	R4,[R0,#0]
    40000CA0 EA000001	B	40000CAC
    40000CA4 E59F0434	LDR	R0,[PC,#0x434]
    40000CA8 E5804000	STR	R4,[R0,#0]
    40000CAC E59F0428	LDR	R0,[PC,#0x428]
    40000CB0 E5805000	STR	R5,[R0,#0]
    40000CB4 E59F0424	LDR	R0,[PC,#0x424]
    40000CB8 E5805000	STR	R5,[R0,#0]
(0218) 	BOUT(currentBias & 0x400000);
    40000CBC E3170840	TST	R7,#0x400000
    40000CC0 0A000002	BEQ	40000CD0
    40000CC4 E59F0410	LDR	R0,[PC,#0x410]
    40000CC8 E5804000	STR	R4,[R0,#0]
    40000CCC EA000001	B	40000CD8
    40000CD0 E59F0408	LDR	R0,[PC,#0x408]
    40000CD4 E5804000	STR	R4,[R0,#0]
    40000CD8 E59F03FC	LDR	R0,[PC,#0x3FC]
    40000CDC E5805000	STR	R5,[R0,#0]
    40000CE0 E59F03F8	LDR	R0,[PC,#0x3F8]
    40000CE4 E5805000	STR	R5,[R0,#0]
(0219) 	BOUT(currentBias & 0x200000);
    40000CE8 E3170980	TST	R7,#0x200000
    40000CEC 0A000002	BEQ	40000CFC
    40000CF0 E59F03E4	LDR	R0,[PC,#0x3E4]
    40000CF4 E5804000	STR	R4,[R0,#0]
    40000CF8 EA000001	B	40000D04
    40000CFC E59F03DC	LDR	R0,[PC,#0x3DC]
    40000D00 E5804000	STR	R4,[R0,#0]
    40000D04 E59F03D0	LDR	R0,[PC,#0x3D0]
    40000D08 E5805000	STR	R5,[R0,#0]
    40000D0C E59F03CC	LDR	R0,[PC,#0x3CC]
    40000D10 E5805000	STR	R5,[R0,#0]
(0220) 	BOUT(currentBias & 0x100000);
    40000D14 E3170940	TST	R7,#0x100000
    40000D18 0A000002	BEQ	40000D28
    40000D1C E59F03B8	LDR	R0,[PC,#0x3B8]
    40000D20 E5804000	STR	R4,[R0,#0]
    40000D24 EA000001	B	40000D30
    40000D28 E59F03B0	LDR	R0,[PC,#0x3B0]
    40000D2C E5804000	STR	R4,[R0,#0]
    40000D30 E59F03A4	LDR	R0,[PC,#0x3A4]
    40000D34 E5805000	STR	R5,[R0,#0]
    40000D38 E59F03A0	LDR	R0,[PC,#0x3A0]
    40000D3C E5805000	STR	R5,[R0,#0]
(0221) 	
(0222) 	BOUT(currentBias & 0x80000);
    40000D40 E3170A80	TST	R7,#0x80000
    40000D44 0A000002	BEQ	40000D54
    40000D48 E59F038C	LDR	R0,[PC,#0x38C]
    40000D4C E5804000	STR	R4,[R0,#0]
    40000D50 EA000001	B	40000D5C
    40000D54 E59F0384	LDR	R0,[PC,#0x384]
    40000D58 E5804000	STR	R4,[R0,#0]
    40000D5C E59F0378	LDR	R0,[PC,#0x378]
    40000D60 E5805000	STR	R5,[R0,#0]
    40000D64 E59F0374	LDR	R0,[PC,#0x374]
    40000D68 E5805000	STR	R5,[R0,#0]
(0223) 	BOUT(currentBias & 0x40000);
    40000D6C E3170A40	TST	R7,#0x40000
    40000D70 0A000002	BEQ	40000D80
    40000D74 E59F0360	LDR	R0,[PC,#0x360]
    40000D78 E5804000	STR	R4,[R0,#0]
    40000D7C EA000001	B	40000D88
    40000D80 E59F0358	LDR	R0,[PC,#0x358]
    40000D84 E5804000	STR	R4,[R0,#0]
    40000D88 E59F034C	LDR	R0,[PC,#0x34C]
    40000D8C E5805000	STR	R5,[R0,#0]
    40000D90 E59F0348	LDR	R0,[PC,#0x348]
    40000D94 E5805000	STR	R5,[R0,#0]
(0224) 	BOUT(currentBias & 0x20000);
    40000D98 E3170B80	TST	R7,#0x20000
    40000D9C 0A000002	BEQ	40000DAC
    40000DA0 E59F0334	LDR	R0,[PC,#0x334]
    40000DA4 E5804000	STR	R4,[R0,#0]
    40000DA8 EA000001	B	40000DB4
    40000DAC E59F032C	LDR	R0,[PC,#0x32C]
    40000DB0 E5804000	STR	R4,[R0,#0]
    40000DB4 E59F0320	LDR	R0,[PC,#0x320]
    40000DB8 E5805000	STR	R5,[R0,#0]
    40000DBC E59F031C	LDR	R0,[PC,#0x31C]
    40000DC0 E5805000	STR	R5,[R0,#0]
(0225) 	BOUT(currentBias & 0x10000);
    40000DC4 E3170B40	TST	R7,#0x10000
    40000DC8 0A000002	BEQ	40000DD8
    40000DCC E59F0308	LDR	R0,[PC,#0x308]
    40000DD0 E5804000	STR	R4,[R0,#0]
    40000DD4 EA000001	B	40000DE0
    40000DD8 E59F0300	LDR	R0,[PC,#0x300]
    40000DDC E5804000	STR	R4,[R0,#0]
    40000DE0 E59F02F4	LDR	R0,[PC,#0x2F4]
    40000DE4 E5805000	STR	R5,[R0,#0]
    40000DE8 E59F02F0	LDR	R0,[PC,#0x2F0]
    40000DEC E5805000	STR	R5,[R0,#0]
(0226) 	
(0227) 	BOUT(currentBias & 0x8000);
    40000DF0 E3170C80	TST	R7,#0x8000
    40000DF4 0A000002	BEQ	40000E04
    40000DF8 E59F02DC	LDR	R0,[PC,#0x2DC]
    40000DFC E5804000	STR	R4,[R0,#0]
    40000E00 EA000001	B	40000E0C
    40000E04 E59F02D4	LDR	R0,[PC,#0x2D4]
    40000E08 E5804000	STR	R4,[R0,#0]
    40000E0C E59F02C8	LDR	R0,[PC,#0x2C8]
    40000E10 E5805000	STR	R5,[R0,#0]
    40000E14 E59F02C4	LDR	R0,[PC,#0x2C4]
    40000E18 E5805000	STR	R5,[R0,#0]
(0228) 	BOUT(currentBias & 0x4000);
    40000E1C E3170C40	TST	R7,#0x4000
    40000E20 0A000002	BEQ	40000E30
    40000E24 E59F02B0	LDR	R0,[PC,#0x2B0]
    40000E28 E5804000	STR	R4,[R0,#0]
    40000E2C EA000001	B	40000E38
    40000E30 E59F02A8	LDR	R0,[PC,#0x2A8]
    40000E34 E5804000	STR	R4,[R0,#0]
    40000E38 E59F029C	LDR	R0,[PC,#0x29C]
    40000E3C E5805000	STR	R5,[R0,#0]
    40000E40 E59F0298	LDR	R0,[PC,#0x298]
    40000E44 E5805000	STR	R5,[R0,#0]
(0229) 	BOUT(currentBias & 0x2000);
    40000E48 E3170D80	TST	R7,#0x2000
    40000E4C 0A000002	BEQ	40000E5C
    40000E50 E59F0284	LDR	R0,[PC,#0x284]
    40000E54 E5804000	STR	R4,[R0,#0]
    40000E58 EA000001	B	40000E64
    40000E5C E59F027C	LDR	R0,[PC,#0x27C]
    40000E60 E5804000	STR	R4,[R0,#0]
    40000E64 E59F0270	LDR	R0,[PC,#0x270]
    40000E68 E5805000	STR	R5,[R0,#0]
    40000E6C E59F026C	LDR	R0,[PC,#0x26C]
    40000E70 E5805000	STR	R5,[R0,#0]
(0230) 	BOUT(currentBias & 0x1000);
    40000E74 E3170D40	TST	R7,#0x1000
    40000E78 0A000002	BEQ	40000E88
    40000E7C E59F0258	LDR	R0,[PC,#0x258]
    40000E80 E5804000	STR	R4,[R0,#0]
    40000E84 EA000001	B	40000E90
    40000E88 E59F0250	LDR	R0,[PC,#0x250]
    40000E8C E5804000	STR	R4,[R0,#0]
    40000E90 E59F0244	LDR	R0,[PC,#0x244]
    40000E94 E5805000	STR	R5,[R0,#0]
    40000E98 E59F0240	LDR	R0,[PC,#0x240]
    40000E9C E5805000	STR	R5,[R0,#0]
(0231) 	
(0232) 	BOUT(currentBias & 0x800);
    40000EA0 E3170E80	TST	R7,#0x800
    40000EA4 0A000002	BEQ	40000EB4
    40000EA8 E59F022C	LDR	R0,[PC,#0x22C]
    40000EAC E5804000	STR	R4,[R0,#0]
    40000EB0 EA000001	B	40000EBC
    40000EB4 E59F0224	LDR	R0,[PC,#0x224]
    40000EB8 E5804000	STR	R4,[R0,#0]
    40000EBC E59F0218	LDR	R0,[PC,#0x218]
    40000EC0 E5805000	STR	R5,[R0,#0]
    40000EC4 E59F0214	LDR	R0,[PC,#0x214]
    40000EC8 E5805000	STR	R5,[R0,#0]
(0233) 	BOUT(currentBias & 0x400);
    40000ECC E3170E40	TST	R7,#0x400
    40000ED0 0A000002	BEQ	40000EE0
    40000ED4 E59F0200	LDR	R0,[PC,#0x200]
    40000ED8 E5804000	STR	R4,[R0,#0]
    40000EDC EA000001	B	40000EE8
    40000EE0 E59F01F8	LDR	R0,[PC,#0x1F8]
    40000EE4 E5804000	STR	R4,[R0,#0]
    40000EE8 E59F01EC	LDR	R0,[PC,#0x1EC]
    40000EEC E5805000	STR	R5,[R0,#0]
    40000EF0 E59F01E8	LDR	R0,[PC,#0x1E8]
    40000EF4 E5805000	STR	R5,[R0,#0]
(0234) 	BOUT(currentBias & 0x200);
    40000EF8 E3170F80	TST	R7,#0x200
    40000EFC 0A000002	BEQ	40000F0C
    40000F00 E59F01D4	LDR	R0,[PC,#0x1D4]
    40000F04 E5804000	STR	R4,[R0,#0]
    40000F08 EA000001	B	40000F14
    40000F0C E59F01CC	LDR	R0,[PC,#0x1CC]
    40000F10 E5804000	STR	R4,[R0,#0]
    40000F14 E59F01C0	LDR	R0,[PC,#0x1C0]
    40000F18 E5805000	STR	R5,[R0,#0]
    40000F1C E59F01BC	LDR	R0,[PC,#0x1BC]
    40000F20 E5805000	STR	R5,[R0,#0]
(0235) 	BOUT(currentBias & 0x100);
    40000F24 E3170F40	TST	R7,#0x100
    40000F28 0A000002	BEQ	40000F38
    40000F2C E59F01A8	LDR	R0,[PC,#0x1A8]
    40000F30 E5804000	STR	R4,[R0,#0]
    40000F34 EA000001	B	40000F40
    40000F38 E59F01A0	LDR	R0,[PC,#0x1A0]
    40000F3C E5804000	STR	R4,[R0,#0]
    40000F40 E59F0194	LDR	R0,[PC,#0x194]
    40000F44 E5805000	STR	R5,[R0,#0]
    40000F48 E59F0190	LDR	R0,[PC,#0x190]
    40000F4C E5805000	STR	R5,[R0,#0]
(0236) 
(0237) 	BOUT(currentBias & 0x80);
    40000F50 E3170080	TST	R7,#0x80
    40000F54 0A000002	BEQ	40000F64
    40000F58 E59F017C	LDR	R0,[PC,#0x17C]
    40000F5C E5804000	STR	R4,[R0,#0]
    40000F60 EA000001	B	40000F6C
    40000F64 E59F0174	LDR	R0,[PC,#0x174]
    40000F68 E5804000	STR	R4,[R0,#0]
    40000F6C E59F0168	LDR	R0,[PC,#0x168]
    40000F70 E5805000	STR	R5,[R0,#0]
    40000F74 E59F0164	LDR	R0,[PC,#0x164]
    40000F78 E5805000	STR	R5,[R0,#0]
(0238) 	BOUT(currentBias & 0x40);
    40000F7C E3170040	TST	R7,#0x40
    40000F80 0A000002	BEQ	40000F90
    40000F84 E59F0150	LDR	R0,[PC,#0x150]
    40000F88 E5804000	STR	R4,[R0,#0]
    40000F8C EA000001	B	40000F98
    40000F90 E59F0148	LDR	R0,[PC,#0x148]
    40000F94 E5804000	STR	R4,[R0,#0]
    40000F98 E59F013C	LDR	R0,[PC,#0x13C]
    40000F9C E5805000	STR	R5,[R0,#0]
    40000FA0 E59F0138	LDR	R0,[PC,#0x138]
    40000FA4 E5805000	STR	R5,[R0,#0]
(0239) 	BOUT(currentBias & 0x20);
    40000FA8 E3170020	TST	R7,#0x20
    40000FAC 0A000002	BEQ	40000FBC
    40000FB0 E59F0124	LDR	R0,[PC,#0x124]
    40000FB4 E5804000	STR	R4,[R0,#0]
    40000FB8 EA000001	B	40000FC4
    40000FBC E59F011C	LDR	R0,[PC,#0x11C]
    40000FC0 E5804000	STR	R4,[R0,#0]
    40000FC4 E59F0110	LDR	R0,[PC,#0x110]
    40000FC8 E5805000	STR	R5,[R0,#0]
    40000FCC E59F010C	LDR	R0,[PC,#0x10C]
    40000FD0 E5805000	STR	R5,[R0,#0]
(0240) 	BOUT(currentBias & 0x10);
    40000FD4 E3170010	TST	R7,#16
    40000FD8 0A000002	BEQ	40000FE8
    40000FDC E59F00F8	LDR	R0,[PC,#0xF8]
    40000FE0 E5804000	STR	R4,[R0,#0]
    40000FE4 EA000001	B	40000FF0
    40000FE8 E59F00F0	LDR	R0,[PC,#0xF0]
    40000FEC E5804000	STR	R4,[R0,#0]
    40000FF0 E59F00E4	LDR	R0,[PC,#0xE4]
    40000FF4 E5805000	STR	R5,[R0,#0]
    40000FF8 E59F00E0	LDR	R0,[PC,#0xE0]
    40000FFC E5805000	STR	R5,[R0,#0]
(0241) 
(0242) 	BOUT(currentBias & 0x8);
    40001000 E3170008	TST	R7,#8
    40001004 0A000002	BEQ	40001014
    40001008 E59F00CC	LDR	R0,[PC,#0xCC]
    4000100C E5804000	STR	R4,[R0,#0]
    40001010 EA000001	B	4000101C
    40001014 E59F00C4	LDR	R0,[PC,#0xC4]
    40001018 E5804000	STR	R4,[R0,#0]
    4000101C E59F00B8	LDR	R0,[PC,#0xB8]
    40001020 E5805000	STR	R5,[R0,#0]
    40001024 E59F00B4	LDR	R0,[PC,#0xB4]
    40001028 E5805000	STR	R5,[R0,#0]
(0243) 	BOUT(currentBias & 0x4);
    4000102C E3170004	TST	R7,#4
    40001030 0A000002	BEQ	40001040
    40001034 E59F00A0	LDR	R0,[PC,#0xA0]
    40001038 E5804000	STR	R4,[R0,#0]
    4000103C EA000001	B	40001048
    40001040 E59F0098	LDR	R0,[PC,#0x98]
    40001044 E5804000	STR	R4,[R0,#0]
    40001048 E59F008C	LDR	R0,[PC,#0x8C]
    4000104C E5805000	STR	R5,[R0,#0]
    40001050 E59F0088	LDR	R0,[PC,#0x88]
    40001054 E5805000	STR	R5,[R0,#0]
(0244) 	BOUT(currentBias & 0x2);
    40001058 E3170002	TST	R7,#2
    4000105C 0A000002	BEQ	4000106C
    40001060 E59F0074	LDR	R0,[PC,#0x74]
    40001064 E5804000	STR	R4,[R0,#0]
    40001068 EA000001	B	40001074
    4000106C E59F006C	LDR	R0,[PC,#0x6C]
    40001070 E5804000	STR	R4,[R0,#0]
    40001074 E59F0060	LDR	R0,[PC,#0x60]
    40001078 E5805000	STR	R5,[R0,#0]
    4000107C E59F005C	LDR	R0,[PC,#0x5C]
    40001080 E5805000	STR	R5,[R0,#0]
(0245) 	BOUT(currentBias & 0x1);
    40001084 E3170001	TST	R7,#1
    40001088 0A000002	BEQ	40001098
    4000108C E59F0048	LDR	R0,[PC,#0x48]
    40001090 E5804000	STR	R4,[R0,#0]
    40001094 EA000001	B	400010A0
    40001098 E59F0040	LDR	R0,[PC,#0x40]
    4000109C E5804000	STR	R4,[R0,#0]
    400010A0 E59F0034	LDR	R0,[PC,#0x34]
    400010A4 E5805000	STR	R5,[R0,#0]
    400010A8 E59F0030	LDR	R0,[PC,#0x30]
    400010AC E5805000	STR	R5,[R0,#0]
    400010B0 E2866001	ADD	R6,R6,#1
    400010B4 E356000C	CMP	R6,#12
    400010B8 3AFFFEF0	BCC	40000C80
(0246) 
(0247) #ifdef NONO
(0248) 	bitIndex = BIT(23);
(0249) 	do {
(0250) 	  if (currentBias & bitIndex) {
(0251) 	    FGPIO_IOSET = PIN_BIAS_DATA;
(0252) 	  } else {
(0253) 	    FGPIO_IOCLR = PIN_BIAS_DATA;
(0254) 	  }
(0255) 	  FGPIO_IOSET = PIN_BIAS_CLOCK;
(0256) 
(0257) 	  FGPIO_IOCLR = PIN_BIAS_CLOCK;
(0258) 
(0259) 	  bitIndex >>= 1;
(0260) 	} while (bitIndex);
(0261) #endif
(0262) 
(0263)   }  // end of biasIndexclocking
(0264) 
(0265) //  FGPIO_IOCLR = PIN_BIAS_DATA;	   // set data pin to low just to have the same output all the time
(0266) 
(0267)   // trigger latch to push bias data to bias generators
(0268)   FGPIO_IOCLR = PIN_BIAS_LATCH | PIN_BIAS_DATA;
    400010BC E3A00DC0	MOV	R0,#0x3000
    400010C0 E59F1018	LDR	R1,[PC,#24]
    400010C4 E5810000	STR	R0,[R1,#0]
(0269)   FGPIO_IOSET = PIN_BIAS_LATCH;
    400010C8 E3A00D40	MOV	R0,#0x1000
    400010CC E59F1008	LDR	R1,[PC,#8]
    400010D0 E5810000	STR	R0,[R1,#0]
    400010D4 E89BA8F0	LDMIA	R11,{R4,R5,R6,R7,R11,R13,PC}
(0270) }
(0271) 
(0272) 
(0273) // *****************************************************************************
(0274) #pragma ramfunc DVS128BiasTransmitBiasValue
(0275) void DVS128BiasTransmitBiasValue(unsigned long biasID) {
_DVS128BiasTransmitBiasValue:
  biasValue            --> R7
  biasID               --> R6
$a:
    400010E4 E1A0C00D	MOV	R12,SP
    400010E8 E92D58F0	STMDB	SP!,{R4,R5,R6,R7,R11,R12,LR}
    400010EC E1A0B00D	MOV	R11,SP
    400010F0 E1A06000	MOV	R6,R0
(0276)   unsigned long biasValue;
(0277)   biasValue = biasMatrix[biasID];
    400010F4 E3A04004	MOV	R4,#4
    400010F8 E0040694	MUL	R4,R4,R6
    400010FC E59F5064	LDR	R5,[PC,#0x64]
    40001100 E7947005	LDR	R7,[R4,R5]
(0278) 
(0279)   dataForTransmission[0] = (((biasValue)    ) & 0x3F) + 32;
    40001104 E207403F	AND	R4,R7,#0x3F
    40001108 E2844020	ADD	R4,R4,#0x20
    4000110C E59F5058	LDR	R5,[PC,#0x58]
    40001110 E5C54000	STRB	R4,[R5,#0]
(0280)   dataForTransmission[1] = (((biasValue)>> 6) & 0x3F) + 32;
    40001114 E1A04327	MOV	R4,R7,LSR #6
    40001118 E204403F	AND	R4,R4,#0x3F
    4000111C E2844020	ADD	R4,R4,#0x20
    40001120 E59F5048	LDR	R5,[PC,#0x48]
    40001124 E5C54000	STRB	R4,[R5,#0]
(0281)   dataForTransmission[2] = (((biasValue)>>12) & 0x3F) + 32;
    40001128 E1A04627	MOV	R4,R7,LSR #12
    4000112C E204403F	AND	R4,R4,#0x3F
    40001130 E2844020	ADD	R4,R4,#0x20
    40001134 E59F5038	LDR	R5,[PC,#0x38]
    40001138 E5C54000	STRB	R4,[R5,#0]
(0282)   dataForTransmission[3] = (((biasValue)>>18) & 0x3F) + 32;
    4000113C E1A04927	MOV	R4,R7,LSR #18
    40001140 E204403F	AND	R4,R4,#0x3F
    40001144 E2844020	ADD	R4,R4,#0x20
    40001148 E59F5028	LDR	R5,[PC,#0x28]
    4000114C E5C54000	STRB	R4,[R5,#0]
(0283)   dataForTransmission[4] = biasID + 32;
    40001150 E2864020	ADD	R4,R6,#0x20
    40001154 E59F5020	LDR	R5,[PC,#0x20]
    40001158 E5C54000	STRB	R4,[R5,#0]
(0284) 
(0285)   transmitSpecialData(5);
    4000115C E3A00005	MOV	R0,#5
    40001160 EBFFFBA7	BL	_transmitSpecialData
    40001164 E89BA8F0	LDMIA	R11,{R4,R5,R6,R7,R11,R13,PC}
FILE: ../../../../../../DOCUME~1/conradt/MYDOCU~1/Projects/DVS128/EDVS128_2106_Rev1.3//UART.c
(0001) #include "EDVS128_2106.h"
(0002) 
(0003) // *****************************************************************************
(0004) extern unsigned long eventBufferWritePointer, eventBufferReadPointer;
(0005) // *****************************************************************************
(0006) extern unsigned char TXBuffer[32];	   // this is the small buffer from mainloop
(0007) extern unsigned long TXBufferIndex;
(0008) 
(0009) extern unsigned long transmitEventRateEnable;
(0010) extern unsigned long enableEventSending;
(0011) 
(0012) extern unsigned long enableAutomaticEventRateControl;
(0013) extern unsigned long requestedEventRate;
(0014) 
(0015) extern unsigned long eDVSDataFormat;
(0016) 
(0017) #ifdef INCLUDE_TRACK_HF_LED
(0018) extern unsigned long transmitTrackHFLED;
(0019) #endif
(0020) #ifdef INCLUDE_PIXEL_CUTOUT_REGION
(0021) extern unsigned long pixelCutoutMinX, pixelCutoutMaxX, pixelCutoutMinY, pixelCutoutMaxY;
(0022) #endif
(0023) 
(0024) unsigned char commandLine[UART_COMMAND_LINE_MAX_LENGTH];
(0025) unsigned long commandLinePointer;
(0026) 
(0027) // *****************************************************************************  
(0028) #define UARTReturn()	   {putchar('\n');}
(0029) 
(0030) // *****************************************************************************
(0031) int putchar(char charToSend) {
$a:
_putchar:
  charToSend           --> R4
    00000DB0 E1A0C00D	MOV	R12,SP
    00000DB4 E92D5010	STMDB	SP!,{R4,R12,LR}
    00000DB8 E1A04000	MOV	R4,R0
(0032)   while (FGPIO_IOPIN & PIN_UART0_RTS) {  // wait while UART buffer is full
    00000DBC E59F102C	LDR	R1,[PC,#0x2C]
    00000DC0 E5911000	LDR	R1,[R1,#0]
    00000DC4 E3110F40	TST	R1,#0x100
    00000DC8 1AFFFFFB	BNE	00000DBC
(0033)   };
(0034)   while ((UART0_LSR & BIT(5))==0) {	  	 // wait until space in UART FIFO
    00000DCC E59F1020	LDR	R1,[PC,#0x20]
    00000DD0 E5911000	LDR	R1,[R1,#0]
    00000DD4 E3110020	TST	R1,#0x20
    00000DD8 0AFFFFFB	BEQ	00000DCC
(0035)   };
(0036)   UART0_THR = charToSend;
    00000DDC E20410FF	AND	R1,R4,#0xFF
    00000DE0 E59F2010	LDR	R2,[PC,#16]
    00000DE4 E5821000	STR	R1,[R2,#0]
(0037)   return(0);
    00000DE8 E3A00000	MOV	R0,#0
    00000DEC E8BDA010	LDMIA	SP!,{R4,R13,PC}
(0038) }
(0039) 
(0040) 
(0041) // *****************************************************************************
(0042) void UART0SetBaudRate(unsigned long baudRate) {
_UART0SetBaudRate:
  baudRate             --> R6
$a:
    00000DFC E1A0C00D	MOV	R12,SP
    00000E00 E92D5870	STMDB	SP!,{R4,R5,R6,R11,R12,LR}
    00000E04 E1A0B00D	MOV	R11,SP
    00000E08 E1A06000	MOV	R6,R0
(0043)   UART0_FDR = 0x10;							// clear fractional baud rate
    00000E0C E3A04010	MOV	R4,#16
    00000E10 E59F5318	LDR	R5,[PC,#0x318]
    00000E14 E5854000	STR	R4,[R5,#0]
(0044)   UART0_LCR = 0x83;							// Enable the divisor
    00000E18 E3A04083	MOV	R4,#0x83
    00000E1C E59F5310	LDR	R5,[PC,#0x310]
    00000E20 E5854000	STR	R4,[R5,#0]
(0045)   UART0_DLM = 0x00;							// Divisor latch MSB (for baud rates < 4800) 
    00000E24 E3A04000	MOV	R4,#0
    00000E28 E59F5308	LDR	R5,[PC,#0x308]
    00000E2C E5854000	STR	R4,[R5,#0]
(0046) 
(0047)   switch (baudRate) {
    00000E30 E3560BE1	CMP	R6,#0x38400
    00000E34 0A00007C	BEQ	0000102C
    00000E38 E3560BE1	CMP	R6,#0x38400
    00000E3C CA000026	BGT	00000EDC
    00000E40 E3560C96	CMP	R6,#0x9600
    00000E44 0A00005B	BEQ	00000FB8
    00000E48 E3560C96	CMP	R6,#0x9600
    00000E4C CA00000F	BGT	00000E90
    00000E50 E3560C4B	CMP	R6,#0x4B00
    00000E54 0A00004C	BEQ	00000F8C
    00000E58 E3560C4B	CMP	R6,#0x4B00
    00000E5C CA000006	BGT	00000E7C
    00000E60 E3560001	CMP	R6,#1
    00000E64 0A00008D	BEQ	000010A0
    00000E68 E3560002	CMP	R6,#2
    00000E6C 0A00009D	BEQ	000010E8
    00000E70 E3560004	CMP	R6,#4
    00000E74 0A00009F	BEQ	000010F8
    00000E78 EA0000A2	B	00001108
    00000E7C E59F42B8	LDR	R4,[PC,#0x2B8]
    00000E80 E1A05006	MOV	R5,R6
    00000E84 E1550004	CMP	R5,R4
    00000E88 0A000046	BEQ	00000FA8
    00000E8C EA00009D	B	00001108
    00000E90 E59F52A8	LDR	R5,[PC,#0x2A8]
    00000E94 E1560005	CMP	R6,R5
    00000E98 0A000054	BEQ	00000FF0
    00000E9C E1560005	CMP	R6,R5
    00000EA0 CA000003	BGT	00000EB4
    00000EA4 E1A04006	MOV	R4,R6
    00000EA8 E3540CE1	CMP	R4,#0xE100
    00000EAC 0A000048	BEQ	00000FD4
    00000EB0 EA000094	B	00001108
    00000EB4 E59F5288	LDR	R5,[PC,#0x288]
    00000EB8 E1560005	CMP	R6,R5
    00000EBC 0A00004F	BEQ	00001000
    00000EC0 E1560005	CMP	R6,R5
    00000EC4 BA00008F	BLT	00001108
    00000EC8 E59F4278	LDR	R4,[PC,#0x278]
    00000ECC E1A05006	MOV	R5,R6
    00000ED0 E1550004	CMP	R5,R4
    00000ED4 0A000050	BEQ	0000101C
    00000ED8 EA00008A	B	00001108
    00000EDC E59F5268	LDR	R5,[PC,#0x268]
    00000EE0 E1560005	CMP	R6,R5
    00000EE4 0A00006D	BEQ	000010A0
    00000EE8 E1560005	CMP	R6,R5
    00000EEC CA000012	BGT	00000F3C
    00000EF0 E59F5258	LDR	R5,[PC,#0x258]
    00000EF4 E1560005	CMP	R6,R5
    00000EF8 0A000056	BEQ	00001058
    00000EFC E1560005	CMP	R6,R5
    00000F00 CA000004	BGT	00000F18
    00000F04 E59F4248	LDR	R4,[PC,#0x248]
    00000F08 E1A05006	MOV	R5,R6
    00000F0C E1550004	CMP	R5,R4
    00000F10 0A00004C	BEQ	00001048
    00000F14 EA00007B	B	00001108
    00000F18 E59F5238	LDR	R5,[PC,#0x238]
    00000F1C E1560005	CMP	R6,R5
    00000F20 0A000053	BEQ	00001074
    00000F24 E1560005	CMP	R6,R5
    00000F28 BA000076	BLT	00001108
    00000F2C E1A04006	MOV	R4,R6
    00000F30 E3540AE1	CMP	R4,#0xE1000
    00000F34 0A000052	BEQ	00001084
    00000F38 EA000072	B	00001108
    00000F3C E59F5218	LDR	R5,[PC,#0x218]
    00000F40 E1560005	CMP	R6,R5
    00000F44 0A000060	BEQ	000010CC
    00000F48 E1560005	CMP	R6,R5
    00000F4C CA000004	BGT	00000F64
    00000F50 E59F4208	LDR	R4,[PC,#0x208]
    00000F54 E1A05006	MOV	R5,R6
    00000F58 E1550004	CMP	R5,R4
    00000F5C 0A000053	BEQ	000010B0
    00000F60 EA000068	B	00001108
    00000F64 E59F51F8	LDR	R5,[PC,#0x1F8]
    00000F68 E1560005	CMP	R6,R5
    00000F6C 0A00005D	BEQ	000010E8
    00000F70 E1560005	CMP	R6,R5
    00000F74 BA000063	BLT	00001108
    00000F78 E59F41E8	LDR	R4,[PC,#0x1E8]
    00000F7C E1A05006	MOV	R5,R6
    00000F80 E1550004	CMP	R5,R4
    00000F84 0A00005B	BEQ	000010F8
    00000F88 EA00005E	B	00001108
(0048) #if PLL_CLOCK == 112						   // all baud rates calculated for 112MHz
(0049) 	case ((unsigned long)  460800): UART0_DLL = (0x0C); UART0_FDR = (((0x0F)<<4) | 0x04); break;
(0050) 	case ((unsigned long)  500000): UART0_DLL = (0x0E); break;
(0051) 	case ((unsigned long)  921600): UART0_DLL = (0x06); UART0_FDR = (((0x0F)<<4) | 0x04); break;
(0052) 	case ((unsigned long)       1):
(0053) 	case ((unsigned long) 1000000): UART0_DLL = (0x07); break;
(0054) 	case ((unsigned long)       2):
(0055) 	case ((unsigned long) 2000000): UART0_DLL = (0x03); UART0_FDR = (((0x06)<<4) | 0x01); break;
(0056) #endif
(0057) 
(0058) #if PLL_CLOCK == 96						   // all baud rates calculated for 96MHz
(0059) 	case ((unsigned long)  460800): UART0_DLL = (0x0D); break;
(0060) 	case ((unsigned long)  500000): UART0_DLL = (0x0C); break;
(0061) 	case ((unsigned long)  921600): UART0_DLL = (0x06); UART0_FDR = (((0x0C)<<4) | 0x01); break;
(0062) 	case ((unsigned long)       1):
(0063) 	case ((unsigned long) 1000000): UART0_DLL = (0x06); break;
(0064) 	case ((unsigned long)       2):
(0065) 	case ((unsigned long) 2000000): UART0_DLL = (0x03); break;
(0066) 	case ((unsigned long)       3):
(0067) 	case ((unsigned long) 3000000): UART0_DLL = (0x02); break;
(0068) #endif
(0069) 
(0070) #if PLL_CLOCK == 80						   // all baud rates calculated for 80MHz
(0071) 	case ((unsigned long)  460800): UART0_DLL = (0x08); UART0_FDR = (((0x0E)<<4) | 0x05); break;
(0072) 	case ((unsigned long)  500000): UART0_DLL = (0x0A); break;
(0073) 	case ((unsigned long)  921600): UART0_DLL = (0x04); UART0_FDR = (((0x0E)<<4) | 0x05); break;
(0074) 	case ((unsigned long)       1):
(0075) 	case ((unsigned long) 1000000): UART0_DLL = (0x05); break;
(0076) #endif
(0077) 
(0078) #if PLL_CLOCK == 64			  			   // all baud rates calculated for 64MHz
(0079) 	case ((unsigned long)   19200): UART0_DLL = (0x7D); UART0_FDR = (((0x03)<<4) | 0x02); break;
    00000F8C E3A0407D	MOV	R4,#0x7D
    00000F90 E59F51D4	LDR	R5,[PC,#0x1D4]
    00000F94 E5854000	STR	R4,[R5,#0]
    00000F98 E3A04032	MOV	R4,#0x32
    00000F9C E59F518C	LDR	R5,[PC,#0x18C]
    00000FA0 E5854000	STR	R4,[R5,#0]
    00000FA4 EA00005D	B	00001120
(0080)     case ((unsigned long)   31250): UART0_DLL = (0x80); break;
    00000FA8 E3A04080	MOV	R4,#0x80
    00000FAC E59F51B8	LDR	R5,[PC,#0x1B8]
    00000FB0 E5854000	STR	R4,[R5,#0]
    00000FB4 EA000059	B	00001120
(0081) 	case ((unsigned long)   38400): UART0_DLL = (0x32); UART0_FDR = (((0x0C)<<4) | 0x0D); break;
    00000FB8 E3A04032	MOV	R4,#0x32
    00000FBC E59F51A8	LDR	R5,[PC,#0x1A8]
    00000FC0 E5854000	STR	R4,[R5,#0]
    00000FC4 E3A040CD	MOV	R4,#0xCD
    00000FC8 E59F5160	LDR	R5,[PC,#0x160]
    00000FCC E5854000	STR	R4,[R5,#0]
    00000FD0 EA000052	B	00001120
(0082) 	case ((unsigned long)   57600): UART0_DLL = (0x36); UART0_FDR = (((0x07)<<4) | 0x02); break;
    00000FD4 E3A04036	MOV	R4,#0x36
    00000FD8 E59F518C	LDR	R5,[PC,#0x18C]
    00000FDC E5854000	STR	R4,[R5,#0]
    00000FE0 E3A04072	MOV	R4,#0x72
    00000FE4 E59F5144	LDR	R5,[PC,#0x144]
    00000FE8 E5854000	STR	R4,[R5,#0]
    00000FEC EA00004B	B	00001120
(0083)     case ((unsigned long)   62500): UART0_DLL = (0x40); break;
    00000FF0 E3A04040	MOV	R4,#0x40
    00000FF4 E59F5170	LDR	R5,[PC,#0x170]
    00000FF8 E5854000	STR	R4,[R5,#0]
    00000FFC EA000047	B	00001120
(0084) 	case ((unsigned long)  115200): UART0_DLL = (0x1B); UART0_FDR = (((0x07)<<4) | 0x02); break;
    00001000 E3A0401B	MOV	R4,#27
    00001004 E59F5160	LDR	R5,[PC,#0x160]
    00001008 E5854000	STR	R4,[R5,#0]
    0000100C E3A04072	MOV	R4,#0x72
    00001010 E59F5118	LDR	R5,[PC,#0x118]
    00001014 E5854000	STR	R4,[R5,#0]
    00001018 EA000040	B	00001120
(0085) 	case ((unsigned long)  125000): UART0_DLL = (0x20);	break;
    0000101C E3A04020	MOV	R4,#0x20
    00001020 E59F5144	LDR	R5,[PC,#0x144]
    00001024 E5854000	STR	R4,[R5,#0]
    00001028 EA00003C	B	00001120
(0086) 	case ((unsigned long)  230400): UART0_DLL = (0x09); UART0_FDR = (((0x0E)<<4) | 0x0D); break;
    0000102C E3A04009	MOV	R4,#9
    00001030 E59F5134	LDR	R5,[PC,#0x134]
    00001034 E5854000	STR	R4,[R5,#0]
    00001038 E3A040ED	MOV	R4,#0xED
    0000103C E59F50EC	LDR	R5,[PC,#0xEC]
    00001040 E5854000	STR	R4,[R5,#0]
    00001044 EA000035	B	00001120
(0087)     case ((unsigned long)  250000): UART0_DLL = (0x10); break;
    00001048 E3A04010	MOV	R4,#16
    0000104C E59F5118	LDR	R5,[PC,#0x118]
    00001050 E5854000	STR	R4,[R5,#0]
    00001054 EA000031	B	00001120
(0088) 	case ((unsigned long)  460800): UART0_DLL = (0x08); UART0_FDR = (((0x0C)<<4) | 0x01); break;
    00001058 E3A04008	MOV	R4,#8
    0000105C E59F5108	LDR	R5,[PC,#0x108]
    00001060 E5854000	STR	R4,[R5,#0]
    00001064 E3A040C1	MOV	R4,#0xC1
    00001068 E59F50C0	LDR	R5,[PC,#0xC0]
    0000106C E5854000	STR	R4,[R5,#0]
    00001070 EA00002A	B	00001120
(0089) 	case ((unsigned long)  500000): UART0_DLL = (0x08); break;
    00001074 E3A04008	MOV	R4,#8
    00001078 E59F50EC	LDR	R5,[PC,#0xEC]
    0000107C E5854000	STR	R4,[R5,#0]
    00001080 EA000026	B	00001120
(0090) 	case ((unsigned long)  921600): UART0_DLL = (0x04); UART0_FDR = (((0x0C)<<4) | 0x01); break;
    00001084 E3A04004	MOV	R4,#4
    00001088 E59F50DC	LDR	R5,[PC,#0xDC]
    0000108C E5854000	STR	R4,[R5,#0]
    00001090 E3A040C1	MOV	R4,#0xC1
    00001094 E59F5094	LDR	R5,[PC,#0x94]
    00001098 E5854000	STR	R4,[R5,#0]
    0000109C EA00001F	B	00001120
(0091) 	case ((unsigned long)       1):
(0092) 	case ((unsigned long) 1000000): UART0_DLL = (0x04); break;
    000010A0 E3A04004	MOV	R4,#4
    000010A4 E59F50C0	LDR	R5,[PC,#0xC0]
    000010A8 E5854000	STR	R4,[R5,#0]
    000010AC EA00001B	B	00001120
(0093) 	case ((unsigned long) 1500000): UART0_DLL = (0x02); UART0_FDR = (((0x03)<<4) | 0x01); break;
    000010B0 E3A04002	MOV	R4,#2
    000010B4 E59F50B0	LDR	R5,[PC,#0xB0]
    000010B8 E5854000	STR	R4,[R5,#0]
    000010BC E3A04031	MOV	R4,#0x31
    000010C0 E59F5068	LDR	R5,[PC,#0x68]
    000010C4 E5854000	STR	R4,[R5,#0]
    000010C8 EA000014	B	00001120
(0094) 	case ((unsigned long) 1843200): UART0_DLL = (0x02); UART0_FDR = (((0x0C)<<4) | 0x01); break; //
    000010CC E3A04002	MOV	R4,#2
    000010D0 E59F5094	LDR	R5,[PC,#0x94]
    000010D4 E5854000	STR	R4,[R5,#0]
    000010D8 E3A040C1	MOV	R4,#0xC1
    000010DC E59F504C	LDR	R5,[PC,#0x4C]
    000010E0 E5854000	STR	R4,[R5,#0]
    000010E4 EA00000D	B	00001120
(0095) 	case ((unsigned long)       2):
(0096) 	case ((unsigned long) 2000000): UART0_DLL = (0x02);	break;
    000010E8 E3A04002	MOV	R4,#2
    000010EC E59F5078	LDR	R5,[PC,#0x78]
    000010F0 E5854000	STR	R4,[R5,#0]
    000010F4 EA000009	B	00001120
(0097) 	case ((unsigned long)       4):
(0098) 	case ((unsigned long) 4000000): UART0_DLL = (0x01);	break;
    000010F8 E3A04001	MOV	R4,#1
    000010FC E59F5068	LDR	R5,[PC,#0x68]
    00001100 E5854000	STR	R4,[R5,#0]
    00001104 EA000005	B	00001120
(0099) #endif
(0100) 
(0101) #if PLL_CLOCK == 32			  			   // all baud rates calculated for 32MHz
(0102) 	case ((unsigned long) 1000000): UART0_DLL = (0x02); break;
(0103) 	case ((unsigned long) 2000000): UART0_DLL = (0x01);	break;
(0104) #endif
(0105) 
(0106) 	default:
(0107)   			UART0_LCR = 0x03;				// Close divisor before printing!
    00001108 E3A04003	MOV	R4,#3
    0000110C E59F5020	LDR	R5,[PC,#0x20]
    00001110 E5854000	STR	R4,[R5,#0]
(0108) 			printf("unknown/unsupported baud rate!\n");
    00001114 E59F0054	LDR	R0,[PC,#0x54]
    00001118 EB000665	BL	_printf
(0109) 			return;
    0000111C EA000002	B	0000112C
(0110)   }
(0111) 
(0112)   UART0_LCR = 0x03;							// Close divisor
    00001120 E3A04003	MOV	R4,#3
    00001124 E59F5008	LDR	R5,[PC,#8]
    00001128 E5854000	STR	R4,[R5,#0]
    0000112C E89BA870	LDMIA	R11,{R4,R5,R6,R11,R13,PC}
(0113) }
(0114) 
(0115) // *****************************************************************************
(0116) void UARTInit(void) {
_UARTInit:
$a:
    00001174 E1A0C00D	MOV	R12,SP
    00001178 E92D5870	STMDB	SP!,{R4,R5,R6,R11,R12,LR}
    0000117C E1A0B00D	MOV	R11,SP
(0117) 
(0118)   UART0SetBaudRate(BAUD_RATE_DEFAULT);
Cidata_length:
    00001180 E59F008C	LDR	R0,[PC,#0x8C]
    00001184 EBFFFF1C	BL	_UART0SetBaudRate
(0119) 
(0120)   UART0_IER = 0x00;							// disable RS232 interrupts
    00001188 E3A04000	MOV	R4,#0
    0000118C E59F5084	LDR	R5,[PC,#0x84]
    00001190 E5854000	STR	R4,[R5,#0]
(0121)   UART0_FCR = 0x01;							// enable the fifos
    00001194 E3A04001	MOV	R4,#1
    00001198 E59F507C	LDR	R5,[PC,#0x7C]
    0000119C E5854000	STR	R4,[R5,#0]
(0122)   UART0_FCR = 0x01 | 0x06;					// Reset FIFOs
    000011A0 E3A04007	MOV	R4,#7
    000011A4 E59F5070	LDR	R5,[PC,#0x70]
    000011A8 E5854000	STR	R4,[R5,#0]
(0123) 
(0124)   UART0_TER = 0x80;							// Enable Transmitter (default)
    000011AC E3A04080	MOV	R4,#0x80
    000011B0 E59F5068	LDR	R5,[PC,#0x68]
    000011B4 E5854000	STR	R4,[R5,#0]
(0125) 
(0126)   PCB_PINSEL0 |= BIT(2) | BIT(0);	  		// enable TxD0, RxD0 output pins
    000011B8 E59F4064	LDR	R4,[PC,#0x64]
    000011BC E5945000	LDR	R5,[R4,#0]
    000011C0 E3855005	ORR	R5,#5
    000011C4 E5845000	STR	R5,[R4,#0]
(0127) 
(0128) // *****************************************************************************  
(0129)   FGPIO_IOCLR  = PIN_UART0_CTS;				// set CTS pin to permanent low
    000011C8 E3A04F80	MOV	R4,#0x200
    000011CC E59F5054	LDR	R5,[PC,#0x54]
    000011D0 E5854000	STR	R4,[R5,#0]
(0130)   FGPIO_IODIR |= PIN_UART0_CTS;
    000011D4 E59F4050	LDR	R4,[PC,#0x50]
    000011D8 E5945000	LDR	R5,[R4,#0]
    000011DC E3855F80	ORR	R5,#0x200
    000011E0 E5845000	STR	R5,[R4,#0]
(0131) 
(0132)   FGPIO_IODIR &= ~(PIN_UART0_RTS);			// set RTS to input
    000011E4 E59F4040	LDR	R4,[PC,#0x40]
    000011E8 E3E05F40	MVN	R5,R0,#0x100
    000011EC E5946000	LDR	R6,[R4,#0]
    000011F0 E0065005	AND	R5,R6,R5
    000011F4 E5845000	STR	R5,[R4,#0]
(0133) 
(0134) // *****************************************************************************  
(0135)   commandLine[0] = 0;
    000011F8 E3A04000	MOV	R4,#0
    000011FC E59F502C	LDR	R5,[PC,#0x2C]
    00001200 E5C54000	STRB	R4,[R5,#0]
(0136)   commandLinePointer = 0;
    00001204 E3A04000	MOV	R4,#0
    00001208 E59F5024	LDR	R5,[PC,#0x24]
    0000120C E5854000	STR	R4,[R5,#0]
    00001210 E89BA870	LDMIA	R11,{R4,R5,R6,R11,R13,PC}
(0137) }
(0138) 
(0139) 
(0140) // *****************************************************************************  
(0141) void UARTShowVersion(void) {
$a:
_UARTShowVersion:
    00001238 E1A0C00D	MOV	R12,SP
    0000123C E92D5810	STMDB	SP!,{R4,R11,R12,LR}
    00001240 E1A0B00D	MOV	R11,SP
(0142)   UARTReturn();
    00001244 E3A0000A	MOV	R0,#10
    00001248 EBFFFED8	BL	_putchar
(0143)   printf("EDVS128_LPC2106, V");
    0000124C E59F0064	LDR	R0,[PC,#0x64]
    00001250 EB000617	BL	_printf
(0144)   printf(SOFTWARE_VERSION);
    00001254 E59F0060	LDR	R0,[PC,#0x60]
    00001258 EB000615	BL	_printf
(0145)   printf(": ");
    0000125C E59F005C	LDR	R0,[PC,#0x5C]
    00001260 EB000613	BL	_printf
(0146)   printf(__DATE__);
    00001264 E59F0058	LDR	R0,[PC,#0x58]
    00001268 EB000611	BL	_printf
(0147)   printf(", ");
    0000126C E59F0054	LDR	R0,[PC,#0x54]
    00001270 EB00060F	BL	_printf
(0148)   printf(__TIME__);
    00001274 E59F0050	LDR	R0,[PC,#0x50]
    00001278 EB00060D	BL	_printf
(0149)   UARTReturn();
    0000127C E3A0000A	MOV	R0,#10
    00001280 EBFFFECA	BL	_putchar
(0150) 
(0151)   printf("System Clock: %2dMHz / %d -> %dns event time resolution",
    00001284 E59F0044	LDR	R0,[PC,#0x44]
    00001288 E3A04040	MOV	R4,#0x40
    0000128C E1A01004	MOV	R1,R4
    00001290 E1A02004	MOV	R2,R4
    00001294 E3A03FFA	MOV	R3,#0x3E8
    00001298 EB000605	BL	_printf
(0152)   				 			   	 	   			  PLL_CLOCK,
(0153) 												  (1<<TIMESTAMP_SHIFTBITS),
(0154)   				 			   	 	   			  1000*(1<<TIMESTAMP_SHIFTBITS) / (PLL_CLOCK));
(0155)   UARTReturn();
    0000129C E3A0000A	MOV	R0,#10
    000012A0 EBFFFEC2	BL	_putchar
(0156) 
(0157)   printf("Modules: ");
    000012A4 E59F0028	LDR	R0,[PC,#0x28]
    000012A8 EB000601	BL	_printf
(0158) 
(0159) #ifdef TIME_OPTIMIZED
(0160)   printf(" TIME_OPTIMIZED");
(0161) #endif
(0162) 
(0163) #ifdef INCLUDE_TRACK_HF_LED
(0164)   printf(" TRACK_HF_LED");
(0165) #endif
(0166) 
(0167) #ifdef INCLUDE_PIXEL_CUTOUT_REGION
(0168)   printf(" PIXEL_CUTOUT_REGION");
(0169) #endif
(0170) 
(0171) #ifdef INCLUDE_PWM246
(0172)   printf(" PWM246-");
(0173)   #ifdef INCLUDE_PWM246_ENABLE_PWM2_OUT
(0174)     printf("2");
(0175)   #endif
(0176)   #ifdef INCLUDE_PWM246_ENABLE_PWM4_OUT
(0177)     printf("4");
(0178)   #endif
(0179)   #ifdef INCLUDE_PWM246_ENABLE_PWM6_OUT
(0180)     printf("6");
(0181)   #endif
(0182) #endif
(0183) 
(0184) #ifdef USE_ALTERNATE_RTS_CTS
(0185)   printf(" ALT-RTS/CTS");
(0186) #endif
(0187) 
(0188) #ifdef INCLUDE_MARK_BUFFEROVERFLOW
(0189)   printf(" MARK_BUFFEROVERFLOW");
(0190) #endif
(0191) 
(0192) #ifdef INCLUDE_EVENTRATE_CONTROL
(0193)   printf(" AUTOMATIC_EVENT_RATE_CONTROL");
(0194) #endif
(0195) 
(0196) #ifdef INCLUDE_UART_SPEEDTEST
(0197)   printf(" UART SPEEDTEST");
(0198) #endif
(0199) 
(0200)   UARTReturn();
    000012AC E3A0000A	MOV	R0,#10
    000012B0 EBFFFEBE	BL	_putchar
    000012B4 E89BA810	LDMIA	R11,{R4,R11,R13,PC}
(0201) }
(0202) 
(0203) // *****************************************************************************  
(0204) void UARTShowUsage(void) {
_UARTShowUsage:
$a:
    000012D8 E92D4000	STMDB	SP!,{LR}
(0205)   
(0206)   UARTShowVersion();
    000012DC EBFFFFD5	BL	_UARTShowVersion
(0207) 
(0208)   UARTReturn();
    000012E0 E3A0000A	MOV	R0,#10
    000012E4 EBFFFEB1	BL	_putchar
(0209)   printf("Supported Commands:\n");
    000012E8 E59F009C	LDR	R0,[PC,#0x9C]
    000012EC EB0005F0	BL	_printf
(0210)   UARTReturn();
    000012F0 E3A0000A	MOV	R0,#10
    000012F4 EBFFFEAD	BL	_putchar
(0211) 
(0212)   printf(" E+/-       - enable/disable event sending\n");
    000012F8 E59F0090	LDR	R0,[PC,#0x90]
    000012FC EB0005EC	BL	_printf
(0213)   printf(" !Ex        - specify event data format, ??E to list options\n");
    00001300 E59F008C	LDR	R0,[PC,#0x8C]
    00001304 EB0005EA	BL	_printf
(0214) #ifdef INCLUDE_PIXEL_CUTOUT_REGION
(0215)   printf(" !Cxl,yl<,xr,yr> - specify a rectangular cutout region\n");
(0216) #endif
(0217)   UARTReturn();
    00001308 E3A0000A	MOV	R0,#10
    0000130C EBFFFEA7	BL	_putchar
(0218) 
(0219)   printf(" !Bx=y      - set bias register x[0..11] to value y[0..0xFFFFFF]\n");
    00001310 E59F0080	LDR	R0,[PC,#0x80]
    00001314 EB0005E6	BL	_printf
(0220)   printf(" !BF        - send bias settings to DVS\n");
    00001318 E59F007C	LDR	R0,[PC,#0x7C]
    0000131C EB0005E4	BL	_printf
(0221)   printf(" !BDx       - select and flush default bias set (default: set 0)\n");
    00001320 E59F0078	LDR	R0,[PC,#0x78]
    00001324 EB0005E2	BL	_printf
(0222)   printf(" ?Bx        - get bias register x current value\n");
    00001328 E59F0074	LDR	R0,[PC,#0x74]
    0000132C EB0005E0	BL	_printf
(0223)   printf(" ?B#x       - get bias register x encoded within event stream\n");
    00001330 E59F0070	LDR	R0,[PC,#0x70]
    00001334 EB0005DE	BL	_printf
(0224)   UARTReturn();
    00001338 E3A0000A	MOV	R0,#10
    0000133C EBFFFE9B	BL	_putchar
(0225) 
(0226)   
(0227)   
(0228)   printf(" !R+/-      - transmit event rate on/off\n");
    00001340 E59F0064	LDR	R0,[PC,#0x64]
    00001344 EB0005DA	BL	_printf
(0229) #ifdef INCLUDE_TRACK_HF_LED
(0230)   printf(" !T+/-      - enable/disable tracking of high-frequency blinkind LEDs\n");
(0231) #ifdef INCLUDE_TRACK_HF_LED_SERVO_OUT
(0232)   printf(" !TS+/-     - enable/disable servo following of tracking target\n");
(0233) #endif
(0234)   UARTReturn();
(0235) #endif
(0236)   
(0237)   printf(" 0,1,2      - LED off/on/blinking\n");
    00001348 E59F0060	LDR	R0,[PC,#0x60]
    0000134C EB0005D8	BL	_printf
(0238)   printf(" !S=x       - set baudrate to x\n");
    00001350 E59F005C	LDR	R0,[PC,#0x5C]
    00001354 EB0005D6	BL	_printf
(0239) #ifdef INCLUDE_PWM246
(0240)   printf(" !PWMC=x    - set PWM cycle length to x us\n");
(0241)   printf(" !PWMS<x>=y - set PWM signal x [0..2] length to y us\n");
(0242) #endif
(0243)   UARTReturn();
    00001358 E3A0000A	MOV	R0,#10
    0000135C EBFFFE93	BL	_putchar
(0244) 
(0245)   printf(" R          - reset board\n");
    00001360 E59F0050	LDR	R0,[PC,#0x50]
    00001364 EB0005D2	BL	_printf
(0246)   printf(" P          - enter reprogramming mode\n");
    00001368 E59F004C	LDR	R0,[PC,#0x4C]
    0000136C EB0005D0	BL	_printf
(0247)   UARTReturn();
    00001370 E3A0000A	MOV	R0,#10
    00001374 EBFFFE8D	BL	_putchar
(0248) 
(0249)   printf(" ??         - display help\n");
    00001378 E59F0040	LDR	R0,[PC,#0x40]
    0000137C EB0005CC	BL	_printf
(0250)   UARTReturn();
    00001380 E3A0000A	MOV	R0,#10
    00001384 EBFFFE89	BL	_putchar
    00001388 E8BD8000	LDMIA	SP!,{PC}
(0251) }
(0252) 
(0253) void UARTShowEventDataOptions(void) {
_UARTShowEventDataOptions:
$a:
    000013C4 E92D4000	STMDB	SP!,{LR}
(0254)   printf(" !E0   - 2 bytes per event binary 0yyyyyyy.pxxxxxxx (default)\n");
    000013C8 E59F0064	LDR	R0,[PC,#0x64]
    000013CC EB0005B8	BL	_printf
(0255)   printf(" !E1   - 4 bytes per event (as above followed by 16bit timestamp 1us res)\n");
    000013D0 E59F0060	LDR	R0,[PC,#0x60]
    000013D4 EB0005B6	BL	_printf
(0256)   printf(" !E2   - 5 bytes per event (as above followed by 24bit timestamp 1us res)\n");
    000013D8 E59F005C	LDR	R0,[PC,#0x5C]
    000013DC EB0005B4	BL	_printf
(0257)   printf(" !E3   - 6 bytes per event (as above followed by 32bit timestamp 1/64M res)\n");
    000013E0 E59F0058	LDR	R0,[PC,#0x58]
    000013E4 EB0005B2	BL	_printf
(0258)   UARTReturn();
    000013E8 E3A0000A	MOV	R0,#10
    000013EC EBFFFE6F	BL	_putchar
(0259) 
(0260)   printf(" !E20  - 4 bytes per event, hex encoded\n");
    000013F0 E59F004C	LDR	R0,[PC,#0x4C]
    000013F4 EB0005AE	BL	_printf
(0261)   printf(" !E21  - 8 bytes per event+timestamp, hex encoded \n");
    000013F8 E59F0048	LDR	R0,[PC,#0x48]
    000013FC EB0005AC	BL	_printf
(0262)   printf(" !E22  - 5 bytes per event, hex encoded; new-line\n");
    00001400 E59F0044	LDR	R0,[PC,#0x44]
    00001404 EB0005AA	BL	_printf
(0263)   printf(" !E23  - 8 bytes per event+timestamp, hex encoded; new-line\n");
    00001408 E59F0040	LDR	R0,[PC,#0x40]
    0000140C EB0005A8	BL	_printf
(0264)   UARTReturn();
    00001410 E3A0000A	MOV	R0,#10
    00001414 EBFFFE65	BL	_putchar
(0265) 
(0266)   printf(" !E30  - 10 bytes per event, ASCII <1p> <3y> <3x>; new-line\n");
    00001418 E59F0034	LDR	R0,[PC,#0x34]
    0000141C EB0005A4	BL	_printf
(0267)   printf(" !E31  - 10 bytes per event+ts 1us res, ASCII <1p> <3y> <3x> <8ts> <nl>\n");
    00001420 E59F0030	LDR	R0,[PC,#0x30]
    00001424 EB0005A2	BL	_printf
(0268)   printf(" !E32  - 10 bytes per event+ts 1/64M res, ASCII <1p> <3y> <3x> <10ts> <nl>\n");
    00001428 E59F002C	LDR	R0,[PC,#0x2C]
    0000142C EB0005A0	BL	_printf
    00001430 E8BD8000	LDMIA	SP!,{PC}
(0269) }
(0270) 
(0271) // *****************************************************************************
(0272) unsigned long parseULong(char **c) {
$a:
_parseULong:
  ul                   --> R4
  c                    --> R5
    00001460 E1A0C00D	MOV	R12,SP
    00001464 E92D5830	STMDB	SP!,{R4,R5,R11,R12,LR}
    00001468 E1A0B00D	MOV	R11,SP
    0000146C E1A05000	MOV	R5,R0
(0273)   unsigned long ul=0;
    00001470 E3A04000	MOV	R4,#0
    00001474 EA000009	B	000014A0
(0274)   while (((**c)>='0') && ((**c)<='9')) {
(0275)     ul = 10*ul;
    00001478 E3A0100A	MOV	R1,#10
    0000147C E0010491	MUL	R1,R1,R4
    00001480 E1A04001	MOV	R4,R1
(0276) 	ul += ((**c)-'0');
    00001484 E5951000	LDR	R1,[R5,#0]
    00001488 E5D11000	LDRB	R1,[R1,#0]
    0000148C E2411030	SUB	R1,R1,#0x30
    00001490 E0844001	ADD	R4,R4,R1
(0277) 	(*(c))++;
    00001494 E5951000	LDR	R1,[R5,#0]
    00001498 E2811001	ADD	R1,R1,#1
    0000149C E5851000	STR	R1,[R5,#0]
    000014A0 E5951000	LDR	R1,[R5,#0]
    000014A4 E5D11000	LDRB	R1,[R1,#0]
    000014A8 E3510030	CMP	R1,#0x30
    000014AC BA000001	BLT	000014B8
    000014B0 E3510039	CMP	R1,#0x39
    000014B4 DAFFFFEF	BLE	00001478
(0278)   }
(0279)   return(ul);
    000014B8 E1A00004	MOV	R0,R4
    000014BC E89BA830	LDMIA	R11,{R4,R5,R11,R13,PC}
(0280) }
(0281) 
(0282) // *****************************************************************************
(0283) // * ** parseGetCommand ** */
(0284) // *****************************************************************************
(0285) void UARTParseGetCommand(void) {
_UARTParseGetCommand:
  c                    --> R11,+4
  biasID               --> R5
    000014C0 E1A0C00D	MOV	R12,SP
    000014C4 E92D5830	STMDB	SP!,{R4,R5,R11,R12,LR}
    000014C8 E1A0B00D	MOV	R11,SP
    000014CC E24DD004	SUB	SP,SP,#4
(0286) 
(0287)   switch (commandLine[1]) {
    000014D0 E59F412C	LDR	R4,[PC,#0x12C]
    000014D4 E5D45000	LDRB	R5,[R4,#0]
    000014D8 E3550045	CMP	R5,#0x45
    000014DC 0A000034	BEQ	000015B4
    000014E0 E3550045	CMP	R5,#0x45
    000014E4 CA000004	BGT	000014FC
    000014E8 E355003F	CMP	R5,#0x3F
    000014EC 0A000035	BEQ	000015C8
    000014F0 E3550042	CMP	R5,#0x42
    000014F4 0A000005	BEQ	00001510
    000014F8 EA00003E	B	000015F8
    000014FC E3550062	CMP	R5,#0x62
    00001500 0A000002	BEQ	00001510
    00001504 E3550065	CMP	R5,#0x65
    00001508 0A000029	BEQ	000015B4
    0000150C EA000039	B	000015F8
(0288) 
(0289)     case 'B':
(0290) 	case 'b': {	   									 			// request bias value
(0291) 	            unsigned char *c;
(0292) 			    long biasID;
(0293) 			    
(0294) 				if (commandLine[2] == '#') {	   	// send bias value as encoded event
    00001510 E59F40F0	LDR	R4,[PC,#0xF0]
    00001514 E5D44000	LDRB	R4,[R4,#0]
    00001518 E3540023	CMP	R4,#0x23
    0000151C 1A000006	BNE	0000153C
(0295) 			      c = commandLine+3;
    00001520 E59F40E4	LDR	R4,[PC,#0xE4]
    00001524 E50B4004	STR	R4,[R11,#-4]
(0296)                   DVS128BiasTransmitBiasValue(parseULong(&c));
    00001528 E24B0004	SUB	R0,R11,#4
    0000152C EBFFFFCB	BL	_parseULong
    00001530 E1A04000	MOV	R4,R0
    00001534 EB00070D	BL	arm_to_ramfunc_branch_veneer__DVS128BiasTransmitBiasValue
(0297) 			      break;
    00001538 EA000030	B	00001600
(0298) 			    }
(0299) 
(0300) 			    c = commandLine+2;					// send bias value as deciman value
    0000153C E59F40C4	LDR	R4,[PC,#0xC4]
    00001540 E50B4004	STR	R4,[R11,#-4]
(0301) 			    if ((*c == 'A') || (*c == 'a')) {
    00001544 E51B4004	LDR	R4,[R11,#-4]
    00001548 E5D44000	LDRB	R4,[R4,#0]
    0000154C E3540041	CMP	R4,#0x41
    00001550 0A000001	BEQ	0000155C
    00001554 E3540061	CMP	R4,#0x61
    00001558 1A00000B	BNE	0000158C
(0302) 			      for (biasID=0; biasID<12; biasID++) {
    0000155C E3A05000	MOV	R5,#0
(0303) 			        printf ("-B%d=%d\n", biasID, DVS128BiasGet(biasID));
    00001560 E1A00005	MOV	R0,R5
    00001564 EBFFFD14	BL	_DVS128BiasGet
    00001568 E1A04000	MOV	R4,R0
    0000156C E59F009C	LDR	R0,[PC,#0x9C]
    00001570 E1A01005	MOV	R1,R5
    00001574 E1A02004	MOV	R2,R4
    00001578 EB00054D	BL	_printf
    0000157C E2855001	ADD	R5,R5,#1
    00001580 E355000C	CMP	R5,#12
    00001584 BAFFFFF5	BLT	00001560
(0304) 			      }
(0305) 				  break;
    00001588 EA00001C	B	00001600
(0306) 			    }
(0307) 			   
(0308) 			    biasID = parseULong(&c);
    0000158C E24B0004	SUB	R0,R11,#4
    00001590 EBFFFFB2	BL	_parseULong
    00001594 E1A05000	MOV	R5,R0
(0309) 			    printf ("-B%d=%d\n", biasID, DVS128BiasGet(biasID));
    00001598 EBFFFD07	BL	_DVS128BiasGet
    0000159C E1A04000	MOV	R4,R0
    000015A0 E59F0068	LDR	R0,[PC,#0x68]
    000015A4 E1A01005	MOV	R1,R5
    000015A8 E1A02004	MOV	R2,R4
    000015AC EB000540	BL	_printf
(0310) 		        break;
    000015B0 EA000012	B	00001600
(0311) 		      }
(0312) 
(0313) #ifdef INCLUDE_PIXEL_CUTOUT_REGION
(0314) 	case 'C':
(0315) 	case 'c':
(0316) 			  printf("-C%d,%d,%d,%d\n", pixelCutoutMinX, pixelCutoutMinY, pixelCutoutMaxX, pixelCutoutMaxY);
(0317) 			  break;
(0318) #endif
(0319) 
(0320) 	case 'E':
(0321) 	case 'e':
(0322) 	          printf("-E%d\n", eDVSDataFormat);
    000015B4 E59F0058	LDR	R0,[PC,#0x58]
    000015B8 E59F4058	LDR	R4,[PC,#0x58]
    000015BC E5941000	LDR	R1,[R4,#0]
    000015C0 EB00053B	BL	_printf
(0323) 		 	  break;
    000015C4 EA00000D	B	00001600
(0324) 
(0325) #ifdef INCLUDE_PWM246
(0326) 	case 'P':
(0327) 	case 'p':
(0328) 		 	  {
(0329) 			    if ((commandLine[4] == 'C') || (commandLine[4] == 'c')) {
(0330) 				  printf("-PWMC=%d\n", PWM246GetCycle());
(0331) 				  break;
(0332) 			    }
(0333) 			    if ((commandLine[4] == 'S') || (commandLine[4] == 's')) {
(0334) 			      printf("-PWMS=%d,%d,%d\n", PWM246GetSignal(0), PWM246GetSignal(1), PWM246GetSignal(2));
(0335) 				  break;
(0336) 			    }
(0337) 			    printf("Get PWM246: parsing error\n");
(0338) 			    break;
(0339) 			  }
(0340) #endif
(0341) 
(0342) 	case '?':
(0343) 	          if (((commandLine[2]) == 'e') || ((commandLine[2]) == 'E')) {
    000015C8 E59F4038	LDR	R4,[PC,#0x38]
    000015CC E5D44000	LDRB	R4,[R4,#0]
    000015D0 E3540065	CMP	R4,#0x65
    000015D4 0A000003	BEQ	000015E8
    000015D8 E59F4028	LDR	R4,[PC,#0x28]
    000015DC E5D44000	LDRB	R4,[R4,#0]
    000015E0 E3540045	CMP	R4,#0x45
    000015E4 1A000001	BNE	000015F0
(0344) 			    UARTShowEventDataOptions();
    000015E8 EBFFFF75	BL	_UARTShowEventDataOptions
(0345) 			    break;
    000015EC EA000003	B	00001600
(0346) 			  }
(0347) 		 	  UARTShowUsage();
    000015F0 EBFFFF38	BL	_UARTShowUsage
(0348) 			  break;
    000015F4 EA000001	B	00001600
(0349) 
(0350) 	default:
(0351) 			  printf("Get: parsing error\n");
    000015F8 E59F001C	LDR	R0,[PC,#28]
    000015FC EB00052C	BL	_printf
(0352)   }
(0353)   return;
    00001600 E89BA830	LDMIA	R11,{R4,R5,R11,R13,PC}
(0354) }
(0355) 
(0356) // *****************************************************************************
(0357) // * ** parseSetCommand ** */
(0358) // *****************************************************************************
(0359) void UARTParseSetCommand(void) {
$a:
_UARTParseSetCommand:
  c                    --> R11,+4
  baudRate             --> R6
  c                    --> R11,+4
  biasValue            --> R7
  biasID               --> R6
  c                    --> R11,+4
    00001620 E1A0C00D	MOV	R12,SP
    00001624 E92D58F0	STMDB	SP!,{R4,R5,R6,R7,R11,R12,LR}
    00001628 E1A0B00D	MOV	R11,SP
    0000162C E24DD004	SUB	SP,SP,#4
(0360)   switch (commandLine[1]) {
    00001630 E59F423C	LDR	R4,[PC,#0x23C]
    00001634 E5D46000	LDRB	R6,[R4,#0]
    00001638 E3560052	CMP	R6,#0x52
    0000163C 0A000071	BEQ	00001808
    00001640 E3560053	CMP	R6,#0x53
    00001644 0A000078	BEQ	0000182C
    00001648 E3560053	CMP	R6,#0x53
    0000164C CA000004	BGT	00001664
    00001650 E3560042	CMP	R6,#0x42
    00001654 0A00000D	BEQ	00001690
    00001658 E3560045	CMP	R6,#0x45
    0000165C 0A000057	BEQ	000017C0
    00001660 EA000080	B	00001868
    00001664 E3560062	CMP	R6,#0x62
    00001668 0A000008	BEQ	00001690
    0000166C E3560065	CMP	R6,#0x65
    00001670 0A000052	BEQ	000017C0
    00001674 E3560062	CMP	R6,#0x62
    00001678 BA00007A	BLT	00001868
    0000167C E3560072	CMP	R6,#0x72
    00001680 0A000060	BEQ	00001808
    00001684 E3560073	CMP	R6,#0x73
    00001688 0A000067	BEQ	0000182C
    0000168C EA000075	B	00001868
(0361) 
(0362) 	case 'B':
(0363) 	case 'b': {
(0364) 	            unsigned char *c;
(0365) 			    long biasID, biasValue;
(0366) //  unsigned long t0, t1;
(0367) 
(0368) 			    if ((commandLine[2] == 'F') || (commandLine[2] == 'f')) {	   	// flush bias values to DVS chip
    00001690 E59F41E0	LDR	R4,[PC,#0x1E0]
    00001694 E5D44000	LDRB	R4,[R4,#0]
    00001698 E3540046	CMP	R4,#0x46
    0000169C 0A000003	BEQ	000016B0
    000016A0 E59F41D0	LDR	R4,[PC,#0x1D0]
    000016A4 E5D44000	LDRB	R4,[R4,#0]
    000016A8 E3540066	CMP	R4,#0x66
    000016AC 1A000007	BNE	000016D0
(0369)                   if (enableEventSending==0) {
    000016B0 E59F41C4	LDR	R4,[PC,#0x1C4]
    000016B4 E5944000	LDR	R4,[R4,#0]
    000016B8 E3540000	CMP	R4,#0
    000016BC 1A000001	BNE	000016C8
(0370) 				    printf("-BF\n");
    000016C0 E59F01B8	LDR	R0,[PC,#0x1B8]
    000016C4 EB0004FA	BL	_printf
(0371) 				  }
(0372) //  t0 = T1_TC;
(0373) 				  DVS128BiasFlush();
    000016C8 EB0006AA	BL	00003178
(0374) //  t1 = T1_TC;
(0375) //  printf("td = %ld\n", (t1-t0));
(0376) 				  break;
    000016CC EA000067	B	00001870
(0377) 				}
(0378) 
(0379) 			    if ((commandLine[2] == 'D') || (commandLine[2] == 'd')) {	   	// load and flush default bias set
    000016D0 E59F41A0	LDR	R4,[PC,#0x1A0]
    000016D4 E5D44000	LDRB	R4,[R4,#0]
    000016D8 E3540044	CMP	R4,#0x44
    000016DC 0A000003	BEQ	000016F0
    000016E0 E59F4190	LDR	R4,[PC,#0x190]
    000016E4 E5D44000	LDRB	R4,[R4,#0]
    000016E8 E3540064	CMP	R4,#0x64
    000016EC 1A000019	BNE	00001758
(0380) 				  if ((commandLine[3]>'0') && (commandLine[3]<'9')) {
    000016F0 E59F418C	LDR	R4,[PC,#0x18C]
    000016F4 E5D44000	LDRB	R4,[R4,#0]
    000016F8 E3540030	CMP	R4,#0x30
    000016FC DA000012	BLE	0000174C
    00001700 E59F417C	LDR	R4,[PC,#0x17C]
    00001704 E5D44000	LDRB	R4,[R4,#0]
    00001708 E3540039	CMP	R4,#0x39
    0000170C AA00000E	BGE	0000174C
(0381)                     if (enableEventSending==0) {
    00001710 E59F4164	LDR	R4,[PC,#0x164]
    00001714 E5944000	LDR	R4,[R4,#0]
    00001718 E3540000	CMP	R4,#0
    0000171C 1A000003	BNE	00001730
(0382) 				      printf("-BD%c\n", commandLine[3]);
    00001720 E59F0160	LDR	R0,[PC,#0x160]
    00001724 E59F4158	LDR	R4,[PC,#0x158]
    00001728 E5D41000	LDRB	R1,[R4,#0]
    0000172C EB0004E0	BL	_printf
(0383) 				    }
(0384) 					DVS128BiasLoadDefaultSet(commandLine[3]-'0');
    00001730 E59F414C	LDR	R4,[PC,#0x14C]
    00001734 E5D44000	LDRB	R4,[R4,#0]
    00001738 E2444030	SUB	R4,R4,#0x30
    0000173C E1A00004	MOV	R0,R4
    00001740 EBFFFCB0	BL	_DVS128BiasLoadDefaultSet
(0385) 					DVS128BiasFlush();
    00001744 EB00068D	BL	00003180
(0386) 				  } else {
    00001748 EA000048	B	00001870
(0387) 					printf("Select default bias set: parsing error\n");
    0000174C E59F0138	LDR	R0,[PC,#0x138]
    00001750 EB0004D7	BL	_printf
(0388) 				  }
(0389) 				  break;
    00001754 EA000045	B	00001870
(0390) 				}
(0391) 
(0392) 				c = commandLine+2;
    00001758 E59F4118	LDR	R4,[PC,#0x118]
    0000175C E50B4004	STR	R4,[R11,#-4]
(0393) 			    biasID = parseULong(&c);
    00001760 E24B0004	SUB	R0,R11,#4
    00001764 EBFFFF3D	BL	_parseULong
    00001768 E1A06000	MOV	R6,R0
(0394) 			    c++;
    0000176C E51B4004	LDR	R4,[R11,#-4]
    00001770 E2844001	ADD	R4,R4,#1
    00001774 E50B4004	STR	R4,[R11,#-4]
(0395) 			    biasValue = parseULong(&c);
    00001778 E24B0004	SUB	R0,R11,#4
    0000177C EBFFFF37	BL	_parseULong
    00001780 E1A07000	MOV	R7,R0
(0396) 			    DVS128BiasSet(biasID, biasValue);
    00001784 E1A00006	MOV	R0,R6
    00001788 E1A01007	MOV	R1,R7
    0000178C EBFFFC7D	BL	_DVS128BiasSet
(0397) 			    if (enableEventSending==0) {
    00001790 E59F40E4	LDR	R4,[PC,#0xE4]
    00001794 E5944000	LDR	R4,[R4,#0]
    00001798 E3540000	CMP	R4,#0
    0000179C 1A000033	BNE	00001870
(0398) 			      printf ("-B%d=%d\n", biasID, DVS128BiasGet(biasID));
    000017A0 E1A00006	MOV	R0,R6
    000017A4 EBFFFC84	BL	_DVS128BiasGet
    000017A8 E1A04000	MOV	R4,R0
    000017AC E59F00DC	LDR	R0,[PC,#0xDC]
    000017B0 E1A01006	MOV	R1,R6
    000017B4 E1A02004	MOV	R2,R4
    000017B8 EB0004BD	BL	_printf
(0399) 			    }
(0400) 			    break;
    000017BC EA00002B	B	00001870
(0401) 			  }
(0402) 
(0403) #ifdef INCLUDE_PIXEL_CUTOUT_REGION
(0404) 	case 'C':
(0405) 	case 'c':
(0406) 		 	  {
(0407) 			    long n;
(0408) 			    n = sscanf(commandLine+2, "%ld,%ld,%ld,%ld", &pixelCutoutMinX, &pixelCutoutMinY, &pixelCutoutMaxX, &pixelCutoutMaxY);
(0409) 			    if (n==2) { 		  	 	 // only two numbers specified --> assume we only want one pixel
(0410) 			      pixelCutoutMaxX = pixelCutoutMinX;
(0411) 			      pixelCutoutMaxY = pixelCutoutMinY;
(0412) 			      printf("-C%d,%d,%d,%d\n", pixelCutoutMinX, pixelCutoutMinY, pixelCutoutMaxX, pixelCutoutMaxY);
(0413) 			      break;
(0414) 			    }
(0415) 			    if (n==4) { 		  	 	 // correct parsing
(0416) 			      printf("-C%d,%d,%d,%d\n", pixelCutoutMinX, pixelCutoutMinY, pixelCutoutMaxX, pixelCutoutMaxY);
(0417) 			      break;
(0418) 				}
(0419) 				printf("Set pixel cutout: parsing error\n");
(0420) 			    break;
(0421) 			  }
(0422) #endif
(0423) 
(0424) 	case 'E':
(0425) 	case 'e': {
(0426) 		 	    unsigned char *c;
(0427) 			    c = commandLine+2;
    000017C0 E59F40B0	LDR	R4,[PC,#0xB0]
    000017C4 E50B4004	STR	R4,[R11,#-4]
(0428) 			    if ((*c) == '=') c++;   		   		// skip '=' if entered
    000017C8 E51B4004	LDR	R4,[R11,#-4]
    000017CC E5D44000	LDRB	R4,[R4,#0]
    000017D0 E354003D	CMP	R4,#0x3D
    000017D4 1A000002	BNE	000017E4
    000017D8 E51B4004	LDR	R4,[R11,#-4]
    000017DC E2844001	ADD	R4,R4,#1
    000017E0 E50B4004	STR	R4,[R11,#-4]
(0429) 			    eDVSDataFormat = parseULong(&c);
    000017E4 E24B0004	SUB	R0,R11,#4
    000017E8 EBFFFF1C	BL	_parseULong
    000017EC E59F50A0	LDR	R5,[PC,#0xA0]
    000017F0 E5850000	STR	R0,[R5,#0]
(0430) 			    printf("-E%d\n", eDVSDataFormat);
    000017F4 E59F009C	LDR	R0,[PC,#0x9C]
    000017F8 E59F4094	LDR	R4,[PC,#0x94]
    000017FC E5941000	LDR	R1,[R4,#0]
    00001800 EB0004AB	BL	_printf
(0431) 		 	    break;
    00001804 EA000019	B	00001870
(0432) 			  }
(0433) 
(0434) #ifdef INCLUDE_PWM246
(0435) 	case 'P':
(0436) 	case 'p':
(0437) 		 	  {
(0438) 	            unsigned char *c;
(0439) 				unsigned long id, l;
(0440) 			    if (((commandLine[4]) == 'C') || ((commandLine[4]) == 'c')) {
(0441) 			      c = commandLine+6;
(0442) 			      l = parseULong(&c);
(0443) 			   	  PWM246SetCycle(l);
(0444) 			      if (enableEventSending==0) {
(0445) 			   	    printf("-PWMC=%d\n", PWM246GetCycle());
(0446) 				  }
(0447) 				  break;
(0448) 			    }
(0449) 			    if (((commandLine[4]) == 'S') || ((commandLine[4]) == 's')) {
(0450) 				  id = commandLine[5]-'0';
(0451) 			      c = commandLine+7;
(0452) 			      l = parseULong(&c);
(0453) 				  PWM246SetSignal(id, l);
(0454) 			      if (enableEventSending==0) {
(0455) 			   	    printf("-PWMS%d=%d\n", id, PWM246GetSignal(id));
(0456) 				  }
(0457) 				  break;
(0458) 				}
(0459) 				printf("Set PWM246: parsing error\n");
(0460) 			    break;
(0461) 			 }
(0462) #endif
(0463) 
(0464) 	case 'R':
(0465) 	case 'r':
(0466) 		 	  transmitEventRateEnable = (commandLine[2] == '+') ? 1 : 0;
    00001808 E59F4068	LDR	R4,[PC,#0x68]
    0000180C E5D44000	LDRB	R4,[R4,#0]
    00001810 E354002B	CMP	R4,#0x2B
    00001814 03A06001	MOVEQ	R6,#1
    00001818 13A06000	MOVNE	R6,#0
    0000181C E1A04006	MOV	R4,R6
    00001820 E59F5074	LDR	R5,[PC,#0x74]
    00001824 E5854000	STR	R4,[R5,#0]
(0467) 			  break;
    00001828 EA000010	B	00001870
(0468) 
(0469) 	case 'S':
(0470) 	case 's': {
(0471) 	            unsigned char *c;
(0472) 			    long baudRate;
(0473) 			    c = commandLine+3;
    0000182C E59F4050	LDR	R4,[PC,#0x50]
    00001830 E50B4004	STR	R4,[R11,#-4]
(0474) 			    baudRate = parseULong(&c);
    00001834 E24B0004	SUB	R0,R11,#4
    00001838 EBFFFF08	BL	_parseULong
    0000183C E1A06000	MOV	R6,R0
(0475) 			    printf("Switching Baud Rate to %d Baud!\n", baudRate);
.symtab_end:
.symtab_length:
    00001840 E59F0058	LDR	R0,[PC,#0x58]
    00001844 E1A01006	MOV	R1,R6
    00001848 EB000499	BL	_printf
(0476)                 while ((UART0_LSR & BIT(6))==0) {};		   // wait for UART to finish data transfer
    0000184C E59F4050	LDR	R4,[PC,#0x50]
    00001850 E5944000	LDR	R4,[R4,#0]
    00001854 E3140040	TST	R4,#0x40
    00001858 0AFFFFFB	BEQ	0000184C
(0477) 			    UART0SetBaudRate(baudRate);
    0000185C E1A00006	MOV	R0,R6
    00001860 EBFFFD65	BL	_UART0SetBaudRate
(0478) 			    break;
    00001864 EA000001	B	00001870
(0479) 			  }
(0480) 
(0481) #ifdef INCLUDE_TRACK_HF_LED
(0482)     case 'T':
(0483)     case 't':
(0484) #ifdef INCLUDE_TRACK_HF_LED_SERVO_OUT
(0485) 		 	  if ((commandLine[2]=='s') || (commandLine[2]=='S')){
(0486) 		 	    if (commandLine[3]=='0') {
(0487) 			      EP_TrackHFLServoResetPosition();
(0488) 				  printf ("-TS0\n");
(0489) 				} else {
(0490) 				  if (commandLine[3]=='+') {
(0491) 			        EP_TrackHFLServoSetEnabled(TRUE);
(0492) 				    printf ("-TS+\n");
(0493) 			      } else {
(0494) 			        EP_TrackHFLServoSetEnabled(FALSE);
(0495) 				    printf ("-TS-\n");
(0496) 				  }
(0497) 				}
(0498) 				break;
(0499) 			  }
(0500) #endif
(0501) 			  
(0502) 		 	  if (commandLine[2]=='+') {
(0503) 			    EP_TrackHFLSetOutputEnabled(TRUE);
(0504) 				printf ("-T+\n");
(0505) 			  } else {
(0506) 			    EP_TrackHFLSetOutputEnabled(FALSE);
(0507) 				printf ("-T-\n");
(0508) 			  }
(0509) 			  break;
(0510) #endif
(0511) 
(0512) 	default:
(0513) 			  printf("Set: parsing error\n");
    00001868 E59F0038	LDR	R0,[PC,#0x38]
    0000186C EB000490	BL	_printf
(0514)   }
(0515)   return;
    00001870 E89BA8F0	LDMIA	R11,{R4,R5,R6,R7,R11,R13,PC}
(0516) }
(0517) 
(0518) // *****************************************************************************
(0519) // * ** parseRS232CommandLine ** */
(0520) // *****************************************************************************
(0521) void parseRS232CommandLine(void) {
_parseRS232CommandLine:
$a:
    000018AC E1A0C00D	MOV	R12,SP
    000018B0 E92D5830	STMDB	SP!,{R4,R5,R11,R12,LR}
    000018B4 E1A0B00D	MOV	R11,SP
(0522) 
(0523)   switch (commandLine[0]) {
    000018B8 E59F40F8	LDR	R4,[PC,#0xF8]
    000018BC E5D45000	LDRB	R5,[R4,#0]
    000018C0 E3550045	CMP	R5,#0x45
    000018C4 0A00002E	BEQ	00001984
    000018C8 E3550045	CMP	R5,#0x45
    000018CC CA00000D	BGT	00001908
    000018D0 E3550030	CMP	R5,#0x30
    000018D4 0A000021	BEQ	00001960
    000018D8 E3550031	CMP	R5,#0x31
    000018DC 0A000022	BEQ	0000196C
    000018E0 E3550032	CMP	R5,#0x32
    000018E4 0A000023	BEQ	00001978
    000018E8 E3550032	CMP	R5,#0x32
    000018EC CA000002	BGT	000018FC
    000018F0 E3550021	CMP	R5,#0x21
    000018F4 0A000013	BEQ	00001948
    000018F8 EA00002B	B	000019AC
    000018FC E355003F	CMP	R5,#0x3F
    00001900 0A00000E	BEQ	00001940
    00001904 EA000028	B	000019AC
    00001908 E3550065	CMP	R5,#0x65
    0000190C 0A00001C	BEQ	00001984
    00001910 E3550065	CMP	R5,#0x65
    00001914 CA000004	BGT	0000192C
    00001918 E3550050	CMP	R5,#0x50
    0000191C 0A00000B	BEQ	00001950
    00001920 E3550052	CMP	R5,#0x52
    00001924 0A00000B	BEQ	00001958
    00001928 EA00001F	B	000019AC
    0000192C E3550070	CMP	R5,#0x70
    00001930 0A000006	BEQ	00001950
    00001934 E3550072	CMP	R5,#0x72
    00001938 0A000006	BEQ	00001958
    0000193C EA00001A	B	000019AC
(0524) 		case '?': UARTParseGetCommand();	break;
    00001940 EBFFFEDE	BL	_UARTParseGetCommand
    00001944 EA00001A	B	000019B4
(0525) 		case '!': UARTParseSetCommand();	break;
    00001948 EBFFFF34	BL	_UARTParseSetCommand
    0000194C EA000018	B	000019B4
(0526) 
(0527) 	    case 'P':
(0528) 	    case 'p': enterReprogrammingMode();	break;
    00001950 EBFFFAD0	BL	_enterReprogrammingMode
    00001954 EA000016	B	000019B4
(0529) 	    case 'R':
(0530) 		case 'r': resetDevice();			break;
    00001958 EBFFFABD	BL	_resetDevice
    0000195C EA000014	B	000019B4
(0531) 
(0532) 		case '0': LEDSetOff();      		break;
    00001960 E3A00000	MOV	R0,#0
    00001964 EBFFFA9D	BL	_LEDSetState
    00001968 EA000011	B	000019B4
(0533) 		case '1': LEDSetOn();       		break;
    0000196C E3A00001	MOV	R0,#1
    00001970 EBFFFA9A	BL	_LEDSetState
    00001974 EA00000E	B	000019B4
(0534) 		case '2': LEDSetBlinking(); 		break;
    00001978 E3E00000	MVN	R0,R0,#0
    0000197C EBFFFA97	BL	_LEDSetState
    00001980 EA00000B	B	000019B4
(0535) 		
(0536) 		case 'E':
(0537) 		case 'e':
(0538) 			 	  if (commandLine[1] == '+') {
    00001984 E59F4030	LDR	R4,[PC,#0x30]
    00001988 E5D44000	LDRB	R4,[R4,#0]
    0000198C E354002B	CMP	R4,#0x2B
    00001990 1A000002	BNE	000019A0
(0539) 				    DVS128FetchEventsEnable(TRUE);
    00001994 E3A00001	MOV	R0,#1
    00001998 EBFFFBE7	BL	_DVS128FetchEventsEnable
(0540) 				  } else {
    0000199C EA000004	B	000019B4
(0541) 				    DVS128FetchEventsEnable(FALSE);
    000019A0 E3A00000	MOV	R0,#0
    000019A4 EBFFFBE4	BL	_DVS128FetchEventsEnable
(0542) 				  }
(0543) 				  break;
    000019A8 EA000001	B	000019B4
(0544) 
(0545) #ifdef INCLUDE_UART_SPEEDTEST
(0546) 		case 'S':
(0547) 		case 's':
(0548) 			     {
(0549) 				   long n;
(0550) 				   long e;
(0551) 				   printf("-tStart-\n");
(0552) 				   for (n=0; n<61; n++) {			// send 1'998'848 events of 2 bytes each (= 3'997'696 bytes = 10sec @ 4mbit)
(0553) 				     for (e=0; e<0x8000; e++) {
(0554) 
(0555) 					   while ((FGPIO_IOPIN & PIN_UART0_RTS) !=0 ) {}			// no rts stop signal
(0556) 					   while ((UART0_LSR & BIT(5))==0) {}						// uart FIFO space to send data?
(0557)     				   UART0_THR = (e>>8) & 0xFF;
(0558) 					   while ((UART0_LSR & BIT(5))==0) {}						// uart FIFO space to send data?
(0559)     				   UART0_THR = (e)    & 0xFF;
(0560) 
(0561) 					 }
(0562) 				   }
(0563) 				   printf("-tStop-\n");
(0564) 				 }
(0565) 				 break;
(0566) #endif
(0567) 
(0568) 	    default:
(0569) 				  printf("?\n\r");
    000019AC E59F000C	LDR	R0,[PC,#12]
    000019B0 EB00043F	BL	_printf
(0570)   }
(0571)   return;
    000019B4 E89BA830	LDMIA	R11,{R4,R5,R11,R13,PC}
(0572) }
(0573) 
(0574) 
(0575) // *****************************************************************************
(0576) // * ** RS232ParseNewChar ** */
(0577) // *****************************************************************************
(0578) void UARTParseNewChar(unsigned char newChar) {
$a:
_UARTParseNewChar:
  n                    --> R7
  newChar              --> R8
    000019C4 E1A0C00D	MOV	R12,SP
    000019C8 E92D59F0	STMDB	SP!,{R4,R5,R6,R7,R8,R11,R12,LR}
    000019CC E1A0B00D	MOV	R11,SP
    000019D0 E1A08000	MOV	R8,R0
(0579) 
(0580)   switch(newChar) {
    000019D4 E20870FF	AND	R7,R8,#0xFF
    000019D8 E3570008	CMP	R7,#8
    000019DC 0A000004	BEQ	000019F4
    000019E0 E357000A	CMP	R7,#10
    000019E4 0A000014	BEQ	00001A3C
    000019E8 E357000D	CMP	R7,#13
    000019EC 0A000012	BEQ	00001A3C
    000019F0 EA000025	B	00001A8C
(0581) 	case 8:			// backspace
(0582) 	  if (commandLinePointer > 0) {
    000019F4 E59F4120	LDR	R4,[PC,#0x120]
    000019F8 E5944000	LDR	R4,[R4,#0]
    000019FC E3540000	CMP	R4,#0
    00001A00 0A000044	BEQ	00001B18
(0583) 	    commandLinePointer--;
    00001A04 E59F4110	LDR	R4,[PC,#0x110]
    00001A08 E5945000	LDR	R5,[R4,#0]
    00001A0C E2455001	SUB	R5,R5,#1
    00001A10 E5845000	STR	R5,[R4,#0]
(0584)           if (enableEventSending==0) {
    00001A14 E59F4104	LDR	R4,[PC,#0x104]
    00001A18 E5944000	LDR	R4,[R4,#0]
    00001A1C E3540000	CMP	R4,#0
    00001A20 1A00003C	BNE	00001B18
(0585) 		    printf("%c %c", 8, 8);
    00001A24 E59F00F8	LDR	R0,[PC,#0xF8]
    00001A28 E3A04008	MOV	R4,#8
    00001A2C E1A01004	MOV	R1,R4
    00001A30 E1A02004	MOV	R2,R4
    00001A34 EB00041E	BL	_printf
(0586) 		  }
(0587) 	  }
(0588)       break;
    00001A38 EA000036	B	00001B18
(0589) 
(0590) 	case 10:
(0591) 	case 13:
(0592)       if (enableEventSending==0) {
    00001A3C E59F40DC	LDR	R4,[PC,#0xDC]
    00001A40 E5944000	LDR	R4,[R4,#0]
    00001A44 E3540000	CMP	R4,#0
    00001A48 1A000001	BNE	00001A54
(0593) 	    UARTReturn();
    00001A4C E3A0000A	MOV	R0,#10
    00001A50 EBFFFCD6	BL	_putchar
(0594)       }
(0595)       if (commandLinePointer > 0) {
    00001A54 E59F40C0	LDR	R4,[PC,#0xC0]
    00001A58 E5944000	LDR	R4,[R4,#0]
    00001A5C E3540000	CMP	R4,#0
    00001A60 0A00002C	BEQ	00001B18
(0596)         commandLine[commandLinePointer]=0;
    00001A64 E59F40B0	LDR	R4,[PC,#0xB0]
    00001A68 E5944000	LDR	R4,[R4,#0]
    00001A6C E59F50B4	LDR	R5,[PC,#0xB4]
    00001A70 E3A06000	MOV	R6,#0
    00001A74 E7C46005	STRB	R6,[R4,R5]
(0597)         parseRS232CommandLine();
    00001A78 EBFFFF8B	BL	_parseRS232CommandLine
(0598) 	    commandLinePointer=0;
    00001A7C E3A04000	MOV	R4,#0
    00001A80 E59F5094	LDR	R5,[PC,#0x94]
    00001A84 E5854000	STR	R4,[R5,#0]
(0599)       }
(0600) 	  break;
    00001A88 EA000022	B	00001B18
(0601) 
(0602) 	default:
(0603)       if (commandLinePointer < (UART_COMMAND_LINE_MAX_LENGTH-2)) {
    00001A8C E59F4088	LDR	R4,[PC,#0x88]
    00001A90 E5944000	LDR	R4,[R4,#0]
    00001A94 E354005E	CMP	R4,#0x5E
    00001A98 2A00000E	BCS	00001AD8
(0604)         if (enableEventSending==0) {
    00001A9C E59F407C	LDR	R4,[PC,#0x7C]
    00001AA0 E5944000	LDR	R4,[R4,#0]
    00001AA4 E3540000	CMP	R4,#0
    00001AA8 1A000001	BNE	00001AB4
(0605)           putchar(newChar);	  		   	// echo to indicate char arrived
    00001AAC E20800FF	AND	R0,R8,#0xFF
    00001AB0 EBFFFCBE	BL	_putchar
(0606)         }
(0607) 		commandLine[commandLinePointer] = newChar;
    00001AB4 E59F4060	LDR	R4,[PC,#0x60]
    00001AB8 E5944000	LDR	R4,[R4,#0]
    00001ABC E59F5064	LDR	R5,[PC,#0x64]
    00001AC0 E7C48005	STRB	R8,[R4,R5]
(0608)         commandLinePointer++;
    00001AC4 E59F4050	LDR	R4,[PC,#0x50]
    00001AC8 E5945000	LDR	R5,[R4,#0]
    00001ACC E2855001	ADD	R5,R5,#1
    00001AD0 E5845000	STR	R5,[R4,#0]
(0609)       } else {
    00001AD4 EA00000F	B	00001B18
(0610) 		long n;
(0611) 		printf("Reached cmd line length, resetting into bootloader mode!\n");
    00001AD8 E59F004C	LDR	R0,[PC,#0x4C]
    00001ADC EB0003F4	BL	_printf
(0612) 		for (n=0; n<100; n++) {
    00001AE0 E3A07000	MOV	R7,#0
(0613) 		  delayMS(20);
    00001AE4 E3A00014	MOV	R0,#20
    00001AE8 EBFFFA2F	BL	_delayMS
(0614) 		  if (UART0_LSR & 0x01) {				   // char arrived?
    00001AEC E59F403C	LDR	R4,[PC,#0x3C]
    00001AF0 E5944000	LDR	R4,[R4,#0]
    00001AF4 E3140001	TST	R4,#1
    00001AF8 0A000002	BEQ	00001B08
(0615)             newChar = UART0_RBR;
    00001AFC E59F4030	LDR	R4,[PC,#0x30]
    00001B00 E5944000	LDR	R4,[R4,#0]
    00001B04 E1A08004	MOV	R8,R4
    00001B08 E2877001	ADD	R7,R7,#1
    00001B0C E3570064	CMP	R7,#0x64
    00001B10 BAFFFFF3	BLT	00001AE4
(0616) 		  }
(0617) 		}
(0618) 		enterReprogrammingMode();
    00001B14 EBFFFA5F	BL	_enterReprogrammingMode
(0619) 	  }
(0620)   }  // end of switch  
FILE: <library>
    00001B18 E89BA9F0	LDMIA	R11,{R4,R5,R6,R7,R8,R11,R13,PC}
$va:
arm_to_ramfunc_branch_veneer__mainloop:
    00003160 E51FF004	LDR	PC,[PC,#-4]
    00003164 400000E8	ANDMI	R0,R0,R8,ROR #1
$va:
arm_to_ramfunc_branch_veneer__DVS128BiasFlush:
    00003168 E51FF004	LDR	PC,[PC,#-4]
    0000316C 40000C64	ANDMI	R0,R0,R4,ROR #24
$va:
arm_to_ramfunc_branch_veneer__DVS128BiasTransmitBiasValue:
    00003170 E51FF004	LDR	PC,[PC,#-4]
    00003174 400010E4	ANDMI	R1,R0,R4,ROR #1
$va:
    00003178 E51FF004	LDR	PC,[PC,#-4]
    0000317C 40000C64	ANDMI	R0,R0,R4,ROR #24
$va:
    00003180 E51FF004	LDR	PC,[PC,#-4]
    00003184 40000C64	ANDMI	R0,R0,R4,ROR #24
$va:
ramfunc_to_arm_branch_veneer__UARTParseNewChar:
$va:
ramfunc_to_arm_branch_veneer__LEDSetState:
