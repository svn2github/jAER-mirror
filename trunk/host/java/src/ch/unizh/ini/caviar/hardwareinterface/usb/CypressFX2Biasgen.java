package ch.unizh.ini.caviar.hardwareinterface.usb;

import ch.unizh.ini.caviar.biasgen.Biasgen;
import ch.unizh.ini.caviar.biasgen.BiasgenHardwareInterface;
import ch.unizh.ini.caviar.biasgen.IPot;
import ch.unizh.ini.caviar.biasgen.IPotArray;
import ch.unizh.ini.caviar.hardwareinterface.HardwareInterfaceException;
import de.thesycon.usbio.UsbIoInterface;
import de.thesycon.usbio.structs.USBIO_CLASS_OR_VENDOR_REQUEST;
import de.thesycon.usbio.structs.USBIO_DATA_BUFFER;
import java.util.Iterator;
import javax.swing.JOptionPane;

/** Adds biasgen functionality to base interface via Cypress FX2
 *@author tobi
 */
public class CypressFX2Biasgen extends CypressFX2 implements BiasgenHardwareInterface {
    
    /** max number of bytes used for each bias. For 24-bit biasgen, only 3 bytes are used. */
    public static final int MAX_BYTES_PER_BIAS=3;
    
    /** Creates a new instance of USBAEMonitor. Note that it is possible to construct several instances
     * and use each of them to open and read from the same device.
     *@param devNumber the desired device number, in range returned by CypressFX2Factory.getNumInterfacesAvailable
     *@see CypressFX2TmpdiffRetinaFactory
     */
    /** Autogenerated proxy constructor. */
    protected CypressFX2Biasgen(int devNumber) {
        super(devNumber);
    }
    
    /*
        sets the powerdown input pin to the biasgenerator.
        Chip may have been plugged in without being
         powered up. To ensure the biasgen is powered up, a negative transition is necessary. This transistion is necessary to ensure the startup circuit starts up the masterbias again.
     
        if this method is called from a GUI is may be desireable to actually toggle the powerdown pin high and then low to ensure the chip is powered up.
        otherwise it doesn't make sense to always toggle this pin because it will perturb the chip operation significantly.
        For instance, it should not be called very time new bias values are sent.
     
      @param powerDown true to power OFF the biasgen, false to power on
     */
    synchronized public void setPowerDown(boolean powerDown) throws HardwareInterfaceException {
        //        System.out.println("BiasgenUSBInterface.setPowerDown("+powerDown+")");
        //        if(!powerDown)
        //            setPowerDownSingle(true);
        setPowerDownSingle(powerDown);
    }
    
    synchronized private void setPowerDownSingle(final boolean powerDown) throws HardwareInterfaceException {
        
        if(gUsbIo==null){
            throw new RuntimeException("device must be opened before sending this vendor request");
        }
        USBIO_CLASS_OR_VENDOR_REQUEST vendorRequest=new USBIO_CLASS_OR_VENDOR_REQUEST();
        int result;
        //        System.out.println("sending bias bytes");
        USBIO_DATA_BUFFER dataBuffer=new USBIO_DATA_BUFFER(0); // no data, control is in setupdat
        vendorRequest.Request=VENDOR_REQUEST_POWERDOWN;
        vendorRequest.Type=UsbIoInterface.RequestTypeVendor;
        vendorRequest.Recipient=UsbIoInterface.RecipientDevice;
        vendorRequest.RequestTypeReservedBits=0;
        vendorRequest.Index=0;  // meaningless for this request
        
        vendorRequest.Value=(short)(powerDown?1:0);  // this is the request bit, if powerDown true, send value 1, false send value 0
        
        dataBuffer.setNumberOfBytesToTransfer(dataBuffer.Buffer().length);
        result=gUsbIo.classOrVendorOutRequest(dataBuffer,vendorRequest);
        if(result!= de.thesycon.usbio.UsbIoErrorCodes.USBIO_ERR_SUCCESS ){
            throw new HardwareInterfaceException("setPowerDown: unable to send: "+gUsbIo.errorText(result));
        }
        HardwareInterfaceException.clearException();
        
    }
    
    /** sends the ipot values. 
     @param biasgen the biasgen which has the values to send
     */
    synchronized public void sendPotValues(ch.unizh.ini.caviar.biasgen.Biasgen biasgen) throws HardwareInterfaceException {
        
        if(gUsbIo==null) {
            System.out.println("BiasgenUSBInterface.send(): usbIo=null");
            return; // may not have been constructed yet.
        }
        if(biasgen.getPotArray()==null) {
            System.out.println("BiasgenUSBInterface.send(): iPotArray=null");
            return; // may not have been constructed yet.
        }
        
        IPotArray iPotArray=biasgen.getPotArray();
        
        //        throw new IPotException("null USBIO interface");
        //        if(iPotArray==null) throw new IPotException("null iPotArray");
        //
        // we make an array of bytes to hold the values sent, then we fill the array, copy it to a
        // new array of the proper size, and pass it to the routine that actually sends a vendor request
        // with a data buffer that is the bytes
        
        byte[] bytes=new byte[iPotArray.getNumPots()*MAX_BYTES_PER_BIAS];
        int byteIndex=0;
        //        System.out.print("BiasgenUSBInterface.send()");
        Iterator i=iPotArray.getShiftRegisterIterator();
        while(i.hasNext()){
            // for each bias starting with the first one (the one closest to the ** END ** of the shift register
            // we get the bitValue and from MSB ro LSB stuff these values into the byte array
            IPot iPot=(IPot)i.next();
            for(int k=iPot.getNumBytes()-1;k>=0;k--){ // for k=2..0
                bytes[byteIndex++]=(byte)((iPot.getBitValue()>>>k*8)&0xff);
            }
            //            System.out.print(iPot.getBitValue()+" ");
            
        }
        //        System.out.println("");
        byte[] toSend=new byte[byteIndex];
        System.arraycopy(bytes, 0, toSend, 0, byteIndex);
        
        sendBiasBytes(toSend);
        HardwareInterfaceException.clearException();
        
    }
    
    /** sends bias bytes. These are sent as control transfers which have a maximum data packet size of 64 bytes.
     If there are more than 64 bytes worth of bias data, then the transfer must be (and is automatically)  split up into several control transfers and the
     bias values can only be latched on-chip when all of the bytes have been sent. 
     *@param b bias bytes to clock out SPI interface
     */
    synchronized void sendBiasBytes(byte[] b) throws HardwareInterfaceException {
//        final int XFER_SIZE=64;
        if(gUsbIo==null){
            throw new RuntimeException("device must be opened before sending this vendor request");
        }
        USBIO_CLASS_OR_VENDOR_REQUEST vendorRequest=new USBIO_CLASS_OR_VENDOR_REQUEST();
        int result;
        if(b==null || b.length==0) {
            throw new RuntimeException("null or empty bias byte array supplied");
        }
//        if(b.length>XFER_SIZE){
//            log.info("more than 64 bytes of bias values to send, splitting up into several control transfers");
//        }
        int numXfers=1;
        int numLeft=b.length;
        int index=0;
        for(int i=0;i<numXfers;i++){
            int xferLength=numLeft;
            //        System.out.println("sending bias bytes");
            USBIO_DATA_BUFFER dataBuffer=new USBIO_DATA_BUFFER(xferLength);
            vendorRequest.Request=VENDOR_REQUEST_SEND_BIAS_BYTES;
            vendorRequest.Type=UsbIoInterface.RequestTypeVendor;
            vendorRequest.Recipient=UsbIoInterface.RecipientDevice;
            vendorRequest.RequestTypeReservedBits=0;
            vendorRequest.Index=0;  // meaningless for this request
            vendorRequest.Value=0;  // meaningless for this request
            System.arraycopy(b, index, dataBuffer.Buffer(), 0, xferLength);
            dataBuffer.setNumberOfBytesToTransfer(dataBuffer.Buffer().length);
            result=gUsbIo.classOrVendorOutRequest(dataBuffer,vendorRequest);
            if(result!= de.thesycon.usbio.UsbIoErrorCodes.USBIO_ERR_SUCCESS ){
                throw new HardwareInterfaceException("sendBiasBytes: Unable to send: "+gUsbIo.errorText(result));
            }
            numLeft-=xferLength;
            index+=xferLength;
        }
//        int numXfers=b.length/XFER_SIZE+1;
//        int numLeft=b.length;
//        int index=0;
//        for(int i=0;i<numXfers;i++){
//            int xferLength=Math.min(XFER_SIZE,numLeft);
//            //        System.out.println("sending bias bytes");
//            USBIO_DATA_BUFFER dataBuffer=new USBIO_DATA_BUFFER(xferLength);
//            vendorRequest.Request=VENDOR_REQUEST_SEND_BIAS_BYTES;
//            vendorRequest.Type=UsbIoInterface.RequestTypeVendor;
//            vendorRequest.Recipient=UsbIoInterface.RecipientDevice;
//            vendorRequest.RequestTypeReservedBits=0;
//            vendorRequest.Index=0;  // meaningless for this request
//            vendorRequest.Value=0;  // meaningless for this request
//            System.arraycopy(b, index, dataBuffer.Buffer(), 0, xferLength);
//            dataBuffer.setNumberOfBytesToTransfer(dataBuffer.Buffer().length);
//            result=gUsbIo.classOrVendorOutRequest(dataBuffer,vendorRequest);
//            if(result!= de.thesycon.usbio.UsbIoErrorCodes.USBIO_ERR_SUCCESS ){
//                throw new HardwareInterfaceException("sendBiasBytes: Unable to send: "+gUsbIo.errorText(result));
//            }
//            numLeft-=xferLength;
//            index+=xferLength;
//        }
    }
    
    synchronized public void flashPotValues(Biasgen biasgen) throws HardwareInterfaceException {
        JOptionPane.showMessageDialog(null,"Flashing biases not yet supported on CypressFX2");
    }
    
}
