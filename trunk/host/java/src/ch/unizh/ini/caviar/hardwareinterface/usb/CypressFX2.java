/*
 * USBAEMon.java
 *
 * Created on February 17, 2005, 7:54 AM
 */
package ch.unizh.ini.caviar.hardwareinterface.usb;

import ch.unizh.ini.caviar.aemonitor.*;
import ch.unizh.ini.caviar.aemonitor.AEMonitorInterface;
import ch.unizh.ini.caviar.chip.*;
//import ch.unizh.ini.caviar.chip.EventExtractor2D;
import ch.unizh.ini.caviar.eventprocessing.EventFilter;
import ch.unizh.ini.caviar.eventprocessing.FilterChain;
import ch.unizh.ini.caviar.event.EventPacket;
import ch.unizh.ini.caviar.hardwareinterface.*;
import ch.unizh.ini.caviar.stereopsis.StereoHardwareInterface;
import ch.unizh.ini.caviar.util.*;
import java.beans.*;
import java.io.*;
import de.thesycon.usbio.*;
import de.thesycon.usbio.structs.*;
import java.util.*;
import java.util.logging.Logger;
import java.util.prefs.*;

/**
 *  Devices that use the CypressFX2 and the USBIO driver, e.g. the DVS retinas, the USBAERmini2. This class should not normally be constructed but rather a subclass that overrides
 * the AEReader should be used.
 *<p>
 *In this class, you can also set the size of the host buffer with {@link #setAEBufferSize}, giving you more time between calls to process the events.
 *<p>
 *On the device, a timer sends all available events approximately every 10ms -- you don't need to wait for a fixed size buffer to be captured to be available to the host.
 *But if events come quickly enough, new events can be available much faster than this.
 *<p>
 *You can also request at any time an early transfer of events with {@link #requestEarlyTransfer}. This will send a vendor request to the device to immediately transfer
 * available events, but they won't be available to the host for a little while, depending on USBIOInterface and driver latency.
 *<p>
 *See the main() method for an example of use.
 * <p>
 * Fires PropertyChangeEvent on the following
 * <ul>
 * <li> NEW_EVENTS_PROPERTY_CHANGE - on new events from driver
 * <li> "readerStarted" - when the reader thread is started
 * </ul>
 *
 *
 * @author  tobi
 */
public class CypressFX2 implements UsbIoErrorCodes, PnPNotifyInterface, AEMonitorInterface, ReaderBufferControl {

    protected Preferences prefs = Preferences.userNodeForPackage(this.getClass());
    protected Logger log = Logger.getLogger("CypressFX2");
    protected AEChip chip;    // note .bix file format is deprecated. The new binary file format is .iic (i2c) format which are image files for the EEPROM
    /** filename of FX2 binary executable, generated by uVision project and associated script that runs hex2bix */
    public final static String FIRMWARE_FILENAME_TMPDIFF128_BIX = "/ch/unizh/ini/caviar/hardwareinterface/usb/USBAER_FX2LP_Retina.bix"; //"USBAEMonFirware.bin";
    /** filename of FX2 binary executable, generated by uVision project and associated script that runs hex2bix */
    public final static String FIRMWARE_FILENAME_TMPDIFF128_HEX = "/ch/unizh/ini/caviar/hardwareinterface/usb/USBAER_FX2LP_Retina.hex"; //"USBAEMonFirware.bin";
    /** filename of FX2 binary executable, generated by uVision project and associated script that runs hex2bix */
    public final static String FIRMWARE_FILENAME_MONITOR_SEQUENCER = "/ch/unizh/ini/caviar/hardwareinterface/usb/USBAERmini2.bix";
    /** filename of FX2 binary executable, generated by uVision project and associated script that runs hex2bix */
    public final static String FIRMWARE_FILENAME_MONITOR_SEQUENCER_HEX = "/ch/unizh/ini/caviar/hardwareinterface/usb/USBAERmini2.hex";
    /** filename of FX2 binary executable, generated by uVision project and associated script that runs hex2bix */
    public final static String FIRMWARE_FILENAME_MONITOR_SEQUENCER_IIC = "/ch/unizh/ini/caviar/hardwareinterface/usb/USBAERmini2.iic";
    public final static String FIRMWARE_FILENAME_MONITOR_SEQUENCER_JTAG_IIC = "/ch/unizh/ini/caviar/hardwareinterface/usb/USBAERmini2_JTAG.iic";
    public final static String FIRMWARE_FILENAME_MAPPER_IIC = "/ch/unizh/ini/caviar/hardwareinterface/usb/USB2AERmapper.iic";
    public final static String FIRMWARE_FILENAME_STEREO_IIC = "/ch/unizh/ini/caviar/hardwareinterface/usb/TMPdiffStereo.iic";//    public final static String FIRMWARE_FILENAME_TCVS320_IIC="/ch/unizh/ini/caviar/hardwareinterface/usb/USBAERTCVS320.iic";
    public final static String FIRMWARE_FILENAME_TCVS320_HEX = "/ch/unizh/ini/caviar/hardwareinterface/usb/USBAERTCVS320.hex";
    public final static String FIRMWARE_FILENAME_TCVS320_BIX = "/ch/unizh/ini/caviar/hardwareinterface/usb/USBAERTCVS320.bix";
    public final static String FIRMWARE_FILENAME_DVS128_IIC = "/ch/unizh/ini/caviar/hardwareinterface/usb/firmwareFX2_DVS128.iic";
    /** driver guid (Globally unique ID, for this USB driver instance */
    //public final static String GUID = "{325ddf96-938c-11d3-9e34-0080c82727f4}";  // working from MouseSimple example.
    public final static String GUID = "{7794C79A-40A7-4a6c-8A29-DA141C20D78C}"; // see guid.txt at root of CypressFX2USB2, generated by tobi for CypressFX2RetinaBiasgen
    //public final static String GUID    = "{96E73B6E-7A5A-11D4-9F24-0080C82727F4}";  // from default usbiowiz.inf file
    /** A blank Cypress FX2 has VID/PID of 0x04b4/0x8613. This VID/PID pair is used to indicate a blank device that needs programming. */
    static final public short VID_BLANK = (short) 0x04b4,  PID_BLANK = (short) 0x8613;
    static public final short PID_DVS128_REV0 = (short) 0x8400;
    static public final short VID = (short) 0x0547;
    static public final short PID_TMPDIFF128_RETINA = (short) 0x8700;
    //static public final short PID_TMPDIFF128_FX2_SMALL_BOARD=(short)0x8701; not used anymore, replace with new VID/PID from thesycon
    static public final short PID_USBAERmini2 = (short) 0x8801;
    static public final short PID_USBAERmini2_without_firmware = (short) 0x8800;
    static public final short PID_USB2AERmapper = (short) 0x8900;
    static public final short DID_STEREOBOARD = (short) 0x2007;
    static public final short PID_TCVS320_RETINA = (short) 0x8702;
    /**
     * event supplied to listeners when new events are collected. this is final because it is just a marker for the listeners that new events are available
     */
    public final PropertyChangeEvent NEW_EVENTS_PROPERTY_CHANGE = new PropertyChangeEvent(this, "NewEvents", null, null);
    PropertyChangeSupport support = new PropertyChangeSupport(this);    // consts
    final static byte AE_MONITOR_ENDPOINT_ADDRESS = (byte) 0x86;  // this is endpoint of AE fifo on Cypress FX2, 0x86 means IN endpoint EP6.
    final static byte STATUS_ENDPOINT_ADDRESS = (byte) 0x81;  // this is endpoint 1 IN for device to report status changes asynchronously
    final short CPUCS = (short) 0xE600;            // address of the CPUCS register, using for resetting 8051 and downloading firmware
    // vendor requests.
    final static byte VENDOR_REQUEST_START_TRANSFER = (byte) 0xb3; // this is request to start sending events from FIFO endpoint
    final static byte VENDOR_REQUEST_STOP_TRANSFER = (byte) 0xb4; // this is request to stop sending events from FIFO endpoint
    final static byte VENDOR_REQUEST_EARLY_TRANFER = (byte) 0xb7; // this is request to transfer whatever you have now
    static final byte VENDOR_REQUEST_SEND_BIAS_BYTES = (byte) 0xb8; // vendor command to send bias bytes out on SPI interface
    final byte VENDOR_REQUEST_POWERDOWN = (byte) 0xb9; // vendor command to send bias bytes out on SPI interface
    final byte VENDOR_REQUEST_FLASH_BIASES = (byte) 0xba;  // vendor command to flash the bias values to EEPROM
    final byte VENDOR_REQUEST_RESET_TIMESTAMPS = (byte) 0xbb; // vendor command to reset timestamps
    final byte VENDOR_REQUEST_SET_ARRAY_RESET = (byte) 0xbc; // vendor command to set array reset of retina
    final byte VENDOR_REQUEST_DO_ARRAY_RESET = (byte) 0xbd; // vendor command to do an array reset (toggle arrayReset for a fixed time)
    //final byte VENDOR_REQUEST_WRITE_EEPROM=(byte)0xbe; // vendor command to write EEPROM
    final byte VENDOR_REQUEST_SET_LED = (byte) 0xbf; // vendor command to set the board's LED
    static final byte VR_DOWNLOAD_FIRMWARE = (byte) 0xC5;  // vendor request to program CPLD or FPGA
    static final byte VR_SET_DEVICE_NAME = (byte) 0xC2;  // set serial number string
    //final byte VENDOR_REQUEST_READ_EEPROM=(byte)0xca; // vendor command to write EEPROM
    // #define VR_EEPROM		0xa2 // loads (uploads) EEPROM
    final byte VR_EEPROM = (byte) 0xa2;
    // #define	VR_RAM			0xa3 // loads (uploads) external ram
    final byte VR_RAM = (byte) 0xa3;    // this is special hw vendor request for reading and writing RAM, used for firmware download
    static final byte VENDOR_REQUEST_FIRMWARE = (byte) 0xA0; // download/upload firmware -- built in to FX2
    final static short CONFIG_INDEX = 0;
    final static short CONFIG_NB_OF_INTERFACES = 1;
    final static short CONFIG_INTERFACE = 0;
    final static short CONFIG_ALT_SETTING = 0;
    final static int CONFIG_TRAN_SIZE = 512;    // following are to support realtime filtering
    // the AEPacketRaw is used only within this class. Each packet is extracted using the chip extractor object from the first filter in the
    // realTimeFilterChain to a reused EventPacket.
    AEPacketRaw realTimeRawPacket = null; // used to hold raw events that are extracted for real time procesing
    EventPacket realTimePacket = null; // used to hold extracted real time events for processing
    /** start of events that have been captured but not yet processed by the realTimeFilters */
    private int realTimeEventCounterStart = 0;
    /** timeout in ms to reopen driver (reloading firmware) if no events are received for this time. This timeout will restart AE transmission if
     *another process (e.g. Biasgen) reloads the firmware. This timer is checked on every attempt to acquire events.
     */
    public static long NO_AE_REOPEN_TIMEOUT = 3000;
    final short TICK_US = 1; // time in us of each timestamp count here on host, could be different on board
    short TICK_US_BOARD = 10; // time in us of timestamp tick on USB board. raphael: should not be final, i need to overwrite it and set it to 1
    /** default size of AE buffer for user processes. This is the buffer that is written by the hardware capture thread that holds events
     * that have not yet been transferred via {@link #acquireAvailableEventsFromDriver} to another thread
     * @see #acquireAvailableEventsFromDriver
     * @see AEReader
     * @see #setAEBufferSize
     */
    public static final int AE_BUFFER_SIZE = 100000; // should handle 5Meps at 30FPS
    /** this is the size of the AEPacketRaw that are part of AEPacketRawPool that double buffer the translated events between rendering and capture threads */
    protected int aeBufferSize = prefs.getInt("CypressFX2.aeBufferSize", AE_BUFFER_SIZE);
    /** the latest status returned from a USBIO call */
    protected int status;
    /** the event reader - a buffer pool thread from USBIO subclassing */
    protected AEReader aeReader = null;
    /** the thread that reads device status messages on EP1 */
    protected AsyncStatusThread asyncStatusThread = null;
    /** a USBIO buffer used for calls */
    protected UsbIoBuf BufDesc = null;
    /** The pool of raw AE packets, used for data transfer */
    protected AEPacketRawPool aePacketRawPool = new AEPacketRawPool();

    /**
     * Object that holds pool of AEPacketRaw that handles data interchange between capture and other (rendering) threads.
     * While the capture thread (AEReader.processData) captures events into one buffer (an AEPacketRaw) the other thread (AEViewer.run()) can
     * render the events. The only time the monitor on the pool needs to be acquired is when swapping or initializing the buffers, to prevent
     * either referencing unrelated data or having memory change out from under you.
     */
    protected class AEPacketRawPool {

        int capacity;
        AEPacketRaw[] buffers;
        AEPacketRaw lastBufferReference;
        volatile int readBuffer = 0,  writeBuffer = 1; // this buffer is the one currently being read from

        AEPacketRawPool() {
            allocateMemory();
            reset();
        }

        /** swap the buffers so that the buffer that was getting written is now the one that is read from, and the one that was read from is
         * now the one written to. Thread safe.
         */
        synchronized final void swap() {
            lastBufferReference = buffers[readBuffer];
            if (readBuffer == 0) {
                readBuffer = 1;
                writeBuffer = 0;
            } else {
                readBuffer = 0;
                writeBuffer = 1;
            }
            writeBuffer().clear();
            writeBuffer().overrunOccuredFlag = false; // mark new write buffer clean, no overrun happened yet. writer sets this if it happens
        }

        /** @return buffer to read from */
        synchronized final AEPacketRaw readBuffer() {
            return buffers[readBuffer];
        }

        /** @return buffer to write to */
        synchronized final AEPacketRaw writeBuffer() {
            return buffers[writeBuffer];
        }

        /** Set the current buffer to be the first one and clear the write buffer */
        synchronized final void reset() {
            readBuffer = 0;
            writeBuffer = 1;
            buffers[writeBuffer].clear(); // new events go into this buffer which should be empty
            buffers[readBuffer].clear();  // clear read buffer in case this buffer was reset by resetTimestamps
//            log.info("buffers reset");
        }
        // allocates AEPacketRaw each with capacity AE_BUFFER_SIZE
        private void allocateMemory() {
            buffers = new AEPacketRaw[2];
            for (int i = 0; i < buffers.length; i++) {
                buffers[i] = new AEPacketRaw();
                buffers[i].ensureCapacity(getAEBufferSize()); // preallocate this memory for capture thread and to try to make it contiguous
            }
        }
    }
    int eventCounter = 0;  // counts events acquired but not yet passed to user
    /** the last events from {@link #acquireAvailableEventsFromDriver}, This packet is reused. */
    protected AEPacketRaw lastEventsAcquired = new AEPacketRaw();
    PnPNotify pnp = null;
    USBIO_CLASS_OR_VENDOR_REQUEST vendorRequest;  // used for vendor requests to device (e.g. firmware download, start sending events, etc)
    protected boolean inEndpointEnabled = false;  // raphael: changed from private to protected, because i need to access this member
    /** device open status */
    protected boolean isOpened = false;
    private boolean aeReaderRunning = false;
    /** the device number, out of all potential compatible devices that could be opened */
    protected int interfaceNumber = 0;

    /** Creates a new instance of USBAEMonitor. Note that it is possible to construct several instances
     * and use each of them to open and read from the same device.
     *@param devNumber the desired device number, in range returned by CypressFX2Factory.getNumInterfacesAvailable
     */
    protected CypressFX2(int devNumber) {
        this.interfaceNumber = devNumber;
//        pnp=new PnPNotify(this);
//        pnp.enablePnPNotification(GUID);
    }

    /** returns the device interface number. This is the index of this device as returned by the interface factory.
     * @return interface number, 0 based
     */
    int getInterfaceNumber() {
        return interfaceNumber;
    }

    /** sets the device number to open, according to the order in the hardware interface factory.
     * @param interfaceNumber 0 based interface number
     */
    void setInterfaceNumber(int interfaceNumber) {
        this.interfaceNumber = interfaceNumber;
    }

    /** acquire a device for exclusive use, other processes can't open the device anymore
     * used for example for continuous sequencing in matlab */
    public void acquireDevice() throws HardwareInterfaceException {
        status = gUsbIo.acquireDevice();
        if (status != 0) {
            throw new HardwareInterfaceException("Unable to acquire device for exclusive use: " + UsbIo.errorText(status));
        }
    }

    /** release the device from exclusive use */
    public void releaseDevice() throws HardwareInterfaceException {
        status = gUsbIo.releaseDevice();
        if (status != 0) {
            throw new HardwareInterfaceException("Unable to release device from exclusive use: " + UsbIo.errorText(status));
        }
    }

    public PropertyChangeSupport getSupport() {
        return this.support;
    }

    public String toString() {
        if (this.isOpened) {
            if (this.numberOfStringDescriptors == 3) {
                return (getStringDescriptors()[1] + " " + getStringDescriptors()[2]);
            } else {
                return (getStringDescriptors()[1] + ": Interface " + getInterfaceNumber());
            }
        } else {
            try {
                openUsbIo_minimal();
                gUsbIo.close();
                UsbIo.destroyDeviceList(gDevList);
                if (this.numberOfStringDescriptors == 3) {
                    return (getStringDescriptors()[1] + " " + getStringDescriptors()[this.numberOfStringDescriptors - 1]);
                } else {
                    return (getStringDescriptors()[1] + ": Interface " + getInterfaceNumber());
                }
            } catch (Exception e) {
                e.printStackTrace();
                return (getClass().getSimpleName() + ": Interface " + getInterfaceNumber());
            }
        }
    }

    public void setSerialNumber(String name) throws HardwareInterfaceException {
        if (!isOpen()) {
            open();
        }

        USBIO_DATA_BUFFER dataBuffer;

        dataBuffer = new USBIO_DATA_BUFFER(name.length());

        // copy the characters to the databuffer
        for (int i = 0; i < name.length(); i++) {
            dataBuffer.Buffer()[i] = (byte) name.charAt(i);
        }

        sendVendorRequest(VR_SET_DEVICE_NAME, (short) 0, (short) 0, dataBuffer);
        sendVendorRequest(VR_SET_DEVICE_NAME, (short) 0, (short) 0, dataBuffer);

        status = gUsbIo.getStringDescriptor(stringDescriptor3, (byte) 3, 0); // check if the new name is really set
        if (status != USBIO_ERR_SUCCESS) {
            log.warning("Could not get new device name, Error: " + gUsbIo.errorText(status));
        } else {
            //log.fine("Device name set to: " + stringDescriptor3.Str);
            log.info("New Devicename set, close and reopen the device to see the change");
        }
    }
    /** the size in bytes of the EEPROM atttached to the CypressFX2LP */
    public int EEPROM_SIZE = 0x8000;//32k;
    /** size of control transfer data packets. Actually vendor request allows for larger data buffer, but windows limits largest xfer to 4096. Here we limit largest
     *to size of buffer for control xfers. */
    public final int MAX_CONTROL_XFER_SIZE = 64; // max control xfer size

    /** This is a BLOCKING write call to write the Cypress EEPROM. Max number of bytes is defined by {@link #EEPROM_SIZE}.
     *@param addr the starting address
     *@param bytes the bytes to write
     */
    synchronized public void writeEEPROM(int addr, byte[] bytes) throws HardwareInterfaceException {

//        log.info("writing EEPROM to addr="+addr+" with "+bytes.length+" bytes");

        if (bytes.length > this.EEPROM_SIZE) {
            throw new RuntimeException(bytes.length + " is too many bytes for EEPROM to hold (" + EEPROM_SIZE + ")");
        }
        if (addr < 0 || addr + bytes.length > EEPROM_SIZE) {
            throw new RuntimeException(bytes.length + " is too many bytes for EEPROM to hold (" + EEPROM_SIZE + ") starting at address " + addr);
        }
        int result; // result of USBIO operations
        USBIO_DATA_BUFFER dataBuffer = null;
        USBIO_CLASS_OR_VENDOR_REQUEST vendorRequest = null;

        int numChunks, index;

        // make vendor request structure and populate it
        vendorRequest = new USBIO_CLASS_OR_VENDOR_REQUEST();


        vendorRequest.Request = VR_EEPROM; // this is EEPROM command, direction of vendor request defines download here

        vendorRequest.Flags = UsbIoInterface.USBIO_SHORT_TRANSFER_OK;
        vendorRequest.Type = UsbIoInterface.RequestTypeVendor;  // this is a vendor, not generic USB, request
        vendorRequest.Recipient = UsbIoInterface.RecipientDevice; // device (not endpoint, interface, etc) receives it
        vendorRequest.RequestTypeReservedBits = 0;    // set these bits to zero for Cypress-specific 'vendor request' rather that user defined
        vendorRequest.Index = 0;

        //send all but last chunk
        vendorRequest.Value = (short) addr;			//address to write to (starting)
        dataBuffer = new USBIO_DATA_BUFFER(MAX_CONTROL_XFER_SIZE);
        dataBuffer.setNumberOfBytesToTransfer(dataBuffer.Buffer().length);
        index = 0;
        numChunks = bytes.length / MAX_CONTROL_XFER_SIZE;  // this is number of full chunks to send
        for (int i = 0; i < numChunks; i++) {
            System.arraycopy(bytes, i * MAX_CONTROL_XFER_SIZE, dataBuffer.Buffer(), 0, MAX_CONTROL_XFER_SIZE);
            result = gUsbIo.classOrVendorOutRequest(dataBuffer, vendorRequest);
            if (result != USBIO_ERR_SUCCESS) {
                close();
                throw new HardwareInterfaceException("Error on downloading segment number " + i + " of EEPROM write: " + UsbIo.errorText(result));
            }
            vendorRequest.Value += MAX_CONTROL_XFER_SIZE;			//change address of EEPROM write location
        }

        // now send final (short) chunk
        int numBytesLeft = bytes.length % MAX_CONTROL_XFER_SIZE;  // remainder
        if (numBytesLeft > 0) {
            dataBuffer = new USBIO_DATA_BUFFER(numBytesLeft);
            dataBuffer.setNumberOfBytesToTransfer(dataBuffer.Buffer().length);
            System.arraycopy(bytes, numChunks * MAX_CONTROL_XFER_SIZE, dataBuffer.Buffer(), 0, numBytesLeft);

            // send remaining part of firmware
            result = gUsbIo.classOrVendorOutRequest(dataBuffer, vendorRequest);
            if (result != USBIO_ERR_SUCCESS) {
                close();
                throw new HardwareInterfaceException("Error on downloading final segment of EEPROM write: " + UsbIo.errorText(result));
            }
        }

    } // writeEEPROM

    /** erases the VID/PID/DID and device identifier strings */
    synchronized protected void eraseEEPROM() throws HardwareInterfaceException {
        log.info("erasing EEPROM by writing all zeros to it");
        writeEEPROM(0, new byte[EEPROM_SIZE]);
    }

    /** Read the EEPROM contents.
     *@param addr the starting address
     *@param length the number of bytes to read
     */
    synchronized protected byte[] readEEPROM(int addr, int length) throws HardwareInterfaceException {
        int result;
        if (length > EEPROM_SIZE) {
            throw new RuntimeException(length + " is more bytes than EEPROM can hold (" + EEPROM_SIZE + ")");
        }
        if (addr < 0 || addr + length > EEPROM_SIZE) {
            throw new RuntimeException(length + " is too many bytes to read from EEPROM which holds " + EEPROM_SIZE + " bytes, if you start at address " + addr);
        }
        USBIO_DATA_BUFFER dataBuffer = null;
        USBIO_CLASS_OR_VENDOR_REQUEST vendorRequest = null;

        byte[] uploadBuffer = new byte[length];

        // make vendor request structure and populate it
        vendorRequest = new USBIO_CLASS_OR_VENDOR_REQUEST();
        vendorRequest.Request = VR_EEPROM; // this is download/upload EEPROM command, direction of vendor request defines upload to host

        vendorRequest.Flags = UsbIoInterface.USBIO_SHORT_TRANSFER_OK;
        vendorRequest.Type = UsbIoInterface.RequestTypeVendor;  // this is a vendor, not generic USB, request
        vendorRequest.Recipient = UsbIoInterface.RecipientDevice; // device (not endpoint, interface, etc) receives it
        vendorRequest.RequestTypeReservedBits = 0;    // set these bits to zero for Cypress-specific 'vendor request' rather that user defined
        vendorRequest.Index = 0;

        dataBuffer = new USBIO_DATA_BUFFER(length);
        int bytesTransferred = 0;
        dataBuffer.setNumberOfBytesToTransfer(length);
        vendorRequest.Value = (short) addr; // this is EEPROM addr to read from for this chunk
        result = gUsbIo.classOrVendorInRequest(dataBuffer, vendorRequest);  // IN request defines direction, so will be understood as read EEPROM on device
        if (result != USBIO_ERR_SUCCESS) {
            close();
            throw new HardwareInterfaceException("Error during uploading EEPROM: " + UsbIo.errorText(result));
        }
        if (dataBuffer.getBytesTransferred() != length) {
            throw new HardwareInterfaceException("wrong number of bytes transferred, asked for " + length + ", got " + dataBuffer.getBytesTransferred());
        }
        System.arraycopy(dataBuffer.Buffer(), 0, uploadBuffer, 0, length);

        return uploadBuffer;
    }

    /** writes the Cypress "C0" load to the EEPROM that makes the Cypress FX2 have a Vender, Product, and Device ID on powerup.
     *@param VID
     *@param PID
     *@param DID the 'device' ID, can be used to individualize devices
     */
    synchronized public void writeVIDPIDDID(short VID, short PID, short DID) throws HardwareInterfaceException {
        byte[] b = new byte[8];
        b[0] = (byte) 0xC0;
        b[1] = (byte) (VID & 0xFF);    // vid LSB
        b[2] = (byte) ((VID & 0xFF00) >>> 8); // vid MSB
        b[3] = (byte) (PID & 0xFF);
        b[4] = (byte) ((PID & 0xFF00) >>> 8);
        b[5] = (byte) (DID & 0xFF);
        b[6] = (byte) ((DID & 0xFF00) >>> 8);
        b[7] = (byte) (0); // configuration byte, DISCON=0 (not disconnected after reset), 400kHz=0 (100kHz I2C  bus)

        writeEEPROM(0, b);
    }
//    private class WriteC2LoadFromHexFileTask extends SwingWorker{
//
//        protected Object doInBackground() throws Exception {
//        }
//
//    }
    /** writes the Cypress "C2" load to the EEPROM that makes the Cypress have full EEPROM firmware, including VID, PID, DID.
     *On reset the Cypress will load its RAM from the EEPROM.
     *@param firmwareFilename a File containing the binary format .iic file
     * firmware as output from hex2bix. This is a flat firmware format that starts at address 0.
     * It does not include the VID/PID written for the C2 load.
     *@param VID
     *@param PID
     *@param DID the 'device' ID, can be used to individualize devices
     */
    public void writeC2Load(String firmwareFilename, short VID, short PID, short DID) throws HardwareInterfaceException {
        byte[] fw = null;

        try {
            fw = loadBinaryFirmwareFile(firmwareFilename);
        } catch (IOException e) {
            throw new HardwareInterfaceException(e.getMessage());
        }

        byte[] b = new byte[12];
        b[0] = (byte) 0xC2;
        b[1] = (byte) (VID & 0xFF);    // vid LSB
        b[2] = (byte) ((VID & 0xFF00) >>> 8); // vid MSB
        b[3] = (byte) (PID & 0xFF);
        b[4] = (byte) ((PID & 0xFF00) >>> 8);
        b[5] = (byte) (DID & 0xFF);
        b[6] = (byte) ((DID & 0xFF00) >>> 8);
        b[7] = (byte) (0); // configuration byte, DISCON=0 (not disconnected after reset), 400kHz=0 (100kHz I2C  bus)

        b[8] = (byte) ((fw.length & 0xFF00) >>> 8);
        b[9] = (byte) ((fw.length & 0xFF)); // length of firmware in these bytes
        b[10] = 0;
        b[11] = 0;

        byte[] end = new byte[5];
        end[0] = (byte) 0x80;
        end[1] = (byte) 0x01;
        end[2] = (byte) 0xe6;
        end[4] = 0;

        byte[] w = new byte[b.length + fw.length + end.length];
        System.arraycopy(b, 0, w, 0, b.length);
        System.arraycopy(fw, 0, w, b.length, fw.length);
        System.arraycopy(end, 0, w, b.length + fw.length, end.length);


        writeEEPROM(0, w);
    }

    /** writes the Cypress "C2" load to the EEPROM that makes the Cypress have EEPROM firmware, including VID, PID, DID.
     *@param VID
     *@param PID
     *@param DID the 'device' ID, can be used to individualize devices
     *@param hexFileResourcePath a full path pointing to a resource containing the firmware as output from compiler in Intel hex format. This resource is a file that is somewhere in the classpath, i.e. it is a file
     *that is included in the project jar. For example: "/ch/unizh/ini/caviar/hardwareinterface/usb/USBAER_FX2LP_Retina.hex"
     *@see #FIRMWARE_FILENAME_TMPDIFF128_HEX
     *@see #FIRMWARE_FILENAME_MONITOR_SEQUENCER_HEX
     */
    synchronized public void writeHexFileToEEPROM(String hexFileResourcePath, short VID, short PID, short DID) throws HardwareInterfaceException {

        log.info("writing retina EEPROM firmware file " + hexFileResourcePath + " with VID=" + HexString.toString(VID) + " PID=" + HexString.toString(PID) + " DID=" + HexString.toString(DID));
        HexFileParser parser;
        try {
            parser = new HexFileParser(hexFileResourcePath);
        } catch (IOException e2) {
            throw new HardwareInterfaceException(e2.getMessage() + ": cannot open resource " + hexFileResourcePath);
        }
        ArrayList<HexFileParser.Record> records = parser.getRecords();
        int index = 0;
        byte[] b;

        log.info("writing " + records.size() + " records");


//        JFrame frame=new JFrame("EEPROM progress");
//        JProgressBar progressBar;
//        progressBar = new JProgressBar(0, records.size());
//        progressBar.setName("EEPROM programming");
//        progressBar.setValue(0);
//        progressBar.setStringPainted(true);
//        frame.getContentPane().add(progressBar);
//        frame.pack();
//        frame.setDefaultCloseOperation(JFrame.HIDE_ON_CLOSE);
//        frame.setVisible(true);


        b = new byte[12];
        b[0] = (byte) 0xC2; // write C2 load format header
        b[1] = (byte) (VID & 0xFF);    // vid LSB
        b[2] = (byte) ((VID & 0xFF00) >>> 8); // vid MSB
        b[3] = (byte) (PID & 0xFF);
        b[4] = (byte) ((PID & 0xFF00) >>> 8);
        b[5] = (byte) (DID & 0xFF);
        b[6] = (byte) ((DID & 0xFF00) >>> 8);
        b[7] = (byte) (0); // configuration byte, DISCON=0 (not disconnected after reset), 400kHz=0 (100kHz I2C  bus)

        writeEEPROM(0, b); // write VID/PID etc header starting at addr 0

        index += b.length;
        int recNum = 0;
        // now for each hex file record, we must write this record, contiguous with the last one, and each record written to
        // flash must contain the starting address of how many bytes there are (up to 1023) and where the memory should go in the FX2 RAM.
        // now write hex file records, one by one
        for (HexFileParser.Record r : records) {
            b = new byte[4];
            b[0] = (byte) ((r.data.length & 0xFF00) >>> 8);
            b[1] = (byte) ((r.data.length & 0xFF));
            b[2] = (byte) ((r.address & 0xFF00) >>> 8);
            b[3] = (byte) ((r.address & 0xFF));
            writeEEPROM(index, b);
            index += b.length;
            writeEEPROM(index, r.data);
            index += r.data.length;
//            progressBar.setValue(recNum++);
        }

        // now write footer

        b = new byte[5];
        b[0] = (byte) 0x80;
        b[1] = (byte) 0x01;
        b[2] = (byte) 0xe6;
        b[3] = (byte) 0;
        b[4] = 0;

        writeEEPROM(index, b);
        index += b.length;
        log.info("done writing " + records.size() + " records to EEPROM");
//        frame.dispose();

    }

    /** downloads firmware to the FX2 RAM from a hex file.
     *@param hexFileResourcePath a full path pointing to a resource containing the firmware as output from compiler in Intel hex format. This resource is a file that is somewhere in the classpath, i.e. it is a file
     *that is included in the project jar. For example: "/ch/unizh/ini/caviar/hardwareinterface/usb/USBAER_FX2LP_Retina.hex"
     *@see #FIRMWARE_FILENAME_TMPDIFF128_HEX
     *@see #FIRMWARE_FILENAME_MONITOR_SEQUENCER_HEX
     */
    synchronized public void downloadFirmwareHex(String hexFileResourcePath) throws HardwareInterfaceException {

        log.info("downloading to RAM firmware file " + hexFileResourcePath);

        HexFileParser parser;
        try {
            parser = new HexFileParser(hexFileResourcePath);
        } catch (FileNotFoundException e) {
            throw new HardwareInterfaceException(e.getMessage() + ": cannot open resource " + hexFileResourcePath);
        } catch (IOException e2) {
            throw new HardwareInterfaceException(e2.getMessage() + ": cannot open resource " + hexFileResourcePath);

        }
        ArrayList<HexFileParser.Record> records = parser.getRecords();

        set8051Reset(true);

        // now for each hex file record, we must write this record, contiguous with the last one, and each record written to
        // flash must contain the starting address of how many bytes there are (up to 1023) and where the memory should go.
        // now write hex file records, one by one
        for (HexFileParser.Record r : records) {
            download8051RAM(r.address, r.data);
        }

        set8051Reset(false);
    }

    /** adds a listener for new events captured from the device.
     * Actually gets called whenever someone looks for new events and there are some using
     * acquireAvailableEventsFromDriver, not when data is actually captured by AEReader.
     * Thus it will be limited to the users sampling rate, e.g. the game loop rendering rate.
     *
     * @param listener the listener. It is called with a PropertyChangeEvent when new events
     * are received by a call to {@link #acquireAvailableEventsFromDriver}.
     * These events may be accessed by calling {@link #getEvents}.
     */
    public void addAEListener(AEListener listener) {
        support.addPropertyChangeListener(listener);
    }

    public void removeAEListener(AEListener listener) {
        support.removePropertyChangeListener(listener);
    }

    /** starts reader buffer pool thread and enables in endpoints for AEs. Subclasses *MUST* override this method to start their own customized reader
    with their own translateEvents method.
     */
    public void startAEReader() throws HardwareInterfaceException {  // raphael: changed from private to protected, because i need to access this method
        throw new Error("This method should not be called - the CypressFX2 subclass should override startAEReader");
//        setAeReader(new AEReader(this));
//        allocateAEBuffers();
//        getAeReader().startThread(3); // arg is number of errors before giving up
//        HardwareInterfaceException.clearException();
    }
    long lastTimeEventCaptured = System.currentTimeMillis(); // used for timer to restart IN transfers, in case another connection, e.g. biasgen, has disabled them

    /** Gets available events from driver.  {@link HardwareInterfaceException} is thrown if there is an error.
     *{@link #overrunOccurred} will be reset after this call.
     *<p>
     *This method also starts event acquisition if it is not running already.
     *
     *Thread safe: synchronized on access to the capture buffer.
     *
     * @return number of events acquired. If this is zero there is no point in getting the events, because there are none.
     *@throws HardwareInterfaceException
     *@see #setEventAcquisitionEnabled
     *
     * .
     */
    synchronized public AEPacketRaw acquireAvailableEventsFromDriver() throws HardwareInterfaceException {
        if (!isOpened) {
            open();
        }

        // make sure event acquisition is running
        if (!inEndpointEnabled) {
            setEventAcquisitionEnabled(true);
        }

//        HardwareInterfaceException.clearException();

        // make sure that event translation from driver is allowed to run if need be, to avoid holding up event sender
//        Thread.currentThread().yield();

//        short[] addresses;
//        int[] timestamps;
        int nEvents;

        // get the 'active' buffer for events (the one that has just been written by the hardware thread)
//        synchronized(aePacketRawPool){ // synchronize on aeReader so that we don't try to access the events at the same time
        aePacketRawPool.swap();
        lastEventsAcquired = aePacketRawPool.readBuffer();
//        log.info(this+" acquired "+lastEventsAcquired);
//            addresses=events.getAddresses();
//            timestamps=events.getTimestamps();
        nEvents = lastEventsAcquired.getNumEvents();
        eventCounter = 0;
        realTimeEventCounterStart = 0;

        computeEstimatedEventRate(lastEventsAcquired);
        if (nEvents != 0) {
            support.firePropertyChange(NEW_EVENTS_PROPERTY_CHANGE); // call listeners
//        }
        }
        return lastEventsAcquired;

//        events=new AEPacketRaw(nEvents);
//        // reuse same packet to avoid constant new'ing
//        events.ensureCapacity(nEvents);
//        if(nEvents==0){
////            log.warning("got zero events from "+this);
//            computeEstimatedEventRate(null);
//            events.clear();
//            return events;
//        }else{
//            System.arraycopy(addresses, 0, events.getAddresses(), 0, nEvents);
//            System.arraycopy(timestamps, 0, events.getTimestamps(), 0, nEvents);
//            events.setNumEvents(nEvents);
//            computeEstimatedEventRate(events);
//            support.firePropertyChaNEW_EVENTS_PROPERTY_CHANGEY_CHANGE); // call listeners
//            return events;
//        }
    }

    /** the max capacity of this USB2 bus interface is 24MB/sec/4 bytes/event
     */
    public int getMaxCapacity() {
        return 6000000;
    }
    private int estimatedEventRate = 0;

    /** @return event rate in events/sec as computed from last acquisition.
     *
     */
    public int getEstimatedEventRate() {
        return estimatedEventRate;
    }

    /** computes the estimated event rate for a packet of events */
    void computeEstimatedEventRate(AEPacketRaw events) {
        if (events == null || events.getNumEvents() < 2) {
            estimatedEventRate = 0;
        } else {
            int[] ts = events.getTimestamps();
            int n = events.getNumEvents();
            int dt = ts[n - 1] - ts[0];
            estimatedEventRate = (int) (1e6f * (float) n / (float) dt);
        }
    }

    /** Returns the number of events acquired by the last call to {@link
     * #acquireAvailableEventsFromDriver }
     * @return number of events acquired
     */
    public int getNumEventsAcquired() {
        return aePacketRawPool.readBuffer().getNumEvents();
    }

    /** reset the timestamps to zero. This has two effects. First it sends a vendor request down the control endpoint
     * to tell the device to reset its own internal timestamp counters. Second, it tells the AEReader object to reset its
     * timestamps, meaning to reset its unwrap counter.
     */
    synchronized public void resetTimestamps() {
        log.info(this + ".resetTimestamps(): zeroing timestamps");
        int status = 0; // don't use global status in this function
        dontwrap = true;  // this is a flag that is reset in translateEvents method
        // send vendor request for device to reset timestamps
        if (gUsbIo == null) {
            throw new RuntimeException("device must be opened before sending this vendor request");
        }

        // make vendor request structure and populate it
        USBIO_CLASS_OR_VENDOR_REQUEST VendorRequest = new USBIO_CLASS_OR_VENDOR_REQUEST();

        VendorRequest.Flags = UsbIoInterface.USBIO_SHORT_TRANSFER_OK;
        VendorRequest.Type = UsbIoInterface.RequestTypeVendor;
        VendorRequest.Recipient = UsbIoInterface.RecipientDevice;
        VendorRequest.RequestTypeReservedBits = 0;
        VendorRequest.Request = VENDOR_REQUEST_RESET_TIMESTAMPS;
        VendorRequest.Index = 0;

        VendorRequest.Value = 0;
        USBIO_DATA_BUFFER dataBuffer = new USBIO_DATA_BUFFER(1);
        dataBuffer.setNumberOfBytesToTransfer(1);
        //        dataBuffer.Buffer()[0]=1;
        status = gUsbIo.classOrVendorOutRequest(dataBuffer, VendorRequest);
        if (status != USBIO_ERR_SUCCESS) {
            log.warning("CypressFX2.resetTimestamps: couldn't send vendor request to reset timestamps");
        }
        if (getAeReader() != null) {
            getAeReader().resetTimestamps(); // reset wrap counter and flush buffers
        } else {
            log.warning("CypressFX2.resetTimestamps(): reader not yet started, can't reset timestamps");
//        log.info(this+" notifying waiting threads that timestamps have been reset");
//        notifyAll(); // notify waiting threads (e.g. StereoHardwareInterface) that timestamps have been reset
        }
    }

    /** reset the entire pixel array */
    public void resetPixelArray() {
        // send vendor request for device to reset array
        int status = 0; // don't use global status in this function
        if (gUsbIo == null) {
            throw new RuntimeException("device must be opened before sending this vendor request");
        }

        // make vendor request structure and populate it
        USBIO_CLASS_OR_VENDOR_REQUEST VendorRequest = new USBIO_CLASS_OR_VENDOR_REQUEST();

        VendorRequest.Flags = UsbIoInterface.USBIO_SHORT_TRANSFER_OK;
        VendorRequest.Type = UsbIoInterface.RequestTypeVendor;
        VendorRequest.Recipient = UsbIoInterface.RecipientDevice;
        VendorRequest.RequestTypeReservedBits = 0;
        VendorRequest.Request = VENDOR_REQUEST_DO_ARRAY_RESET;
        VendorRequest.Index = 0;

        VendorRequest.Value = 0;
        USBIO_DATA_BUFFER dataBuffer = new USBIO_DATA_BUFFER(1);
        dataBuffer.setNumberOfBytesToTransfer(1);
        //        dataBuffer.Buffer()[0]=1;
        status = gUsbIo.classOrVendorOutRequest(dataBuffer, VendorRequest);
        if (status != USBIO_ERR_SUCCESS) {
            log.warning("CypressFX2.resetPixelArray: couldn't send vendor request to reset array");
        }
    }
    protected boolean arrayResetEnabled = false;

    /** set the board LED state. Useful for debugging. Not available for CypressFX2MonitorSequencer
     * @param value true to turn it on, false to turn it off.
     */
    synchronized public void setLed(boolean value) {
        // send vendor request for device to reset array
        int status = 0; // don't use global status in this function
        if (gUsbIo == null) {
            throw new RuntimeException("device must be opened before sending this vendor request");
        }

        // make vendor request structure and populate it
        USBIO_CLASS_OR_VENDOR_REQUEST VendorRequest = new USBIO_CLASS_OR_VENDOR_REQUEST();

        VendorRequest.Flags = UsbIoInterface.USBIO_SHORT_TRANSFER_OK;
        VendorRequest.Type = UsbIoInterface.RequestTypeVendor;
        VendorRequest.Recipient = UsbIoInterface.RecipientDevice;
        VendorRequest.RequestTypeReservedBits = 0;
        VendorRequest.Request = VENDOR_REQUEST_SET_LED;
        VendorRequest.Index = 0;

        VendorRequest.Value = (short) (value ? 0 : 1);  // this is the request bit, if value true, send value 0, false send value 1
        // on the board, 1 actually turns off the LED because the anode is tied to Vdd and the  cathode to the GPIO output

        USBIO_DATA_BUFFER dataBuffer = new USBIO_DATA_BUFFER(0); // no data, value is in request value
        dataBuffer.setNumberOfBytesToTransfer(dataBuffer.Buffer().length);

        status = gUsbIo.classOrVendorOutRequest(dataBuffer, VendorRequest);
        if (status != USBIO_ERR_SUCCESS) {
            log.warning("CypressFX2.resetPixelArray: couldn't send vendor request to set LED");
        }
    }

    /** Is true if an overrun occured in the driver (><code> AE_BUFFER_SIZE</code> events) during the period before the last time {@link
     * #acquireAvailableEventsFromDriver } was called. This flag is cleared by {@link #acquireAvailableEventsFromDriver}, so you need to
     * check it before you acquire the events.
     *<p>
     *If there is an overrun, the events grabbed are the most ancient; events after the overrun are discarded. The timestamps continue on but will
     *probably be lagged behind what they should be.
     * @return true if there was an overrun.
     */
    public boolean overrunOccurred() {
//        synchronized(aePacketRawPool){
        return aePacketRawPool.readBuffer().overrunOccuredFlag;
//        }
    }

    /** Closes the device. Never throws an exception.
     */
    synchronized public void close() {
        if (!isOpened) {
//            log.warning("CypressFX2.close(): not open");
            return;
        }

        try {
//            if (this.isEventAcquisitionEnabled()) {
            setEventAcquisitionEnabled(false);
            stopAEReader();
//            }
            if (asyncStatusThread != null) {
                asyncStatusThread.stopThread();
            }
        } catch (HardwareInterfaceException e) {
            e.printStackTrace();
        }

//        log.info("Cycling port on close()");
        gUsbIo.cyclePort();

        gUsbIo.close();
        UsbIo.destroyDeviceList(gDevList);
//        log.info("USBIOInterface.close(): device closed");
        inEndpointEnabled = false;
        isOpened = false;
    }
    // not really necessary to stop this thread, i believe, because close will unbind already according to usbio docs
    public void stopAEReader() {  // raphael: changed from private to protected, because i need to access this method
        if (getAeReader() != null) {
            //   System.out.println("CypressFX2.stopAEReader(): stopping aeReader thread");
            getAeReader().shutdownThread();
            // unbind pipe
            getAeReader().unbind();
            // close device
            getAeReader().close();

            setAeReader(null);
        }

    //  asyncStatusThread=null;
    }

    /** sends vendor request to trigger an immediate commit of whatever is in the endpoint fifo immediately.
     * next call to <@link #acquireAvailableEventsFromDriver} will get these events if you wait a bit.
     */
    synchronized public void requestEarlyTransfer() throws HardwareInterfaceException {
        // start getting events by sending vendor request 0xb3 to control endpoint 0
        // documented in firmware FX2_to_extFIFO.c

        // make vendor request structure and populate it
        USBIO_CLASS_OR_VENDOR_REQUEST VendorRequest = new USBIO_CLASS_OR_VENDOR_REQUEST();
        int status = 0; // don't use global status in this function

        VendorRequest.Flags = UsbIoInterface.USBIO_SHORT_TRANSFER_OK;
        VendorRequest.Type = UsbIoInterface.RequestTypeVendor;
        VendorRequest.Recipient = UsbIoInterface.RecipientDevice;
        VendorRequest.RequestTypeReservedBits = 0;
        VendorRequest.Request = (byte) VENDOR_REQUEST_EARLY_TRANFER;
        VendorRequest.Index = 0;

        USBIO_DATA_BUFFER dataBuffer = new USBIO_DATA_BUFFER(1);
        VendorRequest.Value = 0; // (byte)VENDOR_REQUEST_START_TRANSFER;
        dataBuffer = new USBIO_DATA_BUFFER(1);
        dataBuffer.setNumberOfBytesToTransfer(dataBuffer.Buffer().length);
        dataBuffer.Buffer()[0] = 1;
        status = gUsbIo.classOrVendorOutRequest(dataBuffer, VendorRequest);
        if (status != USBIO_ERR_SUCCESS) {
            throw new HardwareInterfaceException("Unable to send vendor request to send events early: " + UsbIo.errorText(status));
        }
        HardwareInterfaceException.clearException();

    }

    /** @return true if inEndpoint was enabled.
     * However, some other connection (e.g. biasgen) could have disabled the in transfers.
     */
    public boolean isInEndpointEnabled() {
        return this.inEndpointEnabled;
    }

    /** sends a vendor request to enable or disable in transfers of AEs
     *@param inEndpointEnabled true to send vendor request to enable, false to send request to disable
     */
    public void setInEndpointEnabled(final boolean inEndpointEnabled) throws HardwareInterfaceException {
        if (inEndpointEnabled) {
            enableINEndpoint();
        } else {
            disableINEndpoint();
        }
    }

    synchronized void enableINEndpoint() throws HardwareInterfaceException {
        // start getting events by sending vendor request 0xb3 to control endpoint 0
        // documented in firmware FX2_to_extFIFO.c
//        System.out.println("USBAEMonitor.enableINEndpoint()");
        // make vendor request structure and populate it
        if (gUsbIo == null) {
            log.warning("CypressFX2.enableINEndpoint(): null USBIO device");
            return;
        }
        int status = 0; // don't use global status in this function
        USBIO_CLASS_OR_VENDOR_REQUEST VendorRequest = new USBIO_CLASS_OR_VENDOR_REQUEST();

        VendorRequest.Flags = UsbIoInterface.USBIO_SHORT_TRANSFER_OK;
        VendorRequest.Type = UsbIoInterface.RequestTypeVendor;
        VendorRequest.Recipient = UsbIoInterface.RecipientDevice;
        VendorRequest.RequestTypeReservedBits = 0;
        VendorRequest.Request = (byte) VENDOR_REQUEST_START_TRANSFER;
        VendorRequest.Index = 0;

        VendorRequest.Value = 0;
        USBIO_DATA_BUFFER dataBuffer = new USBIO_DATA_BUFFER(0);
        dataBuffer.setNumberOfBytesToTransfer(0);
        status = gUsbIo.classOrVendorOutRequest(dataBuffer, VendorRequest);
        if (status != USBIO_ERR_SUCCESS) {
            close();
            throw new HardwareInterfaceException("Unable to send vendor request to send events: " + UsbIo.errorText(status));
        } else {
            inEndpointEnabled = true;
        }
        HardwareInterfaceException.clearException();
    }

    synchronized void disableINEndpoint() {
        // stop endpoint sending events by sending vendor request 0xb4 to control endpoint 0
        // these requests are docuemented in firmware file FX2_to_extFIFO.c

        // make vendor request structure and populate it
        int status = 0; // don't use global status in this function
        USBIO_CLASS_OR_VENDOR_REQUEST VendorRequest = new USBIO_CLASS_OR_VENDOR_REQUEST();

        VendorRequest.Flags = UsbIoInterface.USBIO_SHORT_TRANSFER_OK;
        VendorRequest.Type = UsbIoInterface.RequestTypeVendor;
        VendorRequest.Recipient = UsbIoInterface.RecipientDevice;
        VendorRequest.RequestTypeReservedBits = 0;
        VendorRequest.Request = VENDOR_REQUEST_STOP_TRANSFER;
        VendorRequest.Index = 0;

        VendorRequest.Value = 0;
        USBIO_DATA_BUFFER dataBuffer = new USBIO_DATA_BUFFER(0);
        dataBuffer.setNumberOfBytesToTransfer(0);
        status = gUsbIo.classOrVendorOutRequest(dataBuffer, VendorRequest);
        if (status != USBIO_ERR_SUCCESS) {
            log.info("disableINEndpoint: couldn't send vendor request to disable IN transfers--it could be that device is gone or sendor is OFF and and completing GPIF cycle");
        } else {
            inEndpointEnabled = false;
        }
        HardwareInterfaceException.clearException();
    }

    protected class AsyncStatusThread extends Thread {

        UsbIoPipe pipe;
        CypressFX2 monitor;
        boolean stop = false;
        byte msg;

        AsyncStatusThread(CypressFX2 monitor) {
            this.monitor = monitor;
        }

        public void stopThread() {
            if (pipe != null) {
                pipe.abortPipe();
            }
            interrupt();
        }

        public void run() {
            setName("AsyncStatusThread");
            int status;
            UsbIoBuf buffer = new UsbIoBuf(64); // size of EP1
            pipe = new UsbIoPipe();
            status = pipe.bind(monitor.getInterfaceNumber(), STATUS_ENDPOINT_ADDRESS, gDevList, GUID);
            if (status != USBIO_ERR_SUCCESS) {
                log.warning("error binding to pipe for EP1 for device status: " + UsbIo.errorText(status));
            }
            USBIO_PIPE_PARAMETERS pipeParams = new USBIO_PIPE_PARAMETERS();
            pipeParams.Flags = UsbIoInterface.USBIO_SHORT_TRANSFER_OK;
            status = pipe.setPipeParameters(pipeParams);
            if (status != USBIO_ERR_SUCCESS) {
                log.warning("can't set pipe parameters: " + UsbIo.errorText(status));
            }
            while (!stop && !isInterrupted()) {
                buffer.NumberOfBytesToTransfer = 64;
                status = pipe.read(buffer);
                if (status == 0) {
                    if (stop) {
                        log.info("Error submitting read on status pipe: " + UsbIo.errorText(buffer.Status));
                    }
                    break;
                }
                status = pipe.waitForCompletion(buffer);
                if (status != 0 && buffer.Status != UsbIoErrorCodes.USBIO_ERR_CANCELED) {
                    if (!stop && !isInterrupted()) {
                        log.warning("Error waiting for completion of read on status pipe: " + UsbIo.errorText(buffer.Status));
                    }
                    break;
                }
                if (buffer.BytesTransferred > 0) {
                    msg = buffer.BufferMem[0];
                    if (msg == 1) {
                        AEReader rd = getAeReader();
                        if (rd != null) {
                            log.info("*********************************** CypressFX2.AsyncStatusThread.run(): timestamps externally reset");
                            rd.resetTimestamps();
                        } else {
                            log.info("Received timestamp external reset message, but monitor is not running");
                        }
                    }
                } // we get 0 byte read on stopping device
            }
//            System.out.println("Status reader thread terminated.");
        } // run()
    }    //protected boolean relativeTimestampMode=false; // not used anymore //raphael: need this variable to branch in AEReader
    volatile boolean dontwrap = false; // used for resetTimestamps
    private int aeReaderFifoSize = prefs.getInt("CypressFX2.AEReader.fifoSize", 8192);

    /** sets the buffer size for the aereader thread. optimal size depends on event rate, for high event
     *  rates, at least 4096 bytes should be chosen, using caviarviewer and low event rates need smaller
     *  buffer size to produce suitable frame rates*/
    public void setAEReaderFifoSize(int size) {
        this.aeReaderFifoSize = size;
        prefs.putInt("CypressFX2.AEReader.fifoSize", size);
    }
    private int aeReaderNumBuffers = prefs.getInt("CypressFX2.AEReader.numBuffers", 4);

    /** sets the number of buffers for the aereader thread.*/
    public void setAEReaderNumBuffers(int num) {
        this.aeReaderNumBuffers = num;
        prefs.putInt("CypressFX2.AEReader.numBuffers", num);
    }

    /**
     * AE reader class. the thread continually reads events into buffers. when a buffer is read, ProcessData transfers and transforms the buffer data to AE address
     * and timestamps information and puts it in the addresses and timestamps arrays. a call to acquireAvailableEventsFromDriver copies the events to enw user
     * arrays that can be accessed by getEvents() (this packet is also returned by {@link #acquireAvailableEventsFromDriver}). The relevant methods are synchronized so are thread safe.
     */
    public class AEReader extends UsbIoReader implements ReaderBufferControl {

        public final int MAX_NONMONOTONIC_TIME_EXCEPTIONS_TO_PRINT = 10;
        private int numNonMonotonicTimeExceptionsPrinted = 0;
        int cycleCounter = 0;
        volatile boolean timestampsReset = false; // used to tell processData that another thread has reset timestamps
        final int BAD_WRAP_PRINT_INTERVAL = 100; // only print a warning every this many to avoid slowing down critical process
        /** the priority for this monitor acquisition thread. This should be set high (e.g. Thread.MAX_PRIORITY) so that the thread can
         * start new buffer reads in a timely manner so that the sender does not get blocked
         * */
        public static final int MONITOR_PRIORITY = Thread.MAX_PRIORITY; // Thread.NORM_PRIORITY+2
        /** size of CypressFX2 USB fifo's in bytes. */
        public static final int CYPRESS_FIFO_SIZE = 512;
        /** the default number of USB read buffers used in the reader */
        public static final int CYPRESS_NUM_BUFFERS = 2;
        /** the number of capture buffers for the buffer pool for the translated address-events.
         * These buffers allow for smoother access to buffer space by the event capture thread */
        private int numBuffers = prefs.getInt("CypressFX2.AEReader.numBuffers", CYPRESS_NUM_BUFFERS);
        /** size of FIFOs in bytes used in AEReader for event capture from device.
         * This does not have to be the same size as the FIFOs in the CypressFX2 (512 bytes). If it is too small, then there
         * are frequent thread context switches that can greatly slow down rendering loops.
         */
        private int fifoSize = prefs.getInt("CypressFX2.AEReader.fifoSize", CYPRESS_FIFO_SIZE); // 512;
        CypressFX2 monitor = null;

        public AEReader(CypressFX2 m) throws HardwareInterfaceException {
            super();
            monitor = m;
            fifoSize = monitor.aeReaderFifoSize;
            numBuffers = monitor.aeReaderNumBuffers;

            int status;
            status = bind(monitor.getInterfaceNumber(), AE_MONITOR_ENDPOINT_ADDRESS, gDevList, GUID); // device has already been opened so we don't need all the params
            if (status != USBIO_ERR_SUCCESS) {
                throw new HardwareInterfaceException("can't bind pipe: " + UsbIo.errorText(status));
            }

            USBIO_PIPE_PARAMETERS pipeParams = new USBIO_PIPE_PARAMETERS();
            pipeParams.Flags = UsbIoInterface.USBIO_SHORT_TRANSFER_OK;
            status = setPipeParameters(pipeParams);
            if (status != USBIO_ERR_SUCCESS) {
                throw new HardwareInterfaceException("can't set pipe parameters: " + UsbIo.errorText(status));
            }
        }

        public String toString() {
            return "AEReader for " + CypressFX2.this;
        }

        /** Subclsses must override this method to process the raw data to write to the raw event packet buffers
        @param buf the raw byte buffer
         */
        protected void translateEvents(UsbIoBuf buf) {
        }

        // called before buffer is submitted to driver
        public void processBuffer(UsbIoBuf Buf) {
            Buf.NumberOfBytesToTransfer = Buf.Size;
            Buf.BytesTransferred = 0;
            Buf.OperationFinished = false;
        //            System.out.println("ProcessBuffer (before read)");
        }

        /** Resets the timestamp unwrap value, resets the USBIO pipe, and resets the AEPacketRawPool.
         */
        synchronized public void resetTimestamps() {
            log.info(CypressFX2.this + ": wrapAdd=" + wrapAdd + ", zeroing it");
            wrapAdd = WRAP_START;
            timestampsReset = true; // will inform reader thread that timestamps are reset
        }
        
        // log packet times
//        final int NTIMES=100;
//        long[] times=new long[NTIMES];
//        PrintWriter timeWriter=null;
//        long lastTime=System.nanoTime();
        
        
        /** Called on completion of read on a data buffer is received from USBIO driver.
         * @param Buf the data buffer with raw data
         */
        public void processData(UsbIoBuf Buf) {
            cycleCounter++;
            // instrument cycle times
//            long thisTime=System.nanoTime();
//            times[cycleCounter%NTIMES]=thisTime-lastTime;
//            lastTime=thisTime;
//            if(cycleCounter%NTIMES==0){
//                try {
//                    if(timeWriter==null){
//                        timeWriter=new PrintWriter("cycleTimes.csv");
//                    }
//                    for(long t:times){
//                        timeWriter.format("%d\n",t);
//                    }
//                    timeWriter.flush();
//                } catch (FileNotFoundException ex) {
//                    ex.printStackTrace();
//                }
//            }

            synchronized (aePacketRawPool) {
                if (Buf.Status == USBIO_ERR_SUCCESS || Buf.Status == USBIO_ERR_CANCELED) {
                    translateEvents(Buf);
//                    //                System.out.println("ProcessData: "+Buf.BytesTransferred+" bytes transferred: ");
//                    if ((monitor.getPID()==CypressFX2.PID_TMPDIFF128_RETINA) && (monitor.getDID()==CypressFX2.DID_STEREOBOARD))   {
//                        translateEventsWithCPLDEventCode(Buf);
//                    } else if ((monitor.getPID()==PID_USBAERmini2) && (monitor.getDID()==(short)0x0001) ) {
//                        translateEventsWithCPLDEventCode(Buf);
//                      //  CypressFX2MonitorSequencer seq=(CypressFX2MonitorSequencer)(CypressFX2.this);
//                        //                    seq.mapPacket(captureBufferPool.active());
//                        
//                    } else if ((monitor.getPID()==CypressFX2.PID_TMPDIFF128_FX2_SMALL_BOARD) ||( monitor.getPID()==CypressFX2.PID_DVS128_REV0 )) { // the new retina board with a CPLD
//                        translateEventsWithCPLDEventCode(Buf);                      
//                    } else if ((monitor.getPID()==PID_USBAERmini2) || (monitor.getPID()==PID_USB2AERmapper) ) { // USBAERmini2 with old firmware
//                        translateEventsFromOriginalUSB2AERmini2WithOriginalFirmware(Buf);
//                      //  CypressFX2MonitorSequencer seq=(CypressFX2MonitorSequencer)(CypressFX2.this);
//                        //                    seq.mapPacket(captureBufferPool.active());
//                        
//                    } else if(monitor.getPID()==PID_TCVS320_RETINA){
//                        translateEvents_TCVS320(Buf);
//                    } else { // original format with timestamps that just wrap
//                        translateEventsFromTmpdiff128OriginalBoard(Buf);
//                    }
//                    //                pop.play();

                    if (chip != null && chip.getFilterChain() != null && chip.getFilterChain().getProcessingMode() == FilterChain.ProcessingMode.ACQUISITION) {
                        // here we do the realTimeFiltering. We finished capturing this buffer's worth of events, now process them
                        // apply realtime filters and realtime (packet level) mapping

                        // synchronize here so that rendering thread doesn't swap the buffer out from under us while we process these events
                        // aePacketRawPool.writeBuffer is also synchronized so we get the same lock twice which is ok
                        AEPacketRaw buffer = aePacketRawPool.writeBuffer();
                        int[] addresses = buffer.getAddresses();
                        int[] timestamps = buffer.getTimestamps();
                        realTimeFilter(addresses, timestamps);
                    }
                } else {
                    log.warning("ProcessData: Bytes transferred: " + Buf.BytesTransferred + "  Status: " + UsbIo.errorText(Buf.Status));
                    monitor.close();
                }
                if (timestampsReset) {
//                    log.info("timestampsReset: flushing aePacketRawPool buffers");
//                    don't flush, just let the old data through since it is still data
//                    aePacketRawPool.reset();  //this is already done in resetTimestamps() why do it again here?
                    timestampsReset = false;
                }
            }
        }        // sync so that we don't try to copy events while buffer is being translated
        
        
        final int WRAP_START = 0; //(int)(0xFFFFFFFFL&(2147483648L-0x400000L)); // set high to test big wrap 1<<30;
        /** wrapAdd is the time to add to short timestamp to unwrap it */
        protected int wrapAdd = WRAP_START; //0;
        protected int lastWrapAdd = 0;
        /** used to indicate a 32 bit timestamp wrap */
        protected boolean wrappedBig = false;  // indicates that wrapAdd has just wrapped itself, so that we should allow nonmonotonic timestamp

        public void bufErrorHandler(UsbIoBuf Buf) {
            if (Buf.Status != USBIO_ERR_SUCCESS) {
                // print error
                // suppress CANCELED because it is caused by ABORT_PIPE
                if (Buf.Status != USBIO_ERR_CANCELED) {
                    log.warning("USB buffer error: " + Buf.Status);
                }
                if (Buf.Status == USBIO_ERR_DEVICE_GONE) {
                    log.warning("CypressFX2.bufErrorHandler(): device gone, shutting down buffer pool thread");
                    monitor.close();
                }
            }
        }
        // virtual function, called in the context of worker thread
        public void onThreadExit() {
            freeBuffers();
            // System.out.println(this+" event capture worker-thread terminated.\n");
            monitor.aeReaderRunning = false;
        }
        // overridden to change priority
        public void startThread(int MaxIoErrorCount) {
//            log.info("CypressFX2.AEReader.startThread()");
            allocateBuffers(getFifoSize(), getNumBuffers());
            super.startThread(MaxIoErrorCount);
            T.setPriority(MONITOR_PRIORITY); // very important that this thread have priority or the acquisition will stall on device side for substantial amounts of time!
            T.setName("AEReader");
//            System.out.println(this+ " event capture worker-thread started");
            monitor.aeReaderRunning = true;
            getSupport().firePropertyChange("readerStarted", false, true); // used in AEViewer to set up menus for changing buffer size
        }

        public int getFifoSize() {
            return fifoSize;
        }

        public void setFifoSize(int fifoSize) {
            if (fifoSize < CYPRESS_FIFO_SIZE) {
                log.warning("CypressFX2 fifo size clipped to device FIFO size " + CYPRESS_FIFO_SIZE);
                fifoSize = CYPRESS_FIFO_SIZE;
            }
            this.fifoSize = fifoSize;
            freeBuffers();
            allocateBuffers(fifoSize, numBuffers);
            prefs.putInt("CypressFX2.AEReader.fifoSize", fifoSize);
        }

        public int getNumBuffers() {
            return numBuffers;
        }

        public void setNumBuffers(int numBuffers) {
            this.numBuffers = numBuffers;
            freeBuffers();
            allocateBuffers(fifoSize, numBuffers);
            prefs.putInt("CypressFX2.AEReader.numBuffers", numBuffers);
        }

        /**
         * Applies the filterChain processing on the most recently captured data. The processing is done
         * by extracting the events just captured and then applying the filter chain.
         * <strong>The filter outputs are discarded and
         * will not be visble in the rendering of the chip output, but may be used for motor control or other purposes.
         * </strong>
         * <p>
         * TODO: at present this processing is redundant in that the most recently captured events are copied to a
         * different AEPacketRaw, extracted to an EventPacket, and then processed. This effort is duplicated
         * later in rendering. This should be fixed somehow.
         * @param addresses the raw input addresses; these are filtered in place
         * @param timestamps the input timestamps
         */
        private void realTimeFilter(int[] addresses, int[] timestamps) {

            if (!chip.getFilterChain().isAnyFilterEnabled()) {
                return;
            }
            int nevents = getNumRealTimeEvents();

            // initialize packets
            if (realTimeRawPacket == null) {
                realTimeRawPacket = new AEPacketRaw(nevents);  // TODO: expensive
            } else {
                realTimeRawPacket.ensureCapacity(nevents);//                // copy data to real time raw packet
//                if(addresses==null || timestamps==null){
//                    log.warning("realTimeFilter: addresses or timestamp array became null");
//                }else{
            }
            try {
                System.arraycopy(addresses, realTimeEventCounterStart, realTimeRawPacket.getAddresses(), 0, nevents);
                System.arraycopy(timestamps, realTimeEventCounterStart, realTimeRawPacket.getTimestamps(), 0, nevents);
            } catch (IndexOutOfBoundsException e) {
                e.printStackTrace();
            }
            realTimeEventCounterStart = eventCounter;
            //   System.out.println("RealTimeEventCounterStart: " + realTimeEventCounterStart + " nevents " + nevents + " eventCounter " + eventCounter);
            realTimeRawPacket.setNumEvents(nevents);
            // init extracted packet
            // if(realTimePacket==null)
            //   realTimePacket=new EventPacket(chip.getEventClass());
            // extract events for this filter. This duplicates later effort during rendering and should be fixed for later.
            // at present this may mess up everything else because the output packet is reused.


            // hack for stereo hardware interfaces - for real time processing we must label the eye bit here based on which eye our hardware 
            // interface is. note the events are labeled here and the real time processing method is called for each low level hardware interface.
            // But each call will only get events from one eye. it is important that the filterPacket method be sychronized (thread safe) because the 
            // filter object may get called by both AEReader threads at the "same time"
            if (chip.getHardwareInterface() instanceof StereoHardwareInterface) {
                StereoHardwareInterface stereoInterface = (StereoHardwareInterface) chip.getHardwareInterface();
                if (stereoInterface.getAemonLeft() == CypressFX2.this) {
                    stereoInterface.labelLeftEye(realTimeRawPacket);
                } else {
                    stereoInterface.labelRightEye(realTimeRawPacket);
                }
            }
            // regardless, we now extract to typed events for example and process
           realTimePacket = chip.getEventExtractor().extractPacket(realTimeRawPacket); //,realTimePacket);

           try{
            getChip().getFilterChain().filterPacket(realTimePacket);
           }catch(Exception e){
                log.warning(e.toString()+": disabling all filters");
                e.printStackTrace();
                 for(EventFilter f : getChip().getFilterChain()) {
                    f.setFilterEnabled(false);
                }
           }
        // we don't do following because the results are an AEPacketRaw that still needs to be written to addresses/timestamps
        // and this is not done yet. at present results of realtime filtering are just not rendered at all.
        // that means that user will see raw events, e.g. if BackgroundActivityFilter is used, then user will still see all
        // events because the filters are not applied for normal rendering. (If they were applied, then the filters would
        // be in a funny state becaues they would process the same data more than once and out of order, resulting in all kinds
        // of problems.)
        // However, the graphical annotations (like the boxes drawn around clusters in RectangularClusterTracker)
        // done by the real time processing are still shown when the rendering thread calls the
        // annotate methods.

//            chip.getEventExtractor().reconstructRawPacket(realTimePacket);
        }
    }

    private int getNumRealTimeEvents() {
        return eventCounter - realTimeEventCounterStart;
    }

    void allocateAEBuffers() {
        synchronized (aePacketRawPool) {
            aePacketRawPool.allocateMemory();
        }
    }

    /** @return the size of the double buffer raw packet for AEs */
    public int getAEBufferSize() {
        return aeBufferSize; // aePacketRawPool.writeBuffer().getCapacity();
    }

    /** set the size of the raw event packet buffer. Default is AE_BUFFER_SIZE. You can set this larger if you
     *have overruns because your host processing (e.g. rendering) is taking too long.
     *<p>
     *This call discards collected events.
     * @param size of buffer in events
     */
    public void setAEBufferSize(int size) {
        if (size < 1000 || size > 1000000) {
            log.warning("ignoring unreasonable aeBufferSize of " + size + ", choose a more reasonable size between 1000 and 1000000");
            return;
        }
        this.aeBufferSize = size;
        prefs.putInt("CypressFX2.aeBufferSize", aeBufferSize);
        allocateAEBuffers();
    }

    public void onAdd() {
        log.info("USBAEMonitor.onAdd(): device added");
    }

    public void onRemove() {
        log.info("USBAEMonitor.onRemove(): device removed");
    }

    /** start or stops the event acquisition. sends apropriate vendor request to
     * device and starts or stops the AEReader
     * @param enable boolean to enable or disable event acquisition
     */
    synchronized public void setEventAcquisitionEnabled(boolean enable) throws HardwareInterfaceException {
//        log.info("setting event acquisition="+enable);
        setInEndpointEnabled(enable);
        if (enable) {
            startAEReader();
        } else {
            stopAEReader();
        }
    }

    public boolean isEventAcquisitionEnabled() {
        return isInEndpointEnabled();
    }

    public String getTypeName() {
        return "CypressFX2";
    }
    /** the first USB string descriptor (Vendor name) (if available) */
    protected USB_STRING_DESCRIPTOR stringDescriptor1 = new USB_STRING_DESCRIPTOR();
    /** the second USB string descriptor (Product name) (if available) */
    protected USB_STRING_DESCRIPTOR stringDescriptor2 = new USB_STRING_DESCRIPTOR();
    /** the third USB string descriptor (Serial number) (if available) */
    protected USB_STRING_DESCRIPTOR stringDescriptor3 = new USB_STRING_DESCRIPTOR();
    protected int numberOfStringDescriptors = 2;

    /** returns number of string descriptors
     * @return number of string descriptors: 2 for TmpDiff128, 3 for MonitorSequencer */
    public int getNumberOfStringDescriptors() {
        return numberOfStringDescriptors;
    }
    /** the USBIO device descriptor */
    protected USB_DEVICE_DESCRIPTOR deviceDescriptor = new USB_DEVICE_DESCRIPTOR();
    /** the UsbIo interface to the device. This is assigned on construction by the
     * factory which uses it to open the device. here is used for all USBIO access
     * to the device*/
    protected UsbIo gUsbIo = null;
    /** the devlist handle for USBIO */
    protected int gDevList; // 'handle' (an integer) to an internal device list static to UsbIo

    /** checks if device has a string identifier that is a non-empty string
     *@return false if not, true if there is one
     */
    protected boolean hasStringIdentifier() {
        // get string descriptor
        status = gUsbIo.getStringDescriptor(stringDescriptor1, (byte) 1, 0);
        if (status != USBIO_ERR_SUCCESS) {
            return false;
        } else {
            if (stringDescriptor1.Str.length() > 0) {
                return true;
            }
        }
        return false;
    }

    /** constrcuts a new USB connection, opens it. Does NOT start event acquisition.
     * @see #setEventAcquisitionEnabled
     */
    public void open() throws HardwareInterfaceException {
//        log.info(Thread.currentThread()+": CypressFX2.open()");
        openUsbIo();
//        setEventAcquisitionEnabled(true); // don't enable anymore, do this instead in acquireAvailableEventsFromDriver if necessary
        HardwareInterfaceException.clearException();
    }

    /**
     * This method does the hard work of opening the device, downloading the firmware, making sure everything is OK.
     *<p>
     * This method is synchronized to prevent multiple threads from trying to open at the same time, e.g. a GUI thread and the main thread.
     *<p>
     * Opening the device after it has already been opened has no effect.
     *
     * @see #close
     *@throws HardwareInterfaceException if there is a problem. Diagnostics are printed to stderr.
     */
    synchronized protected void openUsbIo() throws HardwareInterfaceException {

        //device has already been UsbIo Opened by now, in factory

        // opens the USBIOInterface device, configures it, binds a reader thread with buffer pool to read from the device and starts the thread reading events.
        // we got a UsbIo object when enumerating all devices and we also made a device list. the device has already been
        // opened from the UsbIo viewpoint, but it still needs firmware download, setting up pipes, etc.

        if (isOpened) {
//            log.warning("CypressFX2.openUsbIo(): already opened interface and setup device");
            return;
        }

        int status;

        gUsbIo = new UsbIo();
        gDevList = UsbIo.createDeviceList(GUID);
        status = gUsbIo.open(getInterfaceNumber(), gDevList, GUID);
        if (status != USBIO_ERR_SUCCESS) {
            UsbIo.destroyDeviceList(gDevList);
            isOpened = false;
            throw new HardwareInterfaceException("CypressFX2.openUsbIo(): can't open USB device: " + UsbIo.errorText(status));
        }

        status = gUsbIo.acquireDevice();
        if (status != USBIO_ERR_SUCCESS) {
            log.warning("couldn't acquire device for exclusive use");
            throw new HardwareInterfaceException("couldn't acquire device for exclusive use: " + UsbIo.errorText(status));
        }

        // get device descriptor (possibly before firmware download, when still bare cypress device or running off EEPROM firmware)
        status = gUsbIo.getDeviceDescriptor(deviceDescriptor);
        if (status != USBIO_ERR_SUCCESS) {
            UsbIo.destroyDeviceList(gDevList);
            throw new HardwareInterfaceException("CypressFX2.openUsbIo(): getDeviceDescriptor: " + UsbIo.errorText(status));
        } else {
//            log.info("getDeviceDescriptor: Vendor ID (VID) "
//                    + HexString.toString((short)deviceDescriptor.idVendor)
//                    + " Product ID (PID) " + HexString.toString((short)deviceDescriptor.idProduct));
        }

        checkBlankDevice();

        // possibly download binary firmware to Cypress RAM
        downloadFirmwareBinary();

        boolean success = false;
        int triesLeft = 10;
        long delay = 400;
        while (!success && triesLeft > 0) {
            try {
                Thread.currentThread().sleep(delay);
            } catch (InterruptedException e) {
            }
            gDevList = UsbIo.createDeviceList(GUID);
            gUsbIo = new UsbIo();
            status = gUsbIo.open(getInterfaceNumber(), gDevList, GUID);
            if (status != USBIO_ERR_SUCCESS) {
                UsbIo.destroyDeviceList(gDevList);
                triesLeft--;
            } else {
                success = true;
            }
        }
        if (!success) {
            throw new HardwareInterfaceException("couldn't reopen device after firmware download and renumeration: " + UsbIo.errorText(status));
        }
        try {
            unconfigureDevice(); // in case it was left configured from a terminated process
        } catch (HardwareInterfaceException e) {
            log.warning("CypressFX2.open(): can't unconfigure,will try simulated disconnect");
            int cycleStatus = gUsbIo.cyclePort();
            if (cycleStatus != USBIO_ERR_SUCCESS) {
                throw new HardwareInterfaceException("Error cycling port: " + UsbIo.errorText(cycleStatus));
            }
            throw new HardwareInterfaceException("couldn't unconfigure device");
        }

        // set configuration -- must do this BEFORE downloading firmware!
        USBIO_SET_CONFIGURATION Conf = new USBIO_SET_CONFIGURATION();
        Conf.ConfigurationIndex = CONFIG_INDEX;
        Conf.NbOfInterfaces = CONFIG_NB_OF_INTERFACES;
        Conf.InterfaceList[0].InterfaceIndex = CONFIG_INTERFACE;
        Conf.InterfaceList[0].AlternateSettingIndex = CONFIG_ALT_SETTING;
        Conf.InterfaceList[0].MaximumTransferSize = CONFIG_TRAN_SIZE;
        status = gUsbIo.setConfiguration(Conf);
        if (status != USBIO_ERR_SUCCESS) {
//            gUsbIo.destroyDeviceList(gDevList);
            //   if (status !=0xE0001005)
            throw new HardwareInterfaceException("CypressFX2.openUsbIo(): setting configuration after firmware download: " + UsbIo.errorText(status));
        }

        //        try{Thread.currentThread().sleep(100);} catch(InterruptedException e){}; // pause for renumeration

        //        System.out.println("after firmware download and reenumeration, descriptors are");
        // get device descriptor
        status = gUsbIo.getDeviceDescriptor(deviceDescriptor);
        if (status != USBIO_ERR_SUCCESS) {
            UsbIo.destroyDeviceList(gDevList);
            throw new HardwareInterfaceException("CypressFX2.openUsbIo(): getDeviceDescriptor: " + UsbIo.errorText(status));
        } else {
//            log.info("getDeviceDescriptor: Vendor ID (VID) "
//                    + HexString.toString((short)deviceDescriptor.idVendor)
//                    + " Product ID (PID) " + HexString.toString((short)deviceDescriptor.idProduct));
        }

        if (deviceDescriptor.iSerialNumber != 0) {
            this.numberOfStringDescriptors = 3;        // get string descriptor
        }
        status = gUsbIo.getStringDescriptor(stringDescriptor1, (byte) 1, 0);
        if (status != USBIO_ERR_SUCCESS) {
            UsbIo.destroyDeviceList(gDevList);
            throw new HardwareInterfaceException("CypressFX2.openUsbIo(): getStringDescriptor: " + UsbIo.errorText(status));
        } else {
//            log.info("getStringDescriptor 1: " + stringDescriptor1.Str);
        }

        // get string descriptor
        status = gUsbIo.getStringDescriptor(stringDescriptor2, (byte) 2, 0);
        if (status != USBIO_ERR_SUCCESS) {
            UsbIo.destroyDeviceList(gDevList);
            throw new HardwareInterfaceException("CypressFX2.openUsbIo(): getStringDescriptor: " + UsbIo.errorText(status));
        } else {
//            log.info("getStringDescriptor 2: " + stringDescriptor2.Str);
        }

        if (this.numberOfStringDescriptors == 3) {
            // get serial number string descriptor
            status = gUsbIo.getStringDescriptor(stringDescriptor3, (byte) 3, 0);
            if (status != USBIO_ERR_SUCCESS) {
                UsbIo.destroyDeviceList(gDevList);
                throw new HardwareInterfaceException("CypressFX2.openUsbIo(): getStringDescriptor: " + UsbIo.errorText(status));
            } else {
//                log.info("getStringDescriptor 3: " + stringDescriptor3.Str);
            }
        }

        if (!gUsbIo.isOperatingAtHighSpeed()) {
            log.warning("CypressFX2.openUsbIo(): Warning: device is not operating at USB 2.0 High Speed, performance will be limited to about 300 keps");
        }

        // get pipe information and extract the FIFO size
        USBIO_CONFIGURATION_INFO ConfigurationInfo = new USBIO_CONFIGURATION_INFO();
        status = gUsbIo.getConfigurationInfo(ConfigurationInfo);
        if (status != USBIO_ERR_SUCCESS) {
            UsbIo.destroyDeviceList(gDevList);
            throw new HardwareInterfaceException("CypressFX2.openUsbIo(): getConfigurationInfo: " + UsbIo.errorText(status));
        }

        if (ConfigurationInfo.NbOfPipes == 0) {
//            gUsbIo.cyclePort();
            throw new HardwareInterfaceException("CypressFX2.openUsbIo(): didn't find any pipes to bind to");
        }

        // start the thread that listens for device status information (e.g. timestamp reset)
        asyncStatusThread = new AsyncStatusThread(this);
        asyncStatusThread.start();
//        log.info("resetting 8051");
//        set8051Reset(true);
//        set8051Reset(false);

        isOpened = true;

    }

    synchronized protected void openUsbIo_minimal() throws HardwareInterfaceException {

        //device has already been UsbIo Opened by now, in factory

        // opens the USBIOInterface device, configures it, binds a reader thread with buffer pool to read from the device and starts the thread reading events.
        // we got a UsbIo object when enumerating all devices and we also made a device list. the device has already been
        // opened from the UsbIo viewpoint, but it still needs firmware download, setting up pipes, etc.

        if (isOpened) {
//            log.warning("CypressFX2.openUsbIo(): already opened interface and setup device");
            return;
        }

        int status;

        gUsbIo = new UsbIo();
        gDevList = UsbIo.createDeviceList(GUID);
        status = gUsbIo.open(getInterfaceNumber(), gDevList, GUID);
        if (status != USBIO_ERR_SUCCESS) {
            UsbIo.destroyDeviceList(gDevList);
            isOpened = false;
            throw new HardwareInterfaceException("CypressFX2.openUsbIo(): can't open USB device: " + UsbIo.errorText(status));
        }

        // get device descriptor (possibly before firmware download, when still bare cypress device or running off EEPROM firmware)
        status = gUsbIo.getDeviceDescriptor(deviceDescriptor);
        if (status != USBIO_ERR_SUCCESS) {
            UsbIo.destroyDeviceList(gDevList);
            throw new HardwareInterfaceException("CypressFX2.openUsbIo(): getDeviceDescriptor: " + UsbIo.errorText(status));
        } else {
//            log.info("getDeviceDescriptor: Vendor ID (VID) "
//                    + HexString.toString((short)deviceDescriptor.idVendor)
//                    + " Product ID (PID) " + HexString.toString((short)deviceDescriptor.idProduct));
        }

        checkBlankDevice();

        // possibly download binary firmware to Cypress RAM

        if (!this.hasStringIdentifier()) {
            downloadFirmwareBinary();

            boolean success = false;
            int triesLeft = 10;
            long delay = 400;
            while (!success && triesLeft > 0) {
                try {
                    Thread.currentThread().sleep(delay);
                } catch (InterruptedException e) {
                }
                gDevList = UsbIo.createDeviceList(GUID);
                gUsbIo = new UsbIo();
                status = gUsbIo.open(getInterfaceNumber(), gDevList, GUID);
                if (status != USBIO_ERR_SUCCESS) {
                    UsbIo.destroyDeviceList(gDevList);
                    triesLeft--;
                } else {
                    success = true;
                }
            }
            if (!success) {
                throw new HardwareInterfaceException("couldn't reopen device after firmware download and renumeration: " + UsbIo.errorText(status));
            }
        }
//        try{
//            unconfigureDevice(); // in case it was left configured from a terminated process
//        }catch(HardwareInterfaceException e){
//            log.warning("CypressFX2.open(): can't unconfigure,will try simulated disconnect");
//            int cycleStatus=gUsbIo.cyclePort();
//            if(cycleStatus!=USBIO_ERR_SUCCESS){
//                throw new HardwareInterfaceException("Error cycling port: "+UsbIo.errorText(cycleStatus));
//            }
//            throw new HardwareInterfaceException("couldn't unconfigure device");
//        }

//        // set configuration -- must do this BEFORE downloading firmware!
//        USBIO_SET_CONFIGURATION Conf = new USBIO_SET_CONFIGURATION();
//        Conf.ConfigurationIndex = CONFIG_INDEX;
//        Conf.NbOfInterfaces = CONFIG_NB_OF_INTERFACES;
//        Conf.InterfaceList[0].InterfaceIndex = CONFIG_INTERFACE;
//        Conf.InterfaceList[0].AlternateSettingIndex = CONFIG_ALT_SETTING;
//        Conf.InterfaceList[0].MaximumTransferSize = CONFIG_TRAN_SIZE;
//        status = gUsbIo.setConfiguration(Conf);
//        if (status != USBIO_ERR_SUCCESS) {
////            gUsbIo.destroyDeviceList(gDevList);
//            //   if (status !=0xE0001005)
//            throw new HardwareInterfaceException("CypressFX2.openUsbIo(): setting configuration after firmware download: "+UsbIo.errorText(status));
//        }

        //        try{Thread.currentThread().sleep(100);} catch(InterruptedException e){}; // pause for renumeration

        //        System.out.println("after firmware download and reenumeration, descriptors are");
        // get device descriptor
        status = gUsbIo.getDeviceDescriptor(deviceDescriptor);
        if (status != USBIO_ERR_SUCCESS) {
            UsbIo.destroyDeviceList(gDevList);
            throw new HardwareInterfaceException("CypressFX2.openUsbIo(): getDeviceDescriptor: " + UsbIo.errorText(status));
        } else {
//            log.info("getDeviceDescriptor: Vendor ID (VID) "
//                    + HexString.toString((short)deviceDescriptor.idVendor)
//                    + " Product ID (PID) " + HexString.toString((short)deviceDescriptor.idProduct));
        }

        if (deviceDescriptor.iSerialNumber != 0) {
            this.numberOfStringDescriptors = 3;        // get string descriptor
        }
        status = gUsbIo.getStringDescriptor(stringDescriptor1, (byte) 1, 0);
        if (status != USBIO_ERR_SUCCESS) {
            UsbIo.destroyDeviceList(gDevList);
            throw new HardwareInterfaceException("CypressFX2.openUsbIo(): getStringDescriptor: " + UsbIo.errorText(status));
        } else {
//            log.info("getStringDescriptor 1: " + stringDescriptor1.Str);
        }

        // get string descriptor
        status = gUsbIo.getStringDescriptor(stringDescriptor2, (byte) 2, 0);
        if (status != USBIO_ERR_SUCCESS) {
            UsbIo.destroyDeviceList(gDevList);
            throw new HardwareInterfaceException("CypressFX2.openUsbIo(): getStringDescriptor: " + UsbIo.errorText(status));
        } else {
//            log.info("getStringDescriptor 2: " + stringDescriptor2.Str);
        }

        if (this.numberOfStringDescriptors == 3) {
            // get serial number string descriptor
            status = gUsbIo.getStringDescriptor(stringDescriptor3, (byte) 3, 0);
            if (status != USBIO_ERR_SUCCESS) {
                UsbIo.destroyDeviceList(gDevList);
                throw new HardwareInterfaceException("CypressFX2.openUsbIo(): getStringDescriptor: " + UsbIo.errorText(status));
            } else {
//                log.info("getStringDescriptor 3: " + stringDescriptor3.Str);
            }
        }
    }
// unconfigure device in case it was still configured from a prior terminated process
    synchronized void unconfigureDevice() throws HardwareInterfaceException {
        int status;
//        System.out.println("CypressFX2RetinaBiasgen.unconfigureDevice()");
        status = gUsbIo.unconfigureDevice();
        if (status != USBIO_ERR_SUCCESS) {
            gUsbIo.destroyDeviceList(gDevList);
            //System.out.println("unconfigureDevice: "+UsbIo.errorText(status));
            //            throw new USBAEMonitorException("getStringDescriptor: "+gUsbIo.errorText(status));
            throw new HardwareInterfaceException("unconfigureDevice: " + UsbIo.errorText(status));
        //            System.out.println("getConfigurationInfo ok");
        }
    //        System.out.println("unconfigured device");
    }

    /** return the string USB descriptors for the device
     *@return String[] of length 2 of USB descriptor strings.
     */
    public String[] getStringDescriptors() {
        if (stringDescriptor1 == null) {
            log.warning("USBAEMonitor: getStringDescriptors called but device has not been opened");
            String[] s = new String[numberOfStringDescriptors];
            for (int i = 0; i < numberOfStringDescriptors; i++) {
                s[i] = "";
            }
            return s;
        }
        String[] s = new String[numberOfStringDescriptors];
        s[0] = stringDescriptor1.Str;
        s[1] = stringDescriptor2.Str;
        if (numberOfStringDescriptors == 3) {
            s[2] = stringDescriptor3.Str;
        }
        return s;
    }

    /** return the USB VID/PID of the interface
     *@return int[] of length 2 containing the Vendor ID (VID) and Product ID (PID) of the device. First element is VID, second element is PID.
     */
    public int[] getVIDPID() {
        if (deviceDescriptor == null) {
            log.warning("USBAEMonitor: getVIDPID called but device has not been opened");
            return new int[2];
        }
        int[] n = new int[2];
        n[0] = deviceDescriptor.idVendor;
        n[1] = deviceDescriptor.idProduct;
        return n;
    }

    public short getVID() {
        if (deviceDescriptor == null) {
            log.warning("USBAEMonitor: getVIDPID called but device has not been opened");
            return 0;
        }
        // int[] n=new int[2]; n is never used
        return (short) deviceDescriptor.idVendor;
    }

    public short getPID() {
        if (deviceDescriptor == null) {
            log.warning("USBAEMonitor: getVIDPID called but device has not been opened");
            return 0;
        }
        return (short) deviceDescriptor.idProduct;
    }

    /** @return bcdDevice (the binary coded decimel device version */
    public short getDID() { // this is not part of USB spec in device descriptor.
        return (short) deviceDescriptor.bcdDevice;
    }

    /** reports if interface is {@link #open}.
     * @return true if already open
     */
    public boolean isOpen() {
        return isOpened;
    }

    /** Loads a binary firmware file into memory.
     * The filename is used to search the resource path (i.e. the jar archives on the classpath).
     *@param firmwareFilename the resource path
     **/
    public byte[] loadBinaryFirmwareFile(String firmwareFilename) throws IOException {
        log.info("loading firmware file " + firmwareFilename);
        InputStream firmwareFileStream;
        byte[] fwBuffer;
        // load firmware file (this is binary file of 8051 firmware)
        try {
            firmwareFileStream = getClass().getResourceAsStream(firmwareFilename);
            if (firmwareFileStream != null) {
                fwBuffer = new byte[firmwareFileStream.available()];
                firmwareFileStream.read(fwBuffer);
                firmwareFileStream.close();
            } else {
                fwBuffer = loadBinaryFirmwareFileSystemFile(firmwareFilename);
            }
        } catch (IOException e) {
            close();
            log.warning(e.getMessage());
            throw new IOException("can't load binary Cypress FX2 firmware file " + firmwareFilename);
        }
        return fwBuffer;
    }

    /** Loads a binary firmware file into memory from a file system path (as opposed to resource path).
     *@param firmwareFilename the file path
     **/
    public byte[] loadBinaryFirmwareFileSystemFile(String firmwareFilename) throws IOException {
        log.info("writing firmware file " + firmwareFilename);
        InputStream firmwareFileStream;
        byte[] fwBuffer;
        // load firmware file (this is binary file of 8051 firmware)
        try {
            File f = new File(firmwareFilename);
            firmwareFileStream = new FileInputStream(f);
            fwBuffer = new byte[firmwareFileStream.available()];
            firmwareFileStream.read(fwBuffer);
            firmwareFileStream.close();
        } catch (IOException e) {
            close();
            log.warning(e.getMessage());
            throw new IOException("can't load binary Cypress FX2 firmware file " + firmwareFilename);
        }
        return fwBuffer;
    }

    /** downloads firmware to FX2 RAM. adapted from John Arthur's example, which comes from Cypress example.
     * Firmware file is a binary file produced by uVision2 (Keil) from source code for firmware.
     *<p>
     *Firmware that is actually downloaded depends on discovered PID of device. If the PID is discovered to be a bare CypressFX2, then
     *a dialog is shown that user can use to program the VID/PID of the device.
     *<p>
     *In addition, there is a problem if firmware is downloaded more than once to an FX2LP device between hard resets. Therefore if this method detects
     *that the device has string identitifers, it assumes the firmware has already been downloaded.
     *
     *
     * Firmware file is loaded as a resource from the jar archive.
     */
    synchronized void downloadFirmwareBinary(String firmwareFilename) throws HardwareInterfaceException {

        byte[] fwBuffer; // buffer to hold contents of firmware file (binary 8051 code)

        try {
            fwBuffer = loadBinaryFirmwareFile(firmwareFilename);
        } catch (IOException e) {
            close();
            log.warning(e.getMessage());
            throw new HardwareInterfaceException("can't load binary Cypress FX2 firmware file " + firmwareFilename);
        }

        set8051Reset(true);
        download8051RAM(0, fwBuffer);
        set8051Reset(false);
    }

    /** downloads firmware to FX2 RAM. adapted from John Arthur's example, which comes from Cypress example.
     * Firmware file is a binary file produced by uVision2 (Keil) from source code for firmware.
     *<p>
     *Firmware that is actually downloaded depends on discovered PID of device. If the PID is discovered to be a bare CypressFX2, then
     *a dialog is shown that user can use to program the VID/PID of the device.
     *<p>
     *In addition, there is a problem if firmware is downloaded more than once to an FX2LP device between hard resets. Therefore if this method detects
     *that the device has string identitifers, it assumes the firmware has already been downloaded.
     *
     *
     * Firmware file is loaded as a resource from the jar archive.
     */
    synchronized void downloadFirmwareBinary() throws HardwareInterfaceException {

        if (hasStringIdentifier()) {
            return;
        }
        log.info("device has no string identifier, downloading firmware to RAM");

        //  firmware load variables
        byte[] fwBuffer; // buffer to hold contents of firmware file (binary 8051 code)

        String firmwareFilename = getFirmwareFilenameBinaryFromVIDPID();

        try {
            fwBuffer = loadBinaryFirmwareFile(firmwareFilename);
        } catch (IOException e) {
            close();
            log.warning(e.getMessage());
            throw new HardwareInterfaceException("can't load binary Cypress FX2 firmware file " + firmwareFilename);
        }

        set8051Reset(true);
        download8051RAM(0, fwBuffer);
        set8051Reset(false);


    } // downloadFirmwareBinary()

    /**
     * Returns the firmware filenmae corresponding to a VID/PID pair.
     * This filename is a full path to a resource on the classpath which is in the project jar jAER.jar.
     *
     */
    protected String getFirmwareFilenameBinaryFromVIDPID() {
        final String defaultResource = FIRMWARE_FILENAME_TCVS320_BIX;
        String firmwareFilename = null;
        if (getPID() == PID_USBAERmini2_without_firmware) {
            firmwareFilename = FIRMWARE_FILENAME_MONITOR_SEQUENCER;
        } else if (getPID() == PID_USBAERmini2) {
            firmwareFilename = FIRMWARE_FILENAME_MONITOR_SEQUENCER;
        } else if (getPID() == PID_TCVS320_RETINA) {
            firmwareFilename = FIRMWARE_FILENAME_TCVS320_BIX;
        } else if (getPID() == PID_TMPDIFF128_RETINA) {
            firmwareFilename = FIRMWARE_FILENAME_TMPDIFF128_BIX;
        } else {
            log.warning("unknown device product ID (PID)=" + HexString.toString(getPID()) + ", assuming this needs " + defaultResource);
            firmwareFilename = defaultResource;
        }

        return firmwareFilename;
    }
    // returns the firmware filenmae corresponding to a VID/PID pair
    // this filename is actually a full path to a resource on the classpath
    protected String getFirmwareFilenameHexFromVIDPID() {
        String firmwareFilename = null;
        if (getPID() == PID_USBAERmini2_without_firmware) {
            firmwareFilename = FIRMWARE_FILENAME_MONITOR_SEQUENCER_HEX;
        } else {
            firmwareFilename = FIRMWARE_FILENAME_TMPDIFF128_HEX;
        }
        return firmwareFilename;
    }

    /** Downloads to RAM on FX2 using built-in vendor request to CPUCS.
     * Remember to set8051Reset() before and after calling this method.
     *@param address the starting address in the 8051 RAM
     *@param FWBuffer the data
     *@see #set8051Reset
     */
    protected void download8051RAM(int address, final byte[] FWBuffer)
            throws HardwareInterfaceException {
        log.info("downloading " + FWBuffer.length + " bytes to CypressFX2 RAM starting at " + address);
        /* From Fx2 tech ref guide, chapter 2 "endpoint 0"
         *
         *The USB endpoint-zero protocol provides a mechanism for mixing
        vendor-specific requests with standard device requests. Bits 6:5 of the bmRequestType
        field are set to 00 for a standard device request and to 10 for a vendor request.
         **/
        // need to perform the following steps:
        //
        //	1) reset the Cypress (write 0x01 into CPUCS register)
        //	2) send the firmware to Control Endpoint 0
        //	3) pull the Cypress out of reset (write 0x00 into the CPUCS register)

        // this is achieved by using the vendor request VENDOR_REQUEST_FIRMWARE, where the Value of the request is the
        // address to write to and the buffer passed to USBIO_CLASS_OR_VENDOR_REQUEST defines data to be written
        // starting at this address and the number of bytes to be written.
        // thus the same vendor request can reset the 8051 (one byte written to CPUCS) and download successive chunks
        // of code. finally the request can unreset the 8051.

        int result;
        USBIO_CLASS_OR_VENDOR_REQUEST vendorRequest = new USBIO_CLASS_OR_VENDOR_REQUEST();
        USBIO_DATA_BUFFER dataBuffer;
        int fwIndex;
        int numChunks;

        vendorRequest.Flags = UsbIoInterface.USBIO_SHORT_TRANSFER_OK;
        vendorRequest.Type = UsbIoInterface.RequestTypeVendor;  // this is a vendor, not generic USB, request
        vendorRequest.Recipient = UsbIoInterface.RecipientDevice; // device (not endpoint, interface, etc) receives it
        vendorRequest.RequestTypeReservedBits = 0;    // set these bits to zero for Cypress-specific 'vendor request' rather that user defined
        vendorRequest.Request = VENDOR_REQUEST_FIRMWARE; // this is download/upload firmware request. really it is just a 'fill RAM request'
        vendorRequest.Index = 0;

        //	2) send the firmware to Control Endpoint 0
        // when sending firmware, we need to break up the loaded fimware
        //		into MAX_CONTROL_XFER_SIZE blocks
        //
        // this means:
        //	a) the address to load it to needs to be changed (VendorRequest.Value)
        //	b) need a pointer that moves through FWbuffer (pBuffer)
        //	c) keep track of remaining bytes to transfer (FWsize_left);


        //send all but last chunk
        vendorRequest.Value = 0;			//address of firmware location
        dataBuffer = new USBIO_DATA_BUFFER(MAX_CONTROL_XFER_SIZE);
        dataBuffer.setNumberOfBytesToTransfer(dataBuffer.Buffer().length);
        fwIndex = 0;
        numChunks = FWBuffer.length / MAX_CONTROL_XFER_SIZE;  // this is number of full chunks to send
        for (int i = 0; i < numChunks; i++) {
            System.arraycopy(FWBuffer, i * MAX_CONTROL_XFER_SIZE, dataBuffer.Buffer(), 0, MAX_CONTROL_XFER_SIZE);
            result = gUsbIo.classOrVendorOutRequest(dataBuffer, vendorRequest);
            if (result != USBIO_ERR_SUCCESS) {
                close();
                throw new HardwareInterfaceException("Error on downloading segment number " + i + " of 8051 firmware: " + UsbIo.errorText(result));
            }
            vendorRequest.Value += MAX_CONTROL_XFER_SIZE;			//change address of firmware location
        }

        // now send final (short) chunk
        int numBytesLeft = FWBuffer.length % MAX_CONTROL_XFER_SIZE;  // remainder
        if (numBytesLeft > 0) {
            dataBuffer = new USBIO_DATA_BUFFER(numBytesLeft);
            dataBuffer.setNumberOfBytesToTransfer(dataBuffer.Buffer().length);
            System.arraycopy(FWBuffer, numChunks * MAX_CONTROL_XFER_SIZE, dataBuffer.Buffer(), 0, numBytesLeft);

            // send remaining part of firmware
            result = gUsbIo.classOrVendorOutRequest(dataBuffer, vendorRequest);
            if (result != USBIO_ERR_SUCCESS) {
                close();
                throw new HardwareInterfaceException("Error on downloading final segment of 8051 firmware: " + UsbIo.errorText(result));
            }
        }

    }

    /**
     * sends vendor request to CPUCS register to set 8051 in CPU reset (or not)
     *@param value true to reset, false to run
     *@see #download8051RAM
     */
    protected void set8051Reset(boolean value) throws HardwareInterfaceException {

//        log.info("setting 8051 reset="+value);

        int result;
        USBIO_DATA_BUFFER dataBuffer;
        USBIO_CLASS_OR_VENDOR_REQUEST vendorRequest;
        // make vendor request structure and populate it
        vendorRequest = new USBIO_CLASS_OR_VENDOR_REQUEST();

        vendorRequest.Flags = UsbIoInterface.USBIO_SHORT_TRANSFER_OK;
        vendorRequest.Type = UsbIoInterface.RequestTypeVendor;  // this is a vendor, not generic USB, request
        vendorRequest.Recipient = UsbIoInterface.RecipientDevice; // device (not endpoint, interface, etc) receives it
        vendorRequest.RequestTypeReservedBits = 0;    // set these bits to zero for Cypress-specific 'vendor request' rather that user defined
        vendorRequest.Request = VENDOR_REQUEST_FIRMWARE; // this is download/upload firmware request. really it is just a 'fill RAM request'
        vendorRequest.Index = 0;

        //	1) reset the Cypress (write 0x01 into CPUCS register)

        vendorRequest.Value = CPUCS; // we're writing to this RAM address, which is actually the only register that the host can write to
        dataBuffer = new USBIO_DATA_BUFFER(1); // make a new buffer to define the length of the request data correctly
        dataBuffer.Buffer()[0] = (byte) (value ? 1 : 0);            // 1 to reset, 0 to run
        dataBuffer.setNumberOfBytesToTransfer(dataBuffer.Buffer().length);
        result = gUsbIo.classOrVendorOutRequest(dataBuffer, vendorRequest);
        if (result != USBIO_ERR_SUCCESS) {
            close();
            throw new HardwareInterfaceException("Unable to reset 8051 for firmware download: " + UsbIo.errorText(result));
        }

    }

    /** @return timestamp tick in us
     * NOTE: DOES NOT RETURN THE TICK OF THE USBAERmini2 board*/
    final public int getTimestampTickUs() {
        return TICK_US;
    }

    /** returns last events from {@link #acquireAvailableEventsFromDriver}
     *@return the event packet
     */
    public AEPacketRaw getEvents() {
        return this.lastEventsAcquired;
    }

    /** sends a vender request without data, value and index are set to zero.
     *@param request the vendor request byte, identifies the request on the device
     */
    synchronized public void sendVendorRequest(byte request) throws HardwareInterfaceException {
        sendVendorRequest(request, (short) 0, (short) 0, null);
    }

    /** sends a vender request without any data.
     *@param request the vendor request byte, identifies the request on the device
     *@param value the value of the request (bValue USB field)
     *@param index the "index" of the request (bIndex USB field)
     */
    synchronized public void sendVendorRequest(byte request, short value, short index) throws HardwareInterfaceException {
        sendVendorRequest(request, value, index, null);
    }

    /** sends a vender request with data.
     *@param request the vendor request byte, identifies the request on the device
     *@param value the value of the request (bValue USB field)
     *@param index the "index" of the request (bIndex USB field)
     *@param dataBuffer the data which is to be transmitted to the device
     */
    synchronized public void sendVendorRequest(byte request, short value, short index, USBIO_DATA_BUFFER dataBuffer) throws HardwareInterfaceException {
        if (!isOpen()) {
            open();
        }

        // make vendor request structure and populate it
        USBIO_CLASS_OR_VENDOR_REQUEST VendorRequest = new USBIO_CLASS_OR_VENDOR_REQUEST();
        int status;

        VendorRequest.Flags = UsbIoInterface.USBIO_SHORT_TRANSFER_OK;
        VendorRequest.Type = UsbIoInterface.RequestTypeVendor;
        VendorRequest.Recipient = UsbIoInterface.RecipientDevice;
        VendorRequest.RequestTypeReservedBits = 0;
        VendorRequest.Request = request;
        VendorRequest.Index = index;
        VendorRequest.Value = value;

        //System.out.println("request= " + request + " value: " + value);

        if (dataBuffer == null) {
            dataBuffer = new USBIO_DATA_BUFFER(1);
            dataBuffer.setNumberOfBytesToTransfer(dataBuffer.Buffer().length);
        } else {
            dataBuffer.setNumberOfBytesToTransfer(dataBuffer.Buffer().length);
        }

        status = gUsbIo.classOrVendorOutRequest(dataBuffer, VendorRequest);

        if (status != USBIO_ERR_SUCCESS) {
            throw new HardwareInterfaceException("Unable to send vendor request " + request + ": " + UsbIo.errorText(status));
        }

        HardwareInterfaceException.clearException();
    }
    /* encodings of xsvf instructions */
    private static final byte XCOMPLETE = (byte) 0;
    private static final byte XTDOMASK = (byte) 1;
    private static final byte XSIR = (byte) 2;
    private static final byte XSDR = (byte) 3;
    private static final byte XRUNTEST = (byte) 4;
    /* Reserved              5 */
    /* Reserved              6 */
    private static final byte XREPEAT = (byte) 7;
    private static final byte XSDRSIZE = (byte) 8;
    private static final byte XSDRTDO = (byte) 9;
    private static final byte XSDRB = (byte) 12;
    private static final byte XSDRC = (byte) 13;
    private static final byte XSDRE = (byte) 14;
    private static final byte XSDRTDOB = (byte) 15;
    private static final byte XSDRTDOC = (byte) 16;
    private static final byte XSDRTDOE = (byte) 17;
    private static final byte XSTATE = (byte) 18;        /* 4.00 */

    private static final byte XENDIR = (byte) 19;         /* 4.04 */

    private static final byte XENDDR = (byte) 20;         /* 4.04 */

    private static final byte XSIR2 = (byte) 21;         /* 4.10 */

    private static final byte XCOMMENT = (byte) 22;         /* 4.14 */

    private static final byte XWAIT = (byte) 23;         /* 5.00 */


    public void writeCPLDfirmware(String svfFile) throws HardwareInterfaceException {
        byte[] bytearray;
        byte command;
        int commandlength = 1,  index = 0, length = 0, status;
        USBIO_DATA_BUFFER dataBuffer = null;
        USBIO_CLASS_OR_VENDOR_REQUEST VendorRequest;

        try {
            bytearray = this.loadBinaryFirmwareFile(svfFile);
        } catch (Exception e) {
            e.printStackTrace();
            return;
        }

        command = bytearray[index];

        while (command != 0x00) {
            commandlength = 1;
            switch (command) {
                case XTDOMASK:
                    commandlength = length + 1;
                    break;
                case XREPEAT:
                    commandlength = 2;
                    break;
                case XRUNTEST:
                    commandlength = 5;
                    break;
                case XSIR:
                    commandlength = (bytearray[index + 1] + 7) / 8 + 2;
                    break;
                case XSIR2:
                    commandlength = ((bytearray[index + 1] << 8 | bytearray[index + 2]) + 7) / 8 + 3;
                    break;
                case XSDR:
                    commandlength = length + 1;
                    break;
                case XSDRSIZE:
                    commandlength = 5;
                    length = ((bytearray[index + 1] << 24) | (bytearray[index + 2] << 16) | (bytearray[index + 3] << 8) | (bytearray[index + 4]) + 7) / 8;
                    break;
                case XSDRTDO:
                    commandlength = 2 * length + 1;
                    break;
                case XSDRB:

                    commandlength = length + 1;
                    break;
                case XSDRC:

                    commandlength = length + 1;
                    break;
                case XSDRE:

                    commandlength = length + 1;
                    break;
                case XSDRTDOB:

                    commandlength = 2 * length + 1;
                    break;
                case XSDRTDOC:

                    commandlength = 2 * length + 1;
                    break;
                case XSDRTDOE:

                    commandlength = 2 * length + 1;
                    break;
                case XSTATE:

                    commandlength = 2;
                    break;
                case XENDIR:

                    commandlength = 2;
                    break;
                case XENDDR:

                    commandlength = 2;
                    break;
                case XCOMMENT:

                    commandlength = 2;
                    while (bytearray[index + commandlength - 1] != 0x00) {
                        commandlength += 1;
                    }
                    log.info("found comment");
                    break;
                case XWAIT:

                    commandlength = 7;
                    break;
                default:
                    this.sendVendorRequest(this.VR_DOWNLOAD_FIRMWARE, (short) 0, (short) 0);
                    throw new HardwareInterfaceException("Unable to program CPLD, unknown xsfv command: " + command);
            }
            //System.out.println("command: " + command + " index: " + index + " commandlength " + commandlength);
            //        System.out.println("max command length " + maxlen);

            dataBuffer = new USBIO_DATA_BUFFER(commandlength);
            System.arraycopy(bytearray, index, dataBuffer.Buffer(), 0, commandlength);

            this.sendVendorRequest(this.VR_DOWNLOAD_FIRMWARE, command, (short) 0, dataBuffer);

            VendorRequest = new USBIO_CLASS_OR_VENDOR_REQUEST();
            dataBuffer = new USBIO_DATA_BUFFER(2);

            VendorRequest.Flags = UsbIoInterface.USBIO_SHORT_TRANSFER_OK;
            VendorRequest.Type = UsbIoInterface.RequestTypeVendor;
            VendorRequest.Recipient = UsbIoInterface.RecipientDevice;
            VendorRequest.RequestTypeReservedBits = 0;
            VendorRequest.Request = this.VR_DOWNLOAD_FIRMWARE;
            VendorRequest.Index = 0;
            VendorRequest.Value = 0;

            dataBuffer.setNumberOfBytesToTransfer(2);
            status = gUsbIo.classOrVendorInRequest(dataBuffer, VendorRequest);

            if (status != USBIO_ERR_SUCCESS) {
                throw new HardwareInterfaceException("Unable to receive xsvf error code: " + UsbIo.errorText(status));
            }

            HardwareInterfaceException.clearException();

            // log.info("bytes transferred" + dataBuffer.getBytesTransferred());
            if (dataBuffer.getBytesTransferred() == 0) {
                this.sendVendorRequest(this.VR_DOWNLOAD_FIRMWARE, (short) 0, (short) 0);
                throw new HardwareInterfaceException("Unable to program CPLD, could not get xsvf Error code");
            }
            if (dataBuffer.Buffer()[1] == 10) {
                this.sendVendorRequest(this.VR_DOWNLOAD_FIRMWARE, (short) 0, (short) 0);
                throw new HardwareInterfaceException("Unable to program CPLD, command too long, please report to raphael@ini.ch, command: " + command + " index: " + index + " commandlength " + commandlength);
            } else if (dataBuffer.Buffer()[1] > 0) {
                this.sendVendorRequest(this.VR_DOWNLOAD_FIRMWARE, (short) 0, (short) 0);
                throw new HardwareInterfaceException("Unable to program CPLD, error code: " + dataBuffer.Buffer()[1] + ", at command: " + command + " index: " + index + " commandlength " + commandlength);
            // System.out.println("Unable to program CPLD, unable to program CPLD, error code: " + dataBuffer.Buffer()[1] + ", at command: " + command + " index: " + index + " commandlength " + commandlength);
            }

            index += commandlength;
            command = bytearray[index];
        } //complete

        log.info("sending XCOMPLETE");
        this.sendVendorRequest(this.VR_DOWNLOAD_FIRMWARE, XCOMPLETE, (short) 0);

    }

    public AEReader getAeReader() {
        return aeReader;
    }

    public void setAeReader(AEReader aeReader) {
        this.aeReader = aeReader;
    }

    public int getFifoSize() {
        if (aeReader == null) {
            return 0;
        } else {
            return aeReader.getFifoSize();
        }
    }

    public void setFifoSize(int fifoSize) {
        if (aeReader == null) {
            return;
        }
        aeReader.shutdownThread();
        aeReader.setFifoSize(fifoSize);
        aeReader.startThread(3);
    }

    public int getNumBuffers() {
        if (aeReader == null) {
            return 0;
        } else {
            return aeReader.getNumBuffers();
        }
    }

    public void setNumBuffers(int numBuffers) {
        if (aeReader == null) {
            return;
        }
        aeReader.shutdownThread();
        aeReader.setNumBuffers(numBuffers);
        aeReader.startThread(3);
    }

    public void setChip(AEChip chip) {
        this.chip = chip;
    }

    public AEChip getChip() {
        return chip;
    }

    /** Resets the USB device using USBIO resetDevice */
    public void resetUSB() {
        if (gUsbIo == null) {
            return;
        }
        gUsbIo.resetDevice();
    }

    /** Cycles the port using USBIO cyclePort */
    public void cyclePort() {
        if (gUsbIo == null) {
            return;
        }
        gUsbIo.cyclePort();
    }

    private void checkBlankDevice() {
        if (deviceDescriptor.idVendor == VID_BLANK && deviceDescriptor.idProduct == PID_BLANK) {
            log.warning("blank CypressFX2 detected");
        }
    }
}

