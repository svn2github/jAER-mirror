/*
 * USBAEMon.java
 *
 * Created on February 17, 2005, 7:54 AM
 */
package ch.unizh.ini.caviar.hardwareinterface.usb;

import ch.unizh.ini.caviar.aemonitor.*;
import ch.unizh.ini.caviar.aemonitor.AEMonitorInterface;
import ch.unizh.ini.caviar.chip.*;
//import ch.unizh.ini.caviar.chip.EventExtractor2D;
import ch.unizh.ini.caviar.eventprocessing.FilterChain;
import ch.unizh.ini.caviar.event.EventPacket;
import ch.unizh.ini.caviar.hardwareinterface.*;
import ch.unizh.ini.caviar.util.*;
import de.thesycon.usbio.PnPNotifyInterface;
import java.beans.*;
import java.io.*;
import de.thesycon.usbio.*;
import de.thesycon.usbio.structs.*;
import java.util.*;
import java.util.logging.Logger;
import java.util.prefs.*;
import javax.swing.*;
import javax.swing.JProgressBar;


/**
 *  Acquires data from INI/USE USB2 board that uses Cypress FX2LP device and host driver firmware and software based on Thesycon Java USBIO.
 *Controls onchip biasgenerator using Cypress FX2 SPI interface.
 *<p>
 *<p>
 *In this class, you can also set the size of the host buffer with {@link #setAEBufferSize}, giving you more time between calls to process the events.
 *<p>
 *On the device, a timer sends all available events approximately every 10ms -- you don't need to wait for a fixed size buffer to be captured to be available to the host.
 *But if events come quickly enough, new events can be available much faster than this.
 *<p>
 *You can also request at any time an early transfer of events with {@link #requestEarlyTransfer}. This will send a vendor request to the device to immediately transfer
 * available events, but they won't be available to the host for a little while, depending on USBIOInterface and driver latency.
 *<p>
 *See the main() method for an example of use.
 *
 *
 * @author  tobi
 */
public class CypressFX2 implements UsbIoErrorCodes, PnPNotifyInterface, AEMonitorInterface, ReaderBufferControl, RealTimeFilter {
    
    
    protected Preferences prefs=Preferences.userNodeForPackage(this.getClass());
    protected Logger log=Logger.getLogger("CypressFX2");
    
    protected AEChip chip;
    
    /** filename of FX2 binary executable, generated by uVision project and associated script that runs hex2bix */
    public final static String FIRMWARE_FILENAME_DAREK_BOARD="/ch/unizh/ini/caviar/hardwareinterface/usb/USBAER_FX2.bix"; //"USBAEMonFirware.bin";
    /** filename of FX2 binary executable, generated by uVision project and associated script that runs hex2bix */
    public final static String FIRMWARE_FILENAME_TMPDIFF128="/ch/unizh/ini/caviar/hardwareinterface/usb/USBAER_FX2LP_Retina.bix"; //"USBAEMonFirware.bin";
    /** filename of FX2 binary executable, generated by uVision project and associated script that runs hex2bix */
    public final static String FIRMWARE_FILENAME_TMPDIFF128_HEX="/ch/unizh/ini/caviar/hardwareinterface/usb/USBAER_FX2LP_Retina.hex"; //"USBAEMonFirware.bin";
    /** filename of FX2 binary executable, generated by uVision project and associated script that runs hex2bix */
    public final static String FIRMWARE_FILENAME_MONITOR_SEQUENCER="/ch/unizh/ini/caviar/hardwareinterface/usb/USBAERmini2.bix";
    /** filename of FX2 binary executable, generated by uVision project and associated script that runs hex2bix */
    public final static String FIRMWARE_FILENAME_MONITOR_SEQUENCER_HEX="/ch/unizh/ini/caviar/hardwareinterface/usb/USBAERmini2.hex";
    /** filename of FX2 binary executable, generated by uVision project and associated script that runs hex2bix */
    public final static String FIRMWARE_FILENAME_MONITOR_SEQUENCER_IIC="/ch/unizh/ini/caviar/hardwareinterface/usb/USBAERmini2.iic";
    public final static String FIRMWARE_FILENAME_MAPPER_IIC="/ch/unizh/ini/caviar/hardwareinterface/usb/USB2AERmapper.iic";
    public final static String FIRMWARE_FILENAME_STEREO_IIC="/ch/unizh/ini/caviar/hardwareinterface/usb/TMPdiffStereo.iic";
    
    
    /** driver guid (Globally unique ID, for this USB driver instance */
    //public final static String GUID = "{325ddf96-938c-11d3-9e34-0080c82727f4}";  // working from MouseSimple example.
    public final static String GUID  = "{7794C79A-40A7-4a6c-8A29-DA141C20D78C}"; // see guid.txt at root of CypressFX2USB2, generated by tobi for CypressFX2RetinaBiasgen
    //public final static String GUID    = "{96E73B6E-7A5A-11D4-9F24-0080C82727F4}";  // from default usbiowiz.inf file
    
    static public final short VID=(short)0x0547;
    static public final short PID_TMPDIFF128_RETINA=(short)0x8700;
    static public final short PID_DAREK_FX2_BOARD=(short)0x8701;
    static public final short PID_USBAERmini2=(short)0x8801;
    static public final short PID_USBAERmini2_without_firmware=(short)0x8800;
    static public final short PID_USB2AERmapper=(short)0x8900;
    static public final short DID_STEREOBOARD=(short)0x2007;
    
    /**
     * event supplied to listeners when new events are collected. this is final because it is just a marker for the listeners that new events are available
     */
    public final PropertyChangeEvent newEventPropertyChange=new PropertyChangeEvent(this, "NewEvents", null,null);
    PropertyChangeSupport support=new PropertyChangeSupport(this);
    
    
    // consts
    final static byte AE_MONITOR_ENDPOINT_ADDRESS = (byte)0x86;  // this is endpoint of AE fifo on Cypress FX2, 0x86 means IN endpoint EP6.
    final static byte STATUS_ENDPOINT_ADDRESS = (byte)0x81;  // this is endpoint 1 IN for device to report status changes asynchronously
    final short CPUCS = (short)0xE600;            // address of the CPUCS register, using for resetting 8051 and downloading firmware
    
    // vendor requests.
    final static byte VENDOR_REQUEST_START_TRANSFER=(byte)0xb3; // this is request to start sending events from FIFO endpoint
    final static byte VENDOR_REQUEST_STOP_TRANSFER=(byte)0xb4; // this is request to stop sending events from FIFO endpoint
    final static byte VENDOR_REQUEST_EARLY_TRANFER=(byte)0xb7; // this is request to transfer whatever you have now
    static final byte VENDOR_REQUEST_SEND_BIAS_BYTES=(byte)0xb8; // vendor command to send bias bytes out on SPI interface
    final byte VENDOR_REQUEST_POWERDOWN=(byte)0xb9; // vendor command to send bias bytes out on SPI interface
    final byte VENDOR_REQUEST_FLASH_BIASES=(byte)0xba;  // vendor command to flash the bias values to EEPROM
    final byte VENDOR_REQUEST_RESET_TIMESTAMPS=(byte)0xbb; // vendor command to reset timestamps
    final byte VENDOR_REQUEST_SET_ARRAY_RESET=(byte)0xbc; // vendor command to set array reset of retina
    final byte VENDOR_REQUEST_DO_ARRAY_RESET=(byte)0xbd; // vendor command to do an array reset (toggle arrayReset for a fixed time)
    //final byte VENDOR_REQUEST_WRITE_EEPROM=(byte)0xbe; // vendor command to write EEPROM
    final byte VENDOR_REQUEST_SET_LED=(byte)0xbf; // vendor command to set the board's LED
    //final byte VENDOR_REQUEST_READ_EEPROM=(byte)0xca; // vendor command to write EEPROM
    // #define VR_EEPROM		0xa2 // loads (uploads) EEPROM
    final byte VR_EEPROM =(byte)0xa2;
    // #define	VR_RAM			0xa3 // loads (uploads) external ram
    final byte VR_RAM =(byte)0xa3;
    
    // this is special hw vendor request for reading and writing RAM, used for firmware download
    static final byte VENDOR_REQUEST_FIRMWARE = (byte)0xA0; // download/upload firmware -- built in to FX2
    
    
    final static short CONFIG_INDEX                       = 0;
    final static short CONFIG_NB_OF_INTERFACES            = 1;
    final static short CONFIG_INTERFACE                   = 0;
    final static short CONFIG_ALT_SETTING                 = 0;
    final static int CONFIG_TRAN_SIZE                     = 512;
    
    
    // following are to support realtime filtering
    // the AEPacketRaw is used only within this class. Each packet is extracted using the chip extractor object from the first filter in the
    // realTimeFilterChain to a reused EventPacket.
    
    AEPacketRaw realTimeRawPacket=null;
    EventPacket realTimePacket=null;
    
    /** start of events that have been captured but not yet processed by the realTimeFilters */
    private int realTimeEventCounterStart=0;
    
    /** timeout in ms to reopen driver (reloading firmware) if no events are received for this time. This timeout will restart AE transmission if
     *another process (e.g. Biasgen) reloads the firmware. This timer is checked on every attempt to acquire events.
     */
    public static long NO_AE_REOPEN_TIMEOUT=3000;
    final short TICK_US=1; // time in us of each timestamp count here on host, could be different on board
    short TICK_US_BOARD=10; // time in us of timestamp tick on USB board. raphael: should not be final, i need to overwrite it and set it to 1
    
    /** default size of AE buffer for user processes. This is the buffer that is written by the hardware capture thread that holds events
     * that have not yet been transferred via {@link #acquireAvailableEventsFromDriver} to another thread
     * @see #acquireAvailableEventsFromDriver
     * @see AEReader
     * @see #setAEBufferSize
     */
    public static final int AE_BUFFER_SIZE=0x1ffff;
    
    /** the latest status returned from a USBIO call */
    protected int status;
    
    /** the event reader - a buffer pool thread from USBIO subclassing */
    protected AEReader aeReader=null;
    
    /** the thread that reads device status messages on EP1 */
    protected AsyncStatusThread asyncStatusThread=null;
    
    
    /** a USBIO buffer used for calls */
    protected UsbIoBuf BufDesc=null;
    
    /** The pool of raw AE packets, used for data transfer */
    protected AEPacketRawPool aePacketRawPool=new AEPacketRawPool();
    
    /**
     * Object that holds pool of AEPacketRaw that handles data interchange between capture and other (rendering) threads.
     * While the capture thread (AEReader.processData) captures events into one buffer (an AEPacketRaw) the other thread (AEViewer.run()) can
     * render the events. The only time the monitor on the pool needs to be acquired is when swapping or initializing the buffers, to prevent
     * either referencing unrelated data or having memory change out from under you.
     */
    private class AEPacketRawPool{
        AEPacketRaw[] buffers;
        AEPacketRaw lastBufferReference;
        volatile int readBuffer=0, writeBuffer=1; // this buffer is the one currently being read from
        AEPacketRawPool(){
            allocateMemory();
            reset();
        }
        
        /** swap the buffers so that the buffer that was getting written is now the one that is read from, and the one that was read from is
         * now the one written to. Thread safe.
         */
        synchronized final void swap(){
            lastBufferReference=buffers[readBuffer];
            if(readBuffer==0){
                readBuffer=1;
                writeBuffer=0;
            }else{
                readBuffer=0;
                writeBuffer=1;
            }
            writeBuffer().clear();
        }
        
        /** @return buffer to read from */
        synchronized final AEPacketRaw readBuffer(){
            return buffers[readBuffer];
        }
        
        /** @return buffer to write to */
        synchronized final AEPacketRaw writeBuffer(){
            return buffers[writeBuffer];
        }
        
        /** Set the current buffer to be the first one and clear the write buffer */
        synchronized final void reset(){
            readBuffer=0; writeBuffer=1;
            buffers[writeBuffer].clear(); // new events go into this buffer which should be empty
            buffers[readBuffer].clear();  // clear read buffer in case this buffer was reset by resetTimestamps
//            log.info("buffers reset");
        }
        
        // allocates AEPacketRaw each with capacity AE_BUFFER_SIZE
        void allocateMemory(){
            buffers=new AEPacketRaw[2];
            for(int i=0;i<buffers.length;i++){
                buffers[i]=new AEPacketRaw();
                buffers[i].ensureCapacity(AE_BUFFER_SIZE); // preallocate this memory for capture thread and to try to make it contiguous
            }
        }
    }
    
    int eventCounter=0;  // counts events acquired but not yet passed to user
    
    
    /** the last events from {@link #acquireAvailableEventsFromDriver}, This packet is reused. */
    protected AEPacketRaw lastEventsAcquired=new AEPacketRaw();
    
    PnPNotify pnp=null;
    USBIO_CLASS_OR_VENDOR_REQUEST vendorRequest;  // used for vendor requests to device (e.g. firmware download, start sending events, etc)
    
    protected boolean inEndpointEnabled=false;  // raphael: changed from private to protected, because i need to access this member
    
    /** device open status */
    protected boolean isOpened=false;
    
    private boolean aeReaderRunning=false;
    
    /** the device number, out of all potential compatible devices that could be opened */
    protected int interfaceNumber=0;
    
    
    /** Creates a new instance of USBAEMonitor. Note that it is possible to construct several instances
     * and use each of them to open and read from the same device.
     *@param devNumber the desired device number, in range returned by CypressFX2Factory.getNumInterfacesAvailable
     *@see CypressFX2TmpdiffRetinaFactory
     */
    protected CypressFX2(int devNumber) {
        this.interfaceNumber=devNumber;
//        pnp=new PnPNotify(this);
//        pnp.enablePnPNotification(GUID);
    }
    
    /** returns the device interface number. This is the index of this device as returned by the interface factory.
     * @return interface number, 0 based
     */
    int getInterfaceNumber() {
        return interfaceNumber;
    }
    
    /** sets the device number to open, according to the order in the hardware interface factory.
     * @param interfaceNumber 0 based interface number
     */
    void setInterfaceNumber(int interfaceNumber) {
        this.interfaceNumber = interfaceNumber;
    }
    
    /** acquire a device for exclusive use, other processes can't open the device anymore
     * used for example for continuous sequencing in matlab */
    public void acquireDevice() throws HardwareInterfaceException {
        status=gUsbIo.acquireDevice();
        if (status != 0) {
            throw new HardwareInterfaceException("Unable to acquire device for exclusive use: " + UsbIo.errorText(status));
        }
    }
    
    /** release the device from exclusive use */
    public void releaseDevice() throws HardwareInterfaceException {
        status=gUsbIo.releaseDevice();
        if (status != 0) {
            throw new HardwareInterfaceException("Unable to release device from exclusive use: " + UsbIo.errorText(status));
        }
    }
    
    public PropertyChangeSupport getSupport() {
        return this.support;
    }
    
    public String toString() {
        return (getClass().getSimpleName() + ": Interface " + getInterfaceNumber());
    }
    
    /** the size in bytes of the EEPROM atttached to the CypressFX2LP */
    public int EEPROM_SIZE=8192;
    
    /** size of control transfer data packets. Actually vendor request allows for larger data buffer, but windows limits largest xfer to 4096. Here we limit largest
     *to size of buffer for control xfers. */
    public final int MAX_CONTROL_XFER_SIZE=64; // max control xfer size
    
    /** this is a BLOCKING write call to write the Cypress EEPROM. Max number of bytes is defined by {@link #EEPROM_SIZE}.
     *@param addr the starting address
     *@param bytes the bytes to write
     */
    synchronized protected void writeEEPROM(int addr, byte[] bytes) throws HardwareInterfaceException{
        
//        log.info("writing EEPROM to addr="+addr+" with "+bytes.length+" bytes");
        
        if(bytes.length>EEPROM_SIZE) throw new RuntimeException(bytes.length+" is too many bytes for EEPROM to hold ("+EEPROM_SIZE+")");
        if(addr<0 || addr+bytes.length>EEPROM_SIZE) throw new RuntimeException(bytes.length+" is too many bytes for EEPROM to hold ("+EEPROM_SIZE+") starting at address "+addr);
        int result; // result of USBIO operations
        USBIO_DATA_BUFFER dataBuffer=null;
        USBIO_CLASS_OR_VENDOR_REQUEST vendorRequest=null;
        
        int numChunks, index;
        
        // make vendor request structure and populate it
        vendorRequest=new USBIO_CLASS_OR_VENDOR_REQUEST();
        
        
        vendorRequest.Request=VR_EEPROM; // this is EEPROM command, direction of vendor request defines download here
        
        vendorRequest.Flags=UsbIoInterface.USBIO_SHORT_TRANSFER_OK;
        vendorRequest.Type=UsbIoInterface.RequestTypeVendor;  // this is a vendor, not generic USB, request
        vendorRequest.Recipient=UsbIoInterface.RecipientDevice; // device (not endpoint, interface, etc) receives it
        vendorRequest.RequestTypeReservedBits=0;    // set these bits to zero for Cypress-specific 'vendor request' rather that user defined
        vendorRequest.Index=0;
        
        //send all but last chunk
        vendorRequest.Value = (short)addr;			//address to write to (starting)
        dataBuffer=new USBIO_DATA_BUFFER(MAX_CONTROL_XFER_SIZE);
        dataBuffer.setNumberOfBytesToTransfer(dataBuffer.Buffer().length);
        index=0;
        numChunks=bytes.length/MAX_CONTROL_XFER_SIZE;  // this is number of full chunks to send
        for(int i=0;i<numChunks;i++){
            System.arraycopy(bytes, i*MAX_CONTROL_XFER_SIZE, dataBuffer.Buffer(), 0, MAX_CONTROL_XFER_SIZE);
            result=gUsbIo.classOrVendorOutRequest(dataBuffer,vendorRequest);
            if(result!=USBIO_ERR_SUCCESS){
                close();
                throw new HardwareInterfaceException("Error on downloading segment number "+i+" of EEPROM write: "+UsbIo.errorText(result));
            }
            vendorRequest.Value += MAX_CONTROL_XFER_SIZE;			//change address of EEPROM write location
        }
        
        // now send final (short) chunk
        int numBytesLeft=bytes.length%MAX_CONTROL_XFER_SIZE;  // remainder
        if(numBytesLeft>0){
            dataBuffer=new USBIO_DATA_BUFFER(numBytesLeft);
            dataBuffer.setNumberOfBytesToTransfer(dataBuffer.Buffer().length);
            System.arraycopy(bytes, numChunks*MAX_CONTROL_XFER_SIZE, dataBuffer.Buffer(), 0, numBytesLeft);
            
            // send remaining part of firmware
            result=gUsbIo.classOrVendorOutRequest(dataBuffer,vendorRequest);
            if(result!=USBIO_ERR_SUCCESS){
                close();
                throw new HardwareInterfaceException("Error on downloading final segment of EEPROM write: "+UsbIo.errorText(result));
            }
        }
        
    } // writeEEPROM
    
    /** erases the VID/PID/DID and device identifier strings */
    synchronized protected void eraseEEPROM() throws HardwareInterfaceException{
        writeEEPROM(0,new byte[EEPROM_SIZE]);
    }
    
    /** read the EEPROM contents
     *@param addr the starting address
     *@param length the number of bytes to read
     */
    synchronized protected byte[] readEEPROM(int addr, int length) throws HardwareInterfaceException{
        int result;
        if(length>EEPROM_SIZE) throw new RuntimeException(length+" is more bytes than EEPROM can hold ("+EEPROM_SIZE+")");
        if(addr<0 || addr+length>EEPROM_SIZE) throw new RuntimeException(length+" is too many bytes to read from EEPROM which holds "+EEPROM_SIZE+" bytes, if you start at address "+addr);
        
        USBIO_DATA_BUFFER dataBuffer=null;
        USBIO_CLASS_OR_VENDOR_REQUEST vendorRequest=null;
        
        byte[] uploadBuffer=new byte[length];
        
        // make vendor request structure and populate it
        vendorRequest=new USBIO_CLASS_OR_VENDOR_REQUEST();
        vendorRequest.Request=VR_EEPROM; // this is download/upload EEPROM command, direction of vendor request defines upload to host
        
        vendorRequest.Flags=UsbIoInterface.USBIO_SHORT_TRANSFER_OK;
        vendorRequest.Type=UsbIoInterface.RequestTypeVendor;  // this is a vendor, not generic USB, request
        vendorRequest.Recipient=UsbIoInterface.RecipientDevice; // device (not endpoint, interface, etc) receives it
        vendorRequest.RequestTypeReservedBits=0;    // set these bits to zero for Cypress-specific 'vendor request' rather that user defined
        vendorRequest.Index=0;
        
        dataBuffer=new USBIO_DATA_BUFFER(length);
        int bytesTransferred=0;
        dataBuffer.setNumberOfBytesToTransfer(length);
        vendorRequest.Value=(short)addr; // this is EEPROM addr to read from for this chunk
        result=gUsbIo.classOrVendorInRequest(dataBuffer, vendorRequest);  // IN request defines direction, so will be understood as read EEPROM on device
        if(result!=USBIO_ERR_SUCCESS){
            close();
            throw new HardwareInterfaceException("Error during uploading EEPROM: "+UsbIo.errorText(result));
        }
        if(dataBuffer.getBytesTransferred()!=length){
            throw new HardwareInterfaceException("wrong number of bytes transferred, asked for "+length+", got "+dataBuffer.getBytesTransferred());
        }
        System.arraycopy(dataBuffer.Buffer(), 0, uploadBuffer, 0, length);
        
        return uploadBuffer;
    }
    
    
    /** writes the Cypress "C0" load to the EEPROM that makes the Cypress have a Vender, Product, and Device ID on powerup.
     *@param VID
     *@param PID
     *@param DID the 'device' ID, can be used to individualize devices
     */
    synchronized public void writeVIDPIDDID(short VID, short PID, short DID) throws HardwareInterfaceException{
        byte[] b=new byte[8];
        b[0]=(byte)0xC0;
        b[1]=(byte)(VID&0xFF);    // vid LSB
        b[2]=(byte)((VID&0xFF00)>>>8); // vid MSB
        b[3]=(byte)(PID&0xFF);
        b[4]=(byte)((PID&0xFF00)>>>8);
        b[5]=(byte)(DID&0xFF);
        b[6]=(byte)((DID&0xFF00)>>>8);
        b[7]=(byte)(0); // configuration byte, DISCON=0 (not disconnected after reset), 400kHz=0 (100kHz I2C  bus)
        
        writeEEPROM(0,b);
    }
    
    
    /** writes the Cypress "C2" load to the EEPROM that makes the Cypress have EEPROM firmware, including VID, PID, DID.
     *@param VID
     *@param PID
     *@param DID the 'device' ID, can be used to individualize devices
     *@param firmwareFilename a File containing the binary format firmware as output from hex2bix. This is a flat firmware format that starts at address 0.
     */
    public void writeC2Load(String firmwareFilename, short VID, short PID, short DID) throws HardwareInterfaceException{
        byte[] fw=null;
        
        try{
            fw=loadBinaryFirmwareFile(firmwareFilename);
        }catch(IOException e){
            throw new HardwareInterfaceException(e.getMessage());
        }
        
        byte[] b=new byte[12];
        b[0]=(byte)0xC2;
        b[1]=(byte)(VID&0xFF);    // vid LSB
        b[2]=(byte)((VID&0xFF00)>>>8); // vid MSB
        b[3]=(byte)(PID&0xFF);
        b[4]=(byte)((PID&0xFF00)>>>8);
        b[5]=(byte)(DID&0xFF);
        b[6]=(byte)((DID&0xFF00)>>>8);
        b[7]=(byte)(0); // configuration byte, DISCON=0 (not disconnected after reset), 400kHz=0 (100kHz I2C  bus)
        
        b[8]=(byte)((fw.length&0xFF00)>>>8);
        b[9]=(byte)((fw.length&0xFF));
        b[10]=0;
        b[11]=0;
        
        byte[] end=new byte[5];
        end[0]=(byte)0x80;
        end[1]=(byte)0x01;
        end[2]=(byte)0xe6;
        end[4]=0;
        
        byte[] w=new byte[b.length+fw.length+end.length];
        System.arraycopy(b,0,w,0,b.length);
        System.arraycopy(fw,0,w,b.length,fw.length);
        System.arraycopy(end,0,w,b.length+fw.length,end.length);
        
        
        writeEEPROM(0,w);
    }
    
    
    /** writes the Cypress "C2" load to the EEPROM that makes the Cypress have EEPROM firmware, including VID, PID, DID.
     *@param VID
     *@param PID
     *@param DID the 'device' ID, can be used to individualize devices
     *@param hexFileResourcePath a full path pointing to a resource containing the firmware as output from compiler in Intel hex format. This resource is a file that is somewhere in the classpath, i.e. it is a file
     *that is included in the project jar. For example: "/ch/unizh/ini/caviar/hardwareinterface/usb/USBAER_FX2LP_Retina.hex"
     *@see #FIRMWARE_FILENAME_TMPDIFF128_HEX
     *@see #FIRMWARE_FILENAME_MONITOR_SEQUENCER_HEX
     */
    synchronized public void writeHexFileToEEPROM(String hexFileResourcePath, short VID, short PID, short DID) throws HardwareInterfaceException{
        
        log.info("writing retina EEPROM firmware file "+hexFileResourcePath+" with VID="+VID+" PID="+PID+" DID="+DID);
        HexFileParser parser;
        try{
            parser=new HexFileParser(hexFileResourcePath);
        }catch(FileNotFoundException e){
            throw new HardwareInterfaceException(e.getMessage()+": cannot open resource "+hexFileResourcePath);
        }catch(IOException e2){
            throw new HardwareInterfaceException(e2.getMessage()+": cannot open resource "+hexFileResourcePath);
            
        }
        ArrayList<HexFileParser.Record> records=parser.getRecords();
        int index=0;
        byte[] b;
        
        log.info("writing "+records.size()+" records");
        
//        JFrame frame=new JFrame("EEPROM progress");
//        JProgressBar progressBar;
//        progressBar = new JProgressBar(0, records.size());
//        progressBar.setName("EEPROM programming");
//        progressBar.setValue(0);
//        progressBar.setStringPainted(true);
//        frame.getContentPane().add(progressBar);
//        frame.pack();
//        frame.setDefaultCloseOperation(JFrame.HIDE_ON_CLOSE);
//        frame.setVisible(true);
        
        
        b=new byte[12];
        b[0]=(byte)0xC2; // write C2 load format header
        b[1]=(byte)(VID&0xFF);    // vid LSB
        b[2]=(byte)((VID&0xFF00)>>>8); // vid MSB
        b[3]=(byte)(PID&0xFF);
        b[4]=(byte)((PID&0xFF00)>>>8);
        b[5]=(byte)(DID&0xFF);
        b[6]=(byte)((DID&0xFF00)>>>8);
        b[7]=(byte)(0); // configuration byte, DISCON=0 (not disconnected after reset), 400kHz=0 (100kHz I2C  bus)
        
        writeEEPROM(0,b); // write VID/PID etc header starting at addr 0
        
        index+=b.length;
        int recNum=0;
        // now for each hex file record, we must write this record, contiguous with the last one, and each record written to
        // flash must contain the starting address of how many bytes there are (up to 1023) and where the memory should go.
        // now write hex file records, one by one
        for(HexFileParser.Record r:records){
            b=new byte[4];
            b[0]=(byte)((r.data.length&0xFF00)>>>8);
            b[1]=(byte)((r.data.length&0xFF));
            b[2]=(byte)((r.address&0xFF00)>>>8);
            b[3]=(byte)((r.address&0xFF));
            writeEEPROM(index,b);
            index+=b.length;
            writeEEPROM(index, r.data);
            index+=r.data.length;
//            progressBar.setValue(recNum++);
        }
        
        // now write footer
        
        b=new byte[5];
        b[0]=(byte)0x80;
        b[1]=(byte)0x01;
        b[2]=(byte)0xe6;
        b[3]=(byte)0;
        b[4]=0;
        
        writeEEPROM(index,b);
        index+=b.length;
        log.info("done writing "+records.size()+" records to EEPROM");
//        frame.dispose();
        
    }
    
    /** downloads firmware to the FX2 RAM from a hex file.
     *@param hexFileResourcePath a full path pointing to a resource containing the firmware as output from compiler in Intel hex format. This resource is a file that is somewhere in the classpath, i.e. it is a file
     *that is included in the project jar. For example: "/ch/unizh/ini/caviar/hardwareinterface/usb/USBAER_FX2LP_Retina.hex"
     *@see #FIRMWARE_FILENAME_TMPDIFF128_HEX
     *@see #FIRMWARE_FILENAME_MONITOR_SEQUENCER_HEX
     */
    synchronized public void downloadFirmwareHex(String hexFileResourcePath) throws HardwareInterfaceException{
        
        log.info("downloading to RAM firmware file "+hexFileResourcePath);
        
        HexFileParser parser;
        try{
            parser=new HexFileParser(hexFileResourcePath);
        }catch(FileNotFoundException e){
            throw new HardwareInterfaceException(e.getMessage()+": cannot open resource "+hexFileResourcePath);
        }catch(IOException e2){
            throw new HardwareInterfaceException(e2.getMessage()+": cannot open resource "+hexFileResourcePath);
            
        }
        ArrayList<HexFileParser.Record> records=parser.getRecords();
        
        set8051Reset(true);
        
        // now for each hex file record, we must write this record, contiguous with the last one, and each record written to
        // flash must contain the starting address of how many bytes there are (up to 1023) and where the memory should go.
        // now write hex file records, one by one
        for(HexFileParser.Record r:records){
            download8051RAM(r.address, r.data);
        }
        
        set8051Reset(false);
    }
    
    
    /** adds a listener for new events captured from the device.
     * Actually gets called whenever someone looks for new events and there are some using
     * acquireAvailableEventsFromDriver, not when data is actually captured by AEReader.
     * Thus it will be limited to the users sampling rate, e.g. the game loop rendering rate.
     *
     * @param listener the listener. It is called with a PropertyChangeEvent when new events
     * are received by a call to {@link #acquireAvailableEventsFromDriver}.
     * These events may be accessed by calling {@link #getEvents}.
     */
    public void addAEListener(AEListener listener) {
        support.addPropertyChangeListener(listener);
    }
    
    public void removeAEListener(AEListener listener) {
        support.removePropertyChangeListener(listener);
    }
    
    /** starts reader buffer pool thread and enables in endpoints for AEs */
    public void startAEReader() throws HardwareInterfaceException {  // raphael: changed from private to protected, because i need to access this method
        int status=0; // don't use global status in this function
        // bind pipe
        
        // tobi commented out because old aeReader was preventing reading of events when device was removed and plugged back in. April 2007
//        if(aeReaderRunning){
//            log.warning("CypressFX2.startAEReader(): already running");
//            return;
//        }
        
        // start the thread that listens for device status information (e.g. timestamp reset)
        // asyncStatusThread=new AsyncStatusThread(this);
        //asyncStatusThread.start();
        
//        System.out.println("before starting aereader gUsbIo.isOpen()="+gUsbIo.isOpen());
        setAeReader(new AEReader(this));
        
        allocateAEBuffers();
        
        getAeReader().startThread(3); // arg is number of errors before giving up
        
//        Thread.currentThread().yield();
//        System.out.println("after starting aereader gUsbIo.isOpen()="+gUsbIo.isOpen());
        
        // enableINEndpoint(); already gets enabled in setEventAcquistionEnabled
        HardwareInterfaceException.clearException();
        
    } // startAEReader
    
    long lastTimeEventCaptured=System.currentTimeMillis(); // used for timer to restart IN transfers, in case another connection, e.g. biasgen, has disabled them
    
    /** Gets available events from driver.  {@link HardwareInterfaceException} is thrown if there is an error.
     *{@link #overrunOccurred} will be reset after this call.
     *<p>
     *This method also starts event acquisition if it is not running already.
     *
     *Thread safe: synchronized on access to the capture buffer.
     *
     * @return number of events acquired. If this is zero there is no point in getting the events, because there are none.
     *@throws HardwareInterfaceException
     *@see #setEventAcquisitionEnabled
     *
     * .
     */
    synchronized public AEPacketRaw acquireAvailableEventsFromDriver() throws HardwareInterfaceException {
        if(!isOpened){
            open();
        }
        
        // make sure event acquisition is running
        if(!inEndpointEnabled){
            setEventAcquisitionEnabled(true);
        }
        
//        HardwareInterfaceException.clearException();
        
        // make sure that event translation from driver is allowed to run if need be, to avoid holding up event sender
//        Thread.currentThread().yield();
        
//        short[] addresses;
//        int[] timestamps;
        int nEvents;
        
        // get the 'active' buffer for events (the one that has just been written by the hardware thread)
//        synchronized(aePacketRawPool){ // synchronize on aeReader so that we don't try to access the events at the same time
        aePacketRawPool.swap();
        lastEventsAcquired=aePacketRawPool.readBuffer();
//        log.info(this+" acquired "+lastEventsAcquired);
        lastEventsAcquired.overrunOccuredFlag=false;
//            addresses=events.getAddresses();
//            timestamps=events.getTimestamps();
        nEvents=lastEventsAcquired.getNumEvents();
        eventCounter=0;
        computeEstimatedEventRate(lastEventsAcquired);
        if(nEvents!=0)
            support.firePropertyChange(newEventPropertyChange); // call listeners
//        }
        return lastEventsAcquired;
        
//        events=new AEPacketRaw(nEvents);
//        // reuse same packet to avoid constant new'ing
//        events.ensureCapacity(nEvents);
//        if(nEvents==0){
////            log.warning("got zero events from "+this);
//            computeEstimatedEventRate(null);
//            events.clear();
//            return events;
//        }else{
//            System.arraycopy(addresses, 0, events.getAddresses(), 0, nEvents);
//            System.arraycopy(timestamps, 0, events.getTimestamps(), 0, nEvents);
//            events.setNumEvents(nEvents);
//            computeEstimatedEventRate(events);
//            support.firePropertyChange(newEventPropertyChange); // call listeners
//            return events;
//        }
    }
    
    
    /** the max capacity of this USB2 bus interface is 24MB/sec/4 bytes/event
     */
    public int getMaxCapacity() {
        return 6000000;
    }
    
    private int estimatedEventRate=0;
    
    /** @return event rate in events/sec as computed from last acquisition.
     *
     */
    public int getEstimatedEventRate() {
        return estimatedEventRate;
    }
    
    /** computes the estimated event rate for a packet of events */
    void computeEstimatedEventRate(AEPacketRaw events){
        if(events==null || events.getNumEvents()<2 ) estimatedEventRate=0;
        else{
            int[] ts=events.getTimestamps();
            int n=events.getNumEvents();
            int dt=ts[n-1]-ts[0];
            estimatedEventRate=(int)(1e6f*(float)n/(float)dt);
        }
    }
    
    /** Returns the number of events acquired by the last call to {@link
     * #acquireAvailableEventsFromDriver }
     * @return number of events acquired
     */
    public int getNumEventsAcquired(){
        return aePacketRawPool.readBuffer().getNumEvents();
    }
    
    
    /** reset the timestamps to zero. This has two effects. First it sends a vendor request down the control endpoint
     * to tell the device to reset its own internal timestamp counters. Second, it tells the AEReader object to reset its
     * timestamps, meaning to reset its unwrap counter.
     */
    synchronized public void resetTimestamps() {
        log.info(this+".resetTimestamps(): zeroing timestamps");
        int status=0; // don't use global status in this function
        dontwrap=true;  // this is a flag that is reset in translateEvents method
        // send vendor request for device to reset timestamps
        if(gUsbIo==null){
            throw new RuntimeException("device must be opened before sending this vendor request");
        }
        
        // make vendor request structure and populate it
        USBIO_CLASS_OR_VENDOR_REQUEST VendorRequest=new USBIO_CLASS_OR_VENDOR_REQUEST();
        
        VendorRequest.Flags=UsbIoInterface.USBIO_SHORT_TRANSFER_OK;
        VendorRequest.Type=UsbIoInterface.RequestTypeVendor;
        VendorRequest.Recipient=UsbIoInterface.RecipientDevice;
        VendorRequest.RequestTypeReservedBits=0;
        VendorRequest.Request=VENDOR_REQUEST_RESET_TIMESTAMPS;
        VendorRequest.Index=0;
        
        VendorRequest.Value=0;
        USBIO_DATA_BUFFER dataBuffer=new USBIO_DATA_BUFFER(1);
        dataBuffer.setNumberOfBytesToTransfer(1);
        //        dataBuffer.Buffer()[0]=1;
        status=gUsbIo.classOrVendorOutRequest(dataBuffer,VendorRequest);
        if(status!=USBIO_ERR_SUCCESS){
            log.warning("CypressFX2.resetTimestamps: couldn't send vendor request to reset timestamps");
        }
        if(getAeReader()!=null)
            getAeReader().resetTimestamps(); // reset wrap counter and flush buffers
        else
            log.warning("CypressFX2.resetTimestamps(): reader not yet started, can't reset timestamps");
//        log.info(this+" notifying waiting threads that timestamps have been reset");
//        notifyAll(); // notify waiting threads (e.g. StereoHardwareInterface) that timestamps have been reset
    }
    
    
    /** reset the entire pixel array */
    public void resetPixelArray() {
        // send vendor request for device to reset array
        int status=0; // don't use global status in this function
        if(gUsbIo==null){
            throw new RuntimeException("device must be opened before sending this vendor request");
        }
        
        // make vendor request structure and populate it
        USBIO_CLASS_OR_VENDOR_REQUEST VendorRequest=new USBIO_CLASS_OR_VENDOR_REQUEST();
        
        VendorRequest.Flags=UsbIoInterface.USBIO_SHORT_TRANSFER_OK;
        VendorRequest.Type=UsbIoInterface.RequestTypeVendor;
        VendorRequest.Recipient=UsbIoInterface.RecipientDevice;
        VendorRequest.RequestTypeReservedBits=0;
        VendorRequest.Request=VENDOR_REQUEST_DO_ARRAY_RESET;
        VendorRequest.Index=0;
        
        VendorRequest.Value=0;
        USBIO_DATA_BUFFER dataBuffer=new USBIO_DATA_BUFFER(1);
        dataBuffer.setNumberOfBytesToTransfer(1);
        //        dataBuffer.Buffer()[0]=1;
        status=gUsbIo.classOrVendorOutRequest(dataBuffer,VendorRequest);
        if(status!=USBIO_ERR_SUCCESS){
            log.warning("CypressFX2.resetPixelArray: couldn't send vendor request to reset array");
        }
    }
    
    protected boolean arrayResetEnabled=false;
    
    /** set the board LED state. Useful for debugging. Not available for CypressFX2MonitorSequencer
     * @param value true to turn it on, false to turn it off.
     */
    synchronized public void setLed(boolean value) {
        // send vendor request for device to reset array
        int status=0; // don't use global status in this function
        if(gUsbIo==null){
            throw new RuntimeException("device must be opened before sending this vendor request");
        }
        
        // make vendor request structure and populate it
        USBIO_CLASS_OR_VENDOR_REQUEST VendorRequest=new USBIO_CLASS_OR_VENDOR_REQUEST();
        
        VendorRequest.Flags=UsbIoInterface.USBIO_SHORT_TRANSFER_OK;
        VendorRequest.Type=UsbIoInterface.RequestTypeVendor;
        VendorRequest.Recipient=UsbIoInterface.RecipientDevice;
        VendorRequest.RequestTypeReservedBits=0;
        VendorRequest.Request=VENDOR_REQUEST_SET_LED;
        VendorRequest.Index=0;
        
        VendorRequest.Value=(short)(value?0:1);  // this is the request bit, if value true, send value 0, false send value 1
        // on the board, 1 actually turns off the LED because the anode is tied to Vdd and the  cathode to the GPIO output
        
        USBIO_DATA_BUFFER dataBuffer=new USBIO_DATA_BUFFER(0); // no data, value is in request value
        dataBuffer.setNumberOfBytesToTransfer(dataBuffer.Buffer().length);
        
        status=gUsbIo.classOrVendorOutRequest(dataBuffer,VendorRequest);
        if(status!=USBIO_ERR_SUCCESS){
            log.warning("CypressFX2.resetPixelArray: couldn't send vendor request to set LED");
        }
    }
    
    /** Is true if an overrun occured in the driver (><code> AE_BUFFER_SIZE</code> events) during the period before the last time {@link
     * #acquireAvailableEventsFromDriver } was called. This flag is cleared by {@link #acquireAvailableEventsFromDriver}, so you need to
     * check it before you acquire the events.
     *<p>
     *If there is an overrun, the events grabbed are the most ancient; events after the overrun are discarded. The timestamps continue on but will
     *probably be lagged behind what they should be.
     * @return true if there was an overrun.
     */
    public boolean overrunOccurred(){
//        synchronized(aePacketRawPool){
        return aePacketRawPool.readBuffer().overrunOccuredFlag;
//        }
    }
    
    /** Closes the device. Never throws an exception.
     */
    synchronized public void close(){
        if(!isOpened){
//            log.warning("CypressFX2.close(): not open");
            return;
        }
        
        try{
//            if (this.isEventAcquisitionEnabled()) {
            setEventAcquisitionEnabled(false);
            stopAEReader();
//            }
            if(asyncStatusThread!=null) asyncStatusThread.stopThread();
        }catch(HardwareInterfaceException e){
            e.printStackTrace();
        }
        
//        log.info("Cycling port on close()");
        gUsbIo.cyclePort();
        
        gUsbIo.close();
        UsbIo.destroyDeviceList(gDevList);
//        log.info("USBIOInterface.close(): device closed");
        inEndpointEnabled=false;
        isOpened=false;
    }
    
    
    // not really necessary to stop this thread, i believe, because close will unbind already according to usbio docs
    public void stopAEReader() {  // raphael: changed from private to protected, because i need to access this method
        if(getAeReader()!=null){
            //   System.out.println("CypressFX2.stopAEReader(): stopping aeReader thread");
            getAeReader().shutdownThread();
            // unbind pipe
            getAeReader().unbind();
            // close device
            getAeReader().close();
            
            setAeReader(null);
        }
        
        //  asyncStatusThread=null;
    }
    
    /** sends vendor request to trigger an immediate commit of whatever is in the endpoint fifo immediately.
     * next call to <@link #acquireAvailableEventsFromDriver} will get these events if you wait a bit.
     */
    synchronized public void requestEarlyTransfer() throws HardwareInterfaceException {
        // start getting events by sending vendor request 0xb3 to control endpoint 0
        // documented in firmware FX2_to_extFIFO.c
        
        // make vendor request structure and populate it
        USBIO_CLASS_OR_VENDOR_REQUEST VendorRequest=new USBIO_CLASS_OR_VENDOR_REQUEST();
        int status=0; // don't use global status in this function
        
        VendorRequest.Flags=UsbIoInterface.USBIO_SHORT_TRANSFER_OK;
        VendorRequest.Type=UsbIoInterface.RequestTypeVendor;
        VendorRequest.Recipient=UsbIoInterface.RecipientDevice;
        VendorRequest.RequestTypeReservedBits=0;
        VendorRequest.Request=(byte)VENDOR_REQUEST_EARLY_TRANFER;
        VendorRequest.Index=0;
        
        USBIO_DATA_BUFFER dataBuffer=new USBIO_DATA_BUFFER(1);
        VendorRequest.Value=0; // (byte)VENDOR_REQUEST_START_TRANSFER;
        dataBuffer=new USBIO_DATA_BUFFER(1);
        dataBuffer.setNumberOfBytesToTransfer(dataBuffer.Buffer().length);
        dataBuffer.Buffer()[0]=1;
        status=gUsbIo.classOrVendorOutRequest(dataBuffer,VendorRequest);
        if(status!=USBIO_ERR_SUCCESS){
            throw new HardwareInterfaceException("Unable to send vendor request to send events early: "+UsbIo.errorText(status));
        }
        HardwareInterfaceException.clearException();
        
    }
    
    /** @return true if inEndpoint was enabled.
     * However, some other connection (e.g. biasgen) could have disabled the in transfers.
     */
    public boolean isInEndpointEnabled() {
        return this.inEndpointEnabled;
    }
    
    /** sends a vendor request to enable or disable in transfers of AEs
     *@param inEndpointEnabled true to send vendor request to enable, false to send request to disable
     */
    public void setInEndpointEnabled(final boolean inEndpointEnabled) throws HardwareInterfaceException {
        if(inEndpointEnabled)
            enableINEndpoint();
        else
            disableINEndpoint();
    }
    
    synchronized void enableINEndpoint() throws HardwareInterfaceException {
        // start getting events by sending vendor request 0xb3 to control endpoint 0
        // documented in firmware FX2_to_extFIFO.c
//        System.out.println("USBAEMonitor.enableINEndpoint()");
        // make vendor request structure and populate it
        if(gUsbIo==null){
            log.warning("CypressFX2.enableINEndpoint(): null USBIO device");
            return;
        }
        int status=0; // don't use global status in this function
        USBIO_CLASS_OR_VENDOR_REQUEST VendorRequest=new USBIO_CLASS_OR_VENDOR_REQUEST();
        
        VendorRequest.Flags=UsbIoInterface.USBIO_SHORT_TRANSFER_OK;
        VendorRequest.Type=UsbIoInterface.RequestTypeVendor;
        VendorRequest.Recipient=UsbIoInterface.RecipientDevice;
        VendorRequest.RequestTypeReservedBits=0;
        VendorRequest.Request=(byte)VENDOR_REQUEST_START_TRANSFER;
        VendorRequest.Index=0;
        
        VendorRequest.Value=0;
        USBIO_DATA_BUFFER dataBuffer=new USBIO_DATA_BUFFER(0);
        dataBuffer.setNumberOfBytesToTransfer(0);
        status=gUsbIo.classOrVendorOutRequest(dataBuffer,VendorRequest);
        if(status!=USBIO_ERR_SUCCESS){
            close();
            throw new HardwareInterfaceException("Unable to send vendor request to send events: "+UsbIo.errorText(status));
        }else
            inEndpointEnabled=true;
        HardwareInterfaceException.clearException();
    }
    
    
    synchronized void disableINEndpoint(){
        // stop endpoint sending events by sending vendor request 0xb4 to control endpoint 0
        // these requests are docuemented in firmware file FX2_to_extFIFO.c
        
        // make vendor request structure and populate it
        int status=0; // don't use global status in this function
        USBIO_CLASS_OR_VENDOR_REQUEST VendorRequest=new USBIO_CLASS_OR_VENDOR_REQUEST();
        
        VendorRequest.Flags=UsbIoInterface.USBIO_SHORT_TRANSFER_OK;
        VendorRequest.Type=UsbIoInterface.RequestTypeVendor;
        VendorRequest.Recipient=UsbIoInterface.RecipientDevice;
        VendorRequest.RequestTypeReservedBits=0;
        VendorRequest.Request=VENDOR_REQUEST_STOP_TRANSFER;
        VendorRequest.Index=0;
        
        VendorRequest.Value=0;
        USBIO_DATA_BUFFER dataBuffer=new USBIO_DATA_BUFFER(0);
        dataBuffer.setNumberOfBytesToTransfer(0);
        status=gUsbIo.classOrVendorOutRequest(dataBuffer,VendorRequest);
        if(status!=USBIO_ERR_SUCCESS){
            log.info("disableINEndpoint: couldn't send vendor request to disable IN transfers--it could be that device is gone or sendor is OFF and and completing GPIF cycle");
        }else
            inEndpointEnabled=false;
        HardwareInterfaceException.clearException();
    }
    
    class AsyncStatusThread extends Thread {
        UsbIoPipe pipe;
        CypressFX2 monitor;
        boolean stop=false;
        byte msg;
        AsyncStatusThread(CypressFX2 monitor) {
            this.monitor=monitor;
        }
        
        public void stopThread(){
            if (pipe!=null)
                pipe.abortPipe();
            interrupt();
        }
        
        public void run(){
            setName("AsyncStatusThread");
            int status;
            UsbIoBuf buffer=new UsbIoBuf(64); // size of EP1
            pipe=new UsbIoPipe();
            status=pipe.bind(monitor.getInterfaceNumber(), STATUS_ENDPOINT_ADDRESS, gDevList, GUID);
            if(status!=USBIO_ERR_SUCCESS){
                log.warning("error binding to pipe for EP1 for device status: "+UsbIo.errorText(status));
            }
            USBIO_PIPE_PARAMETERS pipeParams=new USBIO_PIPE_PARAMETERS();
            pipeParams.Flags=UsbIoInterface.USBIO_SHORT_TRANSFER_OK;
            status=pipe.setPipeParameters(pipeParams);
            if (status != USBIO_ERR_SUCCESS) {
                log.warning("can't set pipe parameters: "+UsbIo.errorText(status));
            }
            while(!stop && !isInterrupted()){
                buffer.NumberOfBytesToTransfer=64;
                status=pipe.read(buffer);
                if (status == 0) {
                    log.warning("Stopping status thread: error reading status pipe: "+UsbIo.errorText(buffer.Status));
                    break;
                }
                status=pipe.waitForCompletion(buffer);
                if (status != 0 && buffer.Status!=UsbIoErrorCodes.USBIO_ERR_CANCELED) {
                    log.warning("Stopping status thread: error waiting for completion of read on status pipe: "+UsbIo.errorText(buffer.Status));
                    break;
                }
                if(buffer.BytesTransferred>0){
                    msg=buffer.BufferMem[0];
                    if(msg==1){
                        AEReader rd= getAeReader();
                        if (rd!=null) {
                            log.info("*********************************** CypressFX2.AsyncStatusThread.run(): timestamps externally reset");
                            rd.resetTimestamps();
                        } else {
                            log.info("Received timestamp external reset message, but monitor is not running");
                        }
                    }
                }else{
                    log.warning("warning, 0 bytes in asyncStatusThread");
                }
            }
//            System.out.println("Status reader thread terminated.");
        } // run()
    }
    
    protected boolean relativeTimestampMode=false; //raphael: need this variable to branch in AEReader
    volatile boolean dontwrap=false; // used for resetTimestamps
    
    int aeReaderFifoSize=prefs.getInt("CypressFX2.AEReader.fifoSize",8192);
    
    /** sets the buffer size for the aereader thread. optimal size depends on event rate, for high event
     *  rates, at least 4096 bytes should be chosen, using caviarviewer and low event rates need smaller
     *  buffer size to produce suitable frame rates*/
    public void setAEReaderFifoSize(int size) {
        this.aeReaderFifoSize=size;
        prefs.putInt("CypressFX2.AEReader.fifoSize",size);
    }
    
    int aeReaderNumBuffers=prefs.getInt("CypressFX2.AEReader.numBuffers",4);
    
    
    /** sets the number of buffers for the aereader thread.*/
    public void setAEReaderNumBuffers(int num) {
        this.aeReaderNumBuffers=num;
        prefs.putInt("CypressFX2.AEReader.numBuffers",num);
    }
    
    
    /**
     * AE reader class. the thread continually reads events into buffers. when a buffer is read, ProcessData transfers and transforms the buffer data to AE address
     * and timestamps information and puts it in the addresses and timestamps arrays. a call to acquireAvailableEventsFromDriver copies the events to enw user
     * arrays that can be accessed by getEvents() (this packet is also returned by {@link #acquireAvailableEventsFromDriver}). The relevant methods are synchronized so are thread safe.
     */
    public class AEReader extends UsbIoReader implements ReaderBufferControl{
        
        public final int MAX_NONMONOTONIC_TIME_EXCEPTIONS_TO_PRINT=10;
        private int numNonMonotonicTimeExceptionsPrinted=0;
        int cycleCounter=0;
        volatile boolean timestampsReset=false; // used to tell processData that another thread has reset timestamps
        private int badWrapCounter=0; // counts number of bad timestamp captures (timestamp went backwards)
        final int BAD_WRAP_PRINT_INTERVAL=100; // only print a warning every this many to avoid slowing down critical process
        
        /** the priority for this monitor acquisition thread. This should be set high (e.g. Thread.MAX_PRIORITY) so that the thread can
         * start new buffer reads in a timely manner so that the sender does not get blocked
         * */
        public static final int MONITOR_PRIORITY=Thread.MAX_PRIORITY-3; // Thread.NORM_PRIORITY+2
        
        /** size of CypressFX2 USB fifo's in bytes. */
        public static final int CYPRESS_FIFO_SIZE=512;
        
        /** the default number of USB read buffers used in the reader */
        public static final int CYPRESS_NUM_BUFFERS=2;
        
        /** the number of capture buffers for the buffer pool for the translated address-events.
         * These buffers allow for smoother access to buffer space by the event capture thread */
        private int numBuffers=prefs.getInt("CypressFX2.AEReader.numBuffers",CYPRESS_NUM_BUFFERS);
        
        /** size of FIFOs in bytes used in AEReader for event capture from device.
         * This does not have to be the same size as the FIFOs in the CypressFX2 (512 bytes). If it is too small, then there
         * are frequent thread context switches that can greatly slow down rendering loops.
         */
        private int fifoSize=prefs.getInt("CypressFX2.AEReader.fifoSize",CYPRESS_FIFO_SIZE); // 512;
        CypressFX2 monitor=null;
        
        public AEReader(CypressFX2 m) throws HardwareInterfaceException {
            super();
            monitor=m;
            fifoSize=monitor.aeReaderFifoSize;
            numBuffers=monitor.aeReaderNumBuffers;
            
            int status;
            status = bind(monitor.getInterfaceNumber(),AE_MONITOR_ENDPOINT_ADDRESS, gDevList, GUID); // device has already been opened so we don't need all the params
            if (status != USBIO_ERR_SUCCESS) {
                throw new HardwareInterfaceException("can't bind pipe: "+UsbIo.errorText(status));
            }
            
            USBIO_PIPE_PARAMETERS pipeParams=new USBIO_PIPE_PARAMETERS();
            pipeParams.Flags=UsbIoInterface.USBIO_SHORT_TRANSFER_OK;
            status=setPipeParameters(pipeParams);
            if (status != USBIO_ERR_SUCCESS) {
                throw new HardwareInterfaceException("can't set pipe parameters: "+UsbIo.errorText(status));
            }
        }
        
        public String toString(){
            return "AEReader for "+CypressFX2.this;
        }
        
        // called before buffer is submitted to driver
        public void processBuffer(UsbIoBuf Buf) {
            Buf.NumberOfBytesToTransfer = Buf.Size;
            Buf.BytesTransferred = 0;
            Buf.OperationFinished = false;
            //            System.out.println("ProcessBuffer (before read)");
        }
        
        /** Resets the timestamp unwrap value, resets the USBIO pipe, and resets the AEPacketRawPool.
         */
        synchronized public void resetTimestamps(){
            log.info(CypressFX2.this+": wrapAdd="+wrapAdd+", zeroing it");
            wrapAdd=WRAP_START;
            lasttimestamp=0;
            lastshortts=0;
//            try{
//                setEventAcquisitionEnabled(false);
//                abortPipe();
//                resetPipe(); // make sure to flush all the buffers
//                setEventAcquisitionEnabled(true);
//            }catch(HardwareInterfaceException e){
//                e.printStackTrace();
//            }
            aePacketRawPool.reset();
            timestampsReset=true; // will inform reader thread that timestamps are reset
        }
        
        
        /** Called on completion of read on a data buffer is received from USBIO driver.
         * @param Buf the data buffer with raw data
         */
        synchronized public void processData(UsbIoBuf Buf) {
            cycleCounter++;
//               System.out.print(".");
//                if(cycleCounter%80==0) System.out.println("");
//                System.out.flush();
            if (Buf.Status == USBIO_ERR_SUCCESS || Buf.Status==USBIO_ERR_CANCELED ) {
                //                System.out.println("ProcessData: "+Buf.BytesTransferred+" bytes transferred: ");
                if (monitor.getDID()==CypressFX2.DID_STEREOBOARD) {
                    translateEvents_EmptyWrapEvent(Buf);
                } else if ((monitor.getVIDPID()[1]==PID_USBAERmini2) || (monitor.getVIDPID()[1]==PID_USB2AERmapper)) {
                    translateEvents_EmptyWrapEvent(Buf);
                    CypressFX2MonitorSequencer seq=(CypressFX2MonitorSequencer)(CypressFX2.this);
//                    seq.mapPacket(captureBufferPool.active());
                    
                } else {
                    translateEvents(Buf);
                }
//                pop.play();
                
                if(chip!=null && chip.getFilterChain()!=null && chip.getFilterChain().getProcessingMode()==FilterChain.ProcessingMode.ACQUISITION){
                    // here we do the realTimeFiltering. We finished capturing this buffer's worth of events, now process them
                    // apply realtime filters and realtime (packet level) mapping
                    AEPacketRaw buffer=aePacketRawPool.writeBuffer();
                    short[] addresses=buffer.getAddresses();
                    int[] timestamps=buffer.getTimestamps();
                    realTimeFilter(eventCounter,addresses,timestamps);
                }
            } else {
                log.warning("ProcessData: Bytes transferred: " + Buf.BytesTransferred + "  Status: " + UsbIo.errorText(Buf.Status));
                monitor.close();
            }
            if(timestampsReset){
                log.info("timestampsReset: flushing aePacketRawPool buffers");
                aePacketRawPool.reset();
                timestampsReset=false;
            }
        }
        
        
        // sync so that we don't try to copy events while buffer is being translated
        // this method extracts addresses and timestamps and copies them to the instance addresses and timestamps arrays, where they will be accessed
        // later by the acquireAvailableEventsFromDriver method (which copies them to returned user arrays)
        
        // note timestamps are multiplied by 10 so that they are in us, because the cypress fx2 retina board uses the
        // timer1 interrupt with period 10us to clock the timestamps counters
        
        final int REAL_WRAP_TIME_MS=TICK_US_BOARD*((1<<16)-1)/1000; // this is wrap time in ms on device timestamp counter, e.g. 650ms
        // it is used below to check for bogus timetamp wraps due to glitches in sampling timestamp counter output
        long lastWrapTimeMs=System.currentTimeMillis();
        
        volatile int lastshortts=0, tsinccounter=0;
        volatile int lasttimestamp=0;
        
//        final long START=(1L<<30L);
        final int WRAP_START=0; //(int)(0xFFFFFFFFL&(2147483648L-0x400000L)); // set high to test big wrap 1<<30;
        
        // wrapAdd is the time to add to short timestamp to unwrap it
        volatile int wrapAdd=WRAP_START; //0;
        int lastWrapAdd=0;
        boolean wrappedBig=false;  // indicates that wrapAdd has just wrapped itself, so that we should allow nonmonotonic timestamp
        
        /** Populates the AE array, translating from raw bufffer data to raw addresses and unwrapped timestamps.
         *<p>
         * ae and timestamps are sent from USB device in BIG-ENDIAN format. MSB comes first,
         * The addresses are simply copied over, and the timestamps are unwrapped to make uint32 timestamps.
         * wrapping is detected when the present timestamp is less than the previous one.
         * then we assume the counter has wrapped--but only once--and add into this and subsequent
         * timestamps the wrap value of 2^16. this offset is maintained and increases every time there
         * is a wrap. hence it integrates the wrap offset.
         * the timestamp is returned in 1us ticks.
         * this conversion is to make values more compatible with other CAVIAR software components.
         *<p>
         *If an overrun has occurred, then the data is still translated up to the overrun.
         */
        synchronized protected void translateEvents(UsbIoBuf b){
            boolean badwrap;
//            System.out.println("buf has "+b.BytesTransferred+" bytes");
//            synchronized(aePacketRawPool){
            if(aePacketRawPool.writeBuffer().overrunOccuredFlag) return;  // don't bother if there's already an overrun, consumer must get the events to clear this flag before there is more room for new events
            int shortts;
            byte[] aeBuffer=b.BufferMem;
            //            byte lsb,msb;
            int bytesSent=b.BytesTransferred;
            if(bytesSent%4!=0){
                System.err.println("CypressFX2.AEReader.translateEvents(): warning: "+bytesSent+" bytes sent, which is not multiple of 4");
                bytesSent=(bytesSent/4)*4; // truncate off any extra part-event
            }
            
            AEPacketRaw activeBuffer=aePacketRawPool.writeBuffer();
            
            short[] addresses=activeBuffer.getAddresses();
            int[] timestamps=activeBuffer.getTimestamps();
            
            long timeNowMs=System.currentTimeMillis();
            
            realTimeEventCounterStart=eventCounter;
            
            // write the start of the packet
            activeBuffer.lastCaptureIndex=eventCounter;
            
            for(int i=0;i<bytesSent;i+=4){
                if(eventCounter>AE_BUFFER_SIZE-1){
                    activeBuffer.overrunOccuredFlag=true;
//                                        log.warning("overrun");
                    return; // return, output event buffer is full and we cannot add any more events to it.
                    //no more events will be translated until the existing events have been consumed by acquireAvailableEventsFromDriver
                }
                // according to FX2 tech ref manual 10.2.8, words from GPIF databus are sent over usb as LSB then MSB.
                // therefore AE07 come first, then AE8-15, then TS0-7, then TS8-15
                // see this useful URL: http://www.rgagnon.com/javadetails/java-0026.html about converting singed bytes to int as unsigned
                // address is LSB MSB
                addresses[eventCounter]=(short)(0xffff&((short)aeBuffer[i]&0xff | ((short)aeBuffer[i+1]&0xff)<<8));
                
                // same for timestamp, LSB MSB
                shortts=(aeBuffer[i+2]&0xff | ((aeBuffer[i+3]&0xff)<<8)); // this is 16 bit value of timestamp in TICK_US tick
                
                // shortts could be a negative short value, but each ts should be greater than the last one until 16 bit rollover
                // tobi added following heuristic 12/05 to help deal with problem bit in timestamp counter that apparently gets read incorrectly
                // occasionally, leading to excessive numbers of timestamp wraps
                
                // the preceeding special condition still occurs on tmpdiff128 usb2 cypress retina boards depending on something probably
                // in cypress firmware and reset state, relative to cypress GPIF interface. not understood as of 10/2006. see below
                
                if(shortts<lastshortts){
                    // if new counter value is less than previous one, assume counter has wrapped around.
                    if(dontwrap){
                        dontwrap=false; // this flag is set in outer method resetTimestamps, it should prevent badwrap messages here
                        // even though resetting the timestamps has caused device timestamps to reset
                    }else{
                        // we count how many bits have changed since last timestamp. if timestamp has gone backwards because of a real wrap, then
                        // lots of bits should have changed, e.g from 0xfe to 0x03. but if the timestamp has gone backwards because a single
                        // or two bits have been latched incorrectly, then we count this as bad wrap event.
                        int or=shortts^lastshortts;
                        int bc=Integer.bitCount(or);
//                        System.err.println("wrap, "+bc+" bits changed"); // usually 15/16 bits change or at least 8 when activity is very low
                        if(bc<7){
                            // the timestamp has gone backwards, but this one is due to reading timestamp counter incorrectly.
                            // this is NOT a real wrap, caused by glitch in sampling counter output during count change or something wierd.
                            long dt=timeNowMs-lastWrapTimeMs;
                            if(badWrapCounter++%BAD_WRAP_PRINT_INTERVAL==0){
                                System.err.println("*** BAD WRAP: Event #"+eventCounter+" Real dt="+dt+" ms, shortts="
                                        +HexString.toString(shortts)+" lastshortts="
                                        +HexString.toString(lastshortts)+" wraps="+wrapAdd/0x10000L);
                            }
                            // if this is a bad wrap, then keep the last shortts instead of choosing the one that goes backwards in time
//                                shortts=lastshortts;
//                                badwrap=true;
                            // this has problem that lastshortts doesn't get updated, so there can be a lot of bad wraps signaled.
                        }else{
                            // this IS a real counter wrap
                            // now we need to increment the wrapAdd
                            lastWrapAdd=wrapAdd;
                            wrapAdd += 0x10000*TICK_US_BOARD;	// we put the tick here to correctly detect big wraps // This is 0xFFFF +1; if we wrapped then increment wrap value by 2^16
//                                if(wrapAdd<lastWrapAdd) {
//                                    wrappedBig=true;
//                                }else {
//                                    wrappedBig=false;
//                                }
                            lastWrapTimeMs=timeNowMs;
//                                System.out.println(this+" incremented wrapAdd to "+wrapAdd/(0x10000L)/TICK_US_BOARD+" wraps");
                        }
                    }
                }
                
                // compute tentative value of new timestamp
                int thistimestamp=(int)(   TICK_US_BOARD*shortts  +wrapAdd    ); //*TICK_US; //add in the wrap offset and convert to 1us tick
                
//                    // if shortts is the same as last value, inc the timestamp by 1us to retain some order, at least for first 10 events
//                    if(shortts==lastshortts){
//                        if(tsinccounter++<10) thistimestamp++;
//                    }else {
//                        tsinccounter=0;
//                    }
                
                // don't let timestamps go backwards in time, UNLESS the wrapAdd has wrapped (this happens every 20 minutes)
                if(thistimestamp<lasttimestamp && !( (wrapAdd & 0x80000000) !=0 ) ) {
                    if(numNonMonotonicTimeExceptionsPrinted++<MAX_NONMONOTONIC_TIME_EXCEPTIONS_TO_PRINT){
                        log.warning("NonMonotonicTime event: dt="+(thistimestamp-lasttimestamp));
                        if(numNonMonotonicTimeExceptionsPrinted==MAX_NONMONOTONIC_TIME_EXCEPTIONS_TO_PRINT){
                            log.warning("suppressing further warnings about NonMonotonicTimeException");
                        }
                    }
                    thistimestamp=lasttimestamp; // somehow this time is earlier than last time, we force zero dt here *and* don't reset lastshortts
                }else{
                    lastshortts=shortts;	// save last timestamp to check for rollover; this is usual branch
                }
                
                // save the timestamp
                timestamps[eventCounter]=thistimestamp;
                lasttimestamp=thistimestamp;
                eventCounter++;
                activeBuffer.setNumEvents(eventCounter);
            }
            // write capture size
            activeBuffer.lastCaptureLength=eventCounter-activeBuffer.lastCaptureIndex;
//            System.out.println("index="+activeBuffer.lastCaptureIndex+", length="+activeBuffer.lastCaptureLength);
            //            if(eventCounter<2){
            //                int j=i+1;
            //                System.out.println("aeBuffer["+i+"]="+HexString.byteToHexString(aeBuffer[i])+" aeBuffer["+j+"]="+HexString.byteToHexString(aeBuffer[i+1])
            //                +" addr="+HexString.shortToHexString(addresses[eventCounter-1]));
            //            }
            
            
//            } // sync on aePacketRawPool
        }
        
/* hex translation
 0 	0x0	0000
1 	0x1	0001
2 	0x2	0010
3 	0x3	0011
4 	0x4	0100
5 	0x5	0101
6 	0x6	0110
7 	0x7	0111
8 	0x8	1000
9 	0x9	1001
10 	0xa	1010
11 	0xb	1011
12 	0xc	1100
13 	0xd	1101
14 	0xe	1110
15 	0xf	1111
 */
        
        /** Function to translate the UsbIoBuffer, when the USBAERmini2 board or StereoRetinaBoard is used. Here,
         * the wrapAdd is increased, when an emtpy event is received, which has the timestamp bit 16
         * set to one.
         * therefore, for a valid event, only 15 bits of the 16 transmitted timestamp bits are valid, bit 16
         * is the status bit. overflow happens every 32 ms.
         * This way, no roll overs go by undetected, and the problem of invalid wraps doesn't arise.
         */
        protected void translateEvents_EmptyWrapEvent(UsbIoBuf b){
            
//            System.out.println("buf has "+b.BytesTransferred+" bytes");
            synchronized(aePacketRawPool){
                AEPacketRaw buffer=aePacketRawPool.writeBuffer();
                if(buffer.overrunOccuredFlag) return;  // don't bother if there's already an overrun, consumer must get the events to clear this flag before there is more room for new events
                int shortts;
                int NumberOfWrapEvents;
                NumberOfWrapEvents=0;
                
                byte[] aeBuffer=b.BufferMem;
                //            byte lsb,msb;
                int bytesSent=b.BytesTransferred;
                if(bytesSent%4!=0){
//                System.out.println("CypressFX2.AEReader.translateEvents(): warning: "+bytesSent+" bytes sent, which is not multiple of 4");
                    bytesSent=(bytesSent/4)*4; // truncate off any extra part-event
                }
                
                short[] addresses=buffer.getAddresses();
                int[] timestamps=buffer.getTimestamps();
                
                // write the start of the packet
                buffer.lastCaptureIndex=eventCounter;
                
                for(int i=0;i<bytesSent;i+=4){
                    if(eventCounter>AE_BUFFER_SIZE-1){
                        buffer.overrunOccuredFlag=true;
//                                        log.warning("overrun");
                        return; // return, output event buffer is full and we cannot add any more events to it.
                        //no more events will be translated until the existing events have been consumed by acquireAvailableEventsFromDriver
                    }
                    
                    if((aeBuffer[i+3]&0x80)==0x80){ // timestamp bit 16 is one -> wrap
                        // now we need to increment the wrapAdd
                        wrapAdd+=0x8000L;	// This is 0x7FFF +1; if we wrapped then increment wrap value by 2^15
                        //System.out.println("received wrap event, index:" + eventCounter + " wrapAdd: "+ wrapAdd);
                        NumberOfWrapEvents++;
                    } else {
                        // address is LSB MSB
                        addresses[eventCounter]=(short)(0xffff&((short)aeBuffer[i]&0xff | ((short)aeBuffer[i+1]&0xff)<<8));
                        
                        // same for timestamp, LSB MSB
                        shortts=(aeBuffer[i+2]&0xff | ((aeBuffer[i+3]&0xff)<<8)); // this is 15 bit value of timestamp in TICK_US tick
                        
                        timestamps[eventCounter]=(int)(TICK_US*(shortts+wrapAdd)); //*TICK_US; //add in the wrap offset and convert to 1us tick
                        // this is USB2AERmini2 or StereoRetina board which have 1us timestamp tick
                        eventCounter++;
                        buffer.setNumEvents(eventCounter);
                    }
                } // end for
                
                // write capture size
                buffer.lastCaptureLength=eventCounter-buffer.lastCaptureIndex;
                
                // if (NumberOfWrapEvents!=0) {
                //System.out.println("Number of wrap events received: "+ NumberOfWrapEvents);
                //}
                //System.out.println("wrapAdd : "+ wrapAdd);
            } // sync on aePacketRawPool
        }
        
        public void bufErrorHandler(UsbIoBuf Buf) {
            if ( Buf.Status != USBIO_ERR_SUCCESS ) {
                // print error
                // suppress CANCELED because it is caused by ABORT_PIPE
                if ( Buf.Status != USBIO_ERR_CANCELED ) {
                    log.warning("USB buffer error: "+Buf.Status);
                }
                if(Buf.Status==USBIO_ERR_DEVICE_GONE){
                    log.warning("CypressFX2.bufErrorHandler(): device gone, shutting down buffer pool thread");
                    monitor.close();
                }
            }
        }
        
        // virtual function, called in the context of worker thread
        public void onThreadExit() {
            freeBuffers();
            // System.out.println(this+" event capture worker-thread terminated.\n");
            monitor.aeReaderRunning=false;
        }
        
        // overridden to change priority
        public void startThread(int MaxIoErrorCount) {
//            log.info("CypressFX2.AEReader.startThread()");
            allocateBuffers(getFifoSize(), getNumBuffers());
            super.startThread(MaxIoErrorCount);
            T.setPriority(MONITOR_PRIORITY); // very important that this thread have priority or the acquisition will stall on device side for substantial amounts of time!
            T.setName("AEReader");
//            System.out.println(this+ " event capture worker-thread started");
            monitor.aeReaderRunning=true;
            getSupport().firePropertyChange("readerStarted",false,true); // used in AEViewer to set up menus for changing buffer size
        }
        
        public int getFifoSize() {
            return fifoSize;
        }
        
        public void setFifoSize(int fifoSize) {
            if(fifoSize<CYPRESS_FIFO_SIZE){
                log.warning("CypressFX2 fifo size clipped to device FIFO size "+CYPRESS_FIFO_SIZE);
                fifoSize=CYPRESS_FIFO_SIZE;
            }
            this.fifoSize = fifoSize;
            freeBuffers();
            allocateBuffers(fifoSize,numBuffers);
            prefs.putInt("CypressFX2.AEReader.fifoSize",fifoSize);
        }
        
        public int getNumBuffers() {
            return numBuffers;
        }
        
        public void setNumBuffers(int numBuffers) {
            this.numBuffers = numBuffers;
            freeBuffers();
            allocateBuffers(fifoSize,numBuffers);
            prefs.putInt("CypressFX2.AEReader.numBuffers",numBuffers);
        }
        
        /**
         * Applies the filterChain processing on the most recently captured data. The processing is done
         * by extracting the events just captured and then applying the filter chain.
         * <strong>The filter outputs are discarded and
         * will not be visble in the rendering of the chip output, but may be used for motor control or other purposes.
         * </strong>
         * <p>
         * TODO: at present this processing is redundant in that the most recently captured events are copied to a
         * different AEPacketRaw, extracted to an EventPacket, and then processed. This effort is duplicated
         * later in rendering. This should be fixed somehow.
         * @param eventCounter the number of valid events stored in arrays
         * @param addresses the raw input addresses; these are filtered in place
         * @param timestamps the input timestamps
         */
        private void realTimeFilter(int eventCounter, short[] addresses, int[] timestamps) {
            
            try{
                if(!chip.getFilterChain().isAnyFilterEnabled()) return;
                
                // initialize packets
                if(realTimeRawPacket==null)
                    realTimeRawPacket=new AEPacketRaw(getNumRealTimeEvents());
                else
                    realTimeRawPacket.ensureCapacity(getNumRealTimeEvents());
                
                // copy data to real time raw packet
                if(addresses==null || timestamps==null){
                    log.warning("realTimeFilter: addresses or timestamp array became null");
                }else{
                    System.arraycopy(addresses,realTimeEventCounterStart,realTimeRawPacket.getAddresses(),0,getNumRealTimeEvents());
                    System.arraycopy(timestamps,realTimeEventCounterStart,realTimeRawPacket.getTimestamps(),0,getNumRealTimeEvents());
                    
                    realTimeRawPacket.setNumEvents(getNumRealTimeEvents());
                    // init extracted packet
                    if(realTimePacket==null)
                        realTimePacket=new EventPacket(chip.getEventClass());
                    
                    // extract events for this filter. This duplicates later effort during rendering and should be fixed for later.
                    // at present this may mess up everything else because the output packet is reused.
                    chip.getEventExtractor().extractPacket(realTimeRawPacket,realTimePacket);
                    
                    getChip().getFilterChain().filterPacket(realTimePacket);
                }
            }catch(ArrayIndexOutOfBoundsException e){
                e.printStackTrace();
            }
            // we don't do following because the results are an AEPacketRaw that still needs to be written to addresses/timestamps
            // and this is not done yet. at present results of realtime filtering are just not rendered at all.
//            chip.getEventExtractor().reconstructRawPacket(realTimePacket);
        }
    }
    
    int getNumRealTimeEvents(){
        return eventCounter-realTimeEventCounterStart;
    }
    
    void allocateAEBuffers(){
        synchronized(aePacketRawPool){
            aePacketRawPool.allocateMemory();
        }
    }
    
    /** @return the size of the buffer for AEs */
    public int getAEBufferSize() {
        return aePacketRawPool.writeBuffer().getCapacity();
    }
    
    /** set the size of the host buffer. Default is AE_BUFFER_SIZE. You can set this larger if you
     *have overruns because your host processing (e.g. rendering) is taking too long.
     *<p>
     *This call discards collected events.
     * @param size of buffer in events
     */
    public void setAEBufferSize(int size) {
        allocateAEBuffers();
    }
    
    public void onAdd() {
        log.info("USBAEMonitor.onAdd(): device added");
    }
    
    public void onRemove() {
        log.info("USBAEMonitor.onRemove(): device removed");
    }
    
    /** start or stops the event acquisition. sends apropriate vendor request to
     * device and starts or stops the AEReader
     * @param enable boolean to enable or disable event acquisition
     */
    synchronized public void setEventAcquisitionEnabled(boolean enable) throws HardwareInterfaceException {
//        log.info("setting event acquisition="+enable);
        setInEndpointEnabled(enable);
        if(enable) startAEReader(); else stopAEReader();
    }
    
    public boolean isEventAcquisitionEnabled() {
        return isInEndpointEnabled();
    }
    
    public String getTypeName() {
        return "CypressFX2";
    }
    
    /** the first USB string descriptor (Vendor name) (if available) */
    protected USB_STRING_DESCRIPTOR stringDescriptor1 = new USB_STRING_DESCRIPTOR();
    
    /** the second USB string descriptor (Product name) (if available) */
    protected USB_STRING_DESCRIPTOR stringDescriptor2 = new USB_STRING_DESCRIPTOR();
    
    /** the third USB string descriptor (Serial number) (if available) */
    protected USB_STRING_DESCRIPTOR stringDescriptor3 = new USB_STRING_DESCRIPTOR();
    
    protected int numberOfStringDescriptors=2;
    
    /** returns number of string descriptors
     * @return number of string descriptors: 2 for TmpDiff128, 3 for MonitorSequencer */
    public int getNumberOfStringDescriptors() {
        return numberOfStringDescriptors;
    }
    
    /** the USBIO device descriptor */
    protected USB_DEVICE_DESCRIPTOR deviceDescriptor = new USB_DEVICE_DESCRIPTOR();
    
    
    /** the UsbIo interface to the device. This is assigned on construction by the
     * factory which uses it to open the device. here is used for all USBIO access
     * to the device*/
    protected UsbIo gUsbIo=null;
    
    /** the devlist handle for USBIO */
    protected int gDevList; // 'handle' (an integer) to an internal device list static to UsbIo
    
    
//    void buildUsbInterfaceList(){
//        buildUsbIoList();
//        usbList=new ArrayList<USBInterface>();
//        for(UsbIo u:usbioList){
//            try{
////                open();
////                usbList.add(this);
////                CypressFX2 dev=new CypressFX2();
////                dev.gUsbIo=u;
////                dev.open();
//                openUsbIo(u);
//                usbList.add(this);
//            }catch(USBInterfaceException e){
//                return;
//            }
//        }
//    }
//
    
    /** checks if device has a string identifier that is a non-empty string
     *@return false if not, true if there is one
     */
    protected boolean hasStringIdentifier(){
        // get string descriptor
        status = gUsbIo.getStringDescriptor(stringDescriptor1,(byte)1,0);
        if (status != USBIO_ERR_SUCCESS) {
            return false;
        } else {
            if(stringDescriptor1.Str.length()>0) return true;
        }
        return false;
    }
    
    /** constrcuts a new USB connection, opens it. Does NOT start event acquisition.
     * @see #setEventAcquisitionEnabled
     */
    public void open() throws HardwareInterfaceException {
//        log.info(Thread.currentThread()+": CypressFX2.open()");
        openUsbIo();
//        setEventAcquisitionEnabled(true); // don't enable anymore, do this instead in acquireAvailableEventsFromDriver if necessary
        HardwareInterfaceException.clearException();
    }
    
    /**
     * This method does the hard work of opening the device, downloading the firmware, making sure everything is OK.
     * This method is synchronized to prevent multiple threads from trying to open at the same time, e.g. a GUI thread and the main thread.
     *
     * Opening the device after it has already been opened has no effect.
     *
     * @see #close
     *@throws HardwareInterfaceException if there is a problem. Diagnostics are printed to stderr.
     */
    synchronized protected void openUsbIo() throws HardwareInterfaceException {
        
        //device has already been UsbIo Opened by now, in factory
        
        // opens the USBIOInterface device, configures it, binds a reader thread with buffer pool to read from the device and starts the thread reading events.
        // we got a UsbIo object when enumerating all devices and we also made a device list. the device has already been
        // opened from the UsbIo viewpoint, but it still needs firmware download, setting up pipes, etc.
        
        if(isOpened){
//            log.warning("CypressFX2.openUsbIo(): already opened interface and setup device");
            return;
        }
        
        int status;
        
        gUsbIo=new UsbIo();
        gDevList=UsbIo.createDeviceList(GUID);
        status = gUsbIo.open(getInterfaceNumber(),gDevList,GUID);
        if (status != USBIO_ERR_SUCCESS) {
            UsbIo.destroyDeviceList(gDevList);
            isOpened=false;
            throw new HardwareInterfaceException("CypressFX2.openUsbIo(): can't open USB device: "+UsbIo.errorText(status));
        }
        
        // get device descriptor (possibly before firmware download, when still bare cypress device or running off EEPROM firmware)
        status = gUsbIo.getDeviceDescriptor(deviceDescriptor);
        if (status != USBIO_ERR_SUCCESS) {
            UsbIo.destroyDeviceList(gDevList);
            throw new HardwareInterfaceException("CypressFX2.openUsbIo(): getDeviceDescriptor: "+UsbIo.errorText(status));
        } else {
//            log.info("getDeviceDescriptor: Vendor ID (VID) "
//                    + HexString.toString((short)deviceDescriptor.idVendor)
//                    + " Product ID (PID) " + HexString.toString((short)deviceDescriptor.idProduct));
        }
        
        // possibly download binary firmware to Cypress RAM
        downloadFirmwareBinary();
        
        boolean success=false; int triesLeft=40;
        long delay=400;
//        System.out.print("Reopening after firmware download ");
        while(!success && triesLeft>0){
            try{Thread.currentThread().sleep(delay);}catch(InterruptedException e){}
            gDevList=UsbIo.createDeviceList(GUID);
            gUsbIo=new UsbIo();
            status = gUsbIo.open(getInterfaceNumber(),gDevList,GUID);
            if (status != USBIO_ERR_SUCCESS) {
                UsbIo.destroyDeviceList(gDevList);
                triesLeft--;
//                System.out.print("."); System.out.flush();
            }else{
                success=true;
            }
        }
//        System.out.println("done");
        if(!success) throw new HardwareInterfaceException("couldn't reopen device after firmware download and renumeration: "+UsbIo.errorText(status));
        
        try{
            unconfigureDevice(); // in case it was left configured from a terminated process
        }catch(HardwareInterfaceException e){
            log.warning("CypressFX2.open(): can't unconfigure,will try simulated disconnect");
            int cycleStatus=gUsbIo.cyclePort();
            if(cycleStatus!=USBIO_ERR_SUCCESS){
                throw new HardwareInterfaceException("Error cycling port: "+UsbIo.errorText(status));
            }
            throw new HardwareInterfaceException("couldn't unconfigure device");
        }
        
        // set configuration -- must do this BEFORE downloading firmware!
        USBIO_SET_CONFIGURATION Conf = new USBIO_SET_CONFIGURATION();
        Conf.ConfigurationIndex = CONFIG_INDEX;
        Conf.NbOfInterfaces = CONFIG_NB_OF_INTERFACES;
        Conf.InterfaceList[0].InterfaceIndex = CONFIG_INTERFACE;
        Conf.InterfaceList[0].AlternateSettingIndex = CONFIG_ALT_SETTING;
        Conf.InterfaceList[0].MaximumTransferSize = CONFIG_TRAN_SIZE;
        status = gUsbIo.setConfiguration(Conf);
        if (status != USBIO_ERR_SUCCESS) {
//            gUsbIo.destroyDeviceList(gDevList);
            //   if (status !=0xE0001005)
            throw new HardwareInterfaceException("CypressFX2.openUsbIo(): setting configuration after firmware download: "+UsbIo.errorText(status));
        }
        
        //        try{Thread.currentThread().sleep(100);} catch(InterruptedException e){}; // pause for renumeration
        
        //        System.out.println("after firmware download and reenumeration, descriptors are");
        // get device descriptor
        status = gUsbIo.getDeviceDescriptor(deviceDescriptor);
        if (status != USBIO_ERR_SUCCESS) {
            UsbIo.destroyDeviceList(gDevList);
            throw new HardwareInterfaceException("CypressFX2.openUsbIo(): getDeviceDescriptor: "+UsbIo.errorText(status));
        } else {
//            log.info("getDeviceDescriptor: Vendor ID (VID) "
//                    + HexString.toString((short)deviceDescriptor.idVendor)
//                    + " Product ID (PID) " + HexString.toString((short)deviceDescriptor.idProduct));
        }
        
        if (deviceDescriptor.iSerialNumber!=0)
            this.numberOfStringDescriptors=3;
        
        // get string descriptor
        status = gUsbIo.getStringDescriptor(stringDescriptor1,(byte)1,0);
        if (status != USBIO_ERR_SUCCESS) {
            UsbIo.destroyDeviceList(gDevList);
            throw new HardwareInterfaceException("CypressFX2.openUsbIo(): getStringDescriptor: "+UsbIo.errorText(status));
        } else {
//            log.info("getStringDescriptor 1: " + stringDescriptor1.Str);
        }
        
        // get string descriptor
        status = gUsbIo.getStringDescriptor(stringDescriptor2,(byte)2,0);
        if (status != USBIO_ERR_SUCCESS) {
            UsbIo.destroyDeviceList(gDevList);
            throw new HardwareInterfaceException("CypressFX2.openUsbIo(): getStringDescriptor: "+UsbIo.errorText(status));
        } else {
//            log.info("getStringDescriptor 2: " + stringDescriptor2.Str);
        }
        
        if (this.numberOfStringDescriptors==3) {
            // get serial number string descriptor
            status = gUsbIo.getStringDescriptor(stringDescriptor3,(byte)3,0);
            if (status != USBIO_ERR_SUCCESS) {
                UsbIo.destroyDeviceList(gDevList);
                throw new HardwareInterfaceException("CypressFX2.openUsbIo(): getStringDescriptor: "+UsbIo.errorText(status));
            } else {
//                log.info("getStringDescriptor 3: " + stringDescriptor3.Str);
            }
        }
        
        if(!gUsbIo.isOperatingAtHighSpeed()){
            log.warning("CypressFX2.openUsbIo(): Warning: device is not operating at USB 2.0 High Speed, performance will be limited to about 300 keps");
        }
        
        // get pipe information and extract the FIFO size
        USBIO_CONFIGURATION_INFO ConfigurationInfo = new USBIO_CONFIGURATION_INFO();
        status = gUsbIo.getConfigurationInfo(ConfigurationInfo);
        if (status != USBIO_ERR_SUCCESS) {
            UsbIo.destroyDeviceList(gDevList);
            throw new HardwareInterfaceException("CypressFX2.openUsbIo(): getConfigurationInfo: "+UsbIo.errorText(status));
        }
        
        if(ConfigurationInfo.NbOfPipes==0){
//            gUsbIo.cyclePort();
            throw new HardwareInterfaceException("CypressFX2.openUsbIo(): didn't find any pipes to bind to");
        }
        
        // start the thread that listens for device status information (e.g. timestamp reset)
        asyncStatusThread=new AsyncStatusThread(this);
        asyncStatusThread.start();
//        log.info("resetting 8051");
//        set8051Reset(true);
//        set8051Reset(false);
        
        isOpened=true;
        
    }
    
// unconfigure device in case it was still configured from a prior terminated process
    synchronized void unconfigureDevice() throws HardwareInterfaceException {
        int status;
//        System.out.println("CypressFX2RetinaBiasgen.unconfigureDevice()");
        status = gUsbIo.unconfigureDevice();
        if (status != USBIO_ERR_SUCCESS) {
            gUsbIo.destroyDeviceList(gDevList);
            //            throw new USBAEMonitorException("getStringDescriptor: "+gUsbIo.errorText(status));
            throw new HardwareInterfaceException("unconfigureDevice: "+UsbIo.errorText(status));
            //            System.out.println("getConfigurationInfo ok");
        }
        //        System.out.println("unconfigured device");
    }
    
    /** return the string USB descriptors for the device
     *@return String[] of length 2 of USB descriptor strings.
     */
    public String[] getStringDescriptors() {
        if(stringDescriptor1==null) {
            log.warning("USBAEMonitor: getStringDescriptors called but device has not been opened");
            String[] s=new String[numberOfStringDescriptors];
            for (int i=0;i<numberOfStringDescriptors;i++) {
                s[i]="";
            }
            return s;
        }
        String[] s=new String[numberOfStringDescriptors];
        s[0]=stringDescriptor1.Str;
        s[1]=stringDescriptor2.Str;
        if (numberOfStringDescriptors==3) {
            s[2]=stringDescriptor3.Str;
        }
        return s;
    }
    
    /** return the USB VID/PID of the interface
     *@return int[] of length 2 containing the Vendor ID (VID) and Product ID (PID) of the device. First element is VID, second element is PID.
     */
    public int[] getVIDPID() {
        if(deviceDescriptor==null) {
            log.warning("USBAEMonitor: getVIDPID called but device has not been opened");
            return new int[2];
        }
        int[] n=new int[2];
        n[0]=deviceDescriptor.idVendor;
        n[1]=deviceDescriptor.idProduct;
        return n;
    }
    
    
    public short getVID() {
        if(deviceDescriptor==null) {
            log.warning("USBAEMonitor: getVIDPID called but device has not been opened");
            return 0;
        }
        // int[] n=new int[2]; n is never used
        return (short)deviceDescriptor.idVendor;
    }
    
    public short getPID() {
        if(deviceDescriptor==null) {
            log.warning("USBAEMonitor: getVIDPID called but device has not been opened");
            return 0;
        }
        return (short)deviceDescriptor.idProduct;
    }
    
    /** @return bcdDevice (the binary coded decimel device version */
    public short getDID() { // this is not part of USB spec in device descriptor.
        return (short)deviceDescriptor.bcdDevice;
    }
    
    /** reports if interface is {@link #open}.
     * @return true if already open
     */
    public boolean isOpen() {
        return isOpened;
    }
    
    public byte[] loadBinaryFirmwareFile(String firmwareFilename) throws IOException{
        log.info("writing firmware file "+firmwareFilename);
        InputStream firmwareFileStream;
        byte[] FWBuffer;
        // load firmware file (this is binary file of 8051 firmware)
        try{
            firmwareFileStream=getClass().getResourceAsStream(firmwareFilename);
            if(firmwareFileStream==null) throw new IOException("can't load binary Cypress FX2 firmware file "+firmwareFilename);
            FWBuffer=new byte[firmwareFileStream.available()];
            log.info("CypressFX2.downloadFirmware(): firmware filename is "+firmwareFileStream.available()+" bytes long");
            firmwareFileStream.read(FWBuffer);
            firmwareFileStream.close();
        }catch(IOException e){
            close();
            log.warning(e.getMessage());
            throw new IOException("can't load binary Cypress FX2 firmware file "+firmwareFilename);
        }
        return FWBuffer;
    }
    
    /** downloads firmware to FX2 RAM. adapted from John Arthur's example, which comes from Cypress example.
     * Firmware file is a binary file produced by uVision2 (Keil) from source code for firmware.
     *<p>
     *Firmware that is actually downloaded depends on discovered PID of device. If the PID is discovered to be a bare CypressFX2, then
     *a dialog is shown that user can use to program the VID/PID of the device.
     *<p>
     *In addition, there is a problem if firmware is downloaded more than once to an FX2LP device between hard resets. Therefore if this method detects
     *that the device has string identitifers, it assumes the firmware has already been downloaded.
     *
     *
     * Firmware file is loaded as a resource from the jar archive.
     */
    synchronized void downloadFirmwareBinary(String firmwareFilename) throws HardwareInterfaceException {
        
        InputStream firmwareFile;  // firmware file
        byte[] FWBuffer; // buffer to hold contents of firmware file (binary 8051 code)
        
        try{
            FWBuffer=loadBinaryFirmwareFile(firmwareFilename);
        }catch(IOException e){
            close();
            log.warning(e.getMessage());
            throw new HardwareInterfaceException("can't load binary Cypress FX2 firmware file "+firmwareFilename);
        }
        
        set8051Reset(true);
        download8051RAM(0, FWBuffer);
        set8051Reset(false);
    }
    
    /** downloads firmware to FX2 RAM. adapted from John Arthur's example, which comes from Cypress example.
     * Firmware file is a binary file produced by uVision2 (Keil) from source code for firmware.
     *<p>
     *Firmware that is actually downloaded depends on discovered PID of device. If the PID is discovered to be a bare CypressFX2, then
     *a dialog is shown that user can use to program the VID/PID of the device.
     *<p>
     *In addition, there is a problem if firmware is downloaded more than once to an FX2LP device between hard resets. Therefore if this method detects
     *that the device has string identitifers, it assumes the firmware has already been downloaded.
     *
     *
     * Firmware file is loaded as a resource from the jar archive.
     */
    synchronized void downloadFirmwareBinary() throws HardwareInterfaceException {
        
        if(hasStringIdentifier()){
//            log.info("CypressFX2.downloadFirmware(): device has string identifier already, not downloading firmware");
            return;
        }
        
        //  firmware load variables
        byte[] FWBuffer; // buffer to hold contents of firmware file (binary 8051 code)
        
        String firmwareFilename = getFirmwareFilenameBinaryFromVIDPID();
        
        try{
            FWBuffer=loadBinaryFirmwareFile(firmwareFilename);
        }catch(IOException e){
            close();
            log.warning(e.getMessage());
            throw new HardwareInterfaceException("can't load binary Cypress FX2 firmware file "+firmwareFilename);
        }
        
        set8051Reset(true);
        download8051RAM(0, FWBuffer);
        set8051Reset(false);
        
        
    } // downloadFirmwareBinary()
    
// returns the firmware filenmae corresponding to a VID/PID pair
// this filename is actually a full path to a resource on the classpath
    protected String getFirmwareFilenameBinaryFromVIDPID() {
        String firmwareFilename=null;
        if(getVIDPID()[1]==PID_DAREK_FX2_BOARD){
            firmwareFilename=FIRMWARE_FILENAME_DAREK_BOARD;
        } else if (getVIDPID()[1]==PID_USBAERmini2_without_firmware){
            firmwareFilename=FIRMWARE_FILENAME_MONITOR_SEQUENCER;
        }else if (getVIDPID()[1]==PID_USBAERmini2){
            firmwareFilename=FIRMWARE_FILENAME_MONITOR_SEQUENCER;
        }else{
            firmwareFilename=FIRMWARE_FILENAME_TMPDIFF128;
        }
        
        return firmwareFilename;
    }
    
    // returns the firmware filenmae corresponding to a VID/PID pair
    // this filename is actually a full path to a resource on the classpath
    protected String getFirmwareFilenameHexFromVIDPID() {
        String firmwareFilename=null;
        if (getVIDPID()[1]==PID_USBAERmini2_without_firmware){
            firmwareFilename=FIRMWARE_FILENAME_MONITOR_SEQUENCER_HEX;
        }else{
            firmwareFilename=FIRMWARE_FILENAME_TMPDIFF128_HEX;
        }
        return firmwareFilename;
    }
    
    /** downloads to RAM on FX2 using built-in vendor request to CPUCS
     * // remember to set8051Reset() before and after calling this method
     *@param address the starting address in the 8051 RAM
     *@param FWBuffer the data
     *@see #set8051Reset
     */
    protected void download8051RAM(int address, final byte[] FWBuffer)
    throws HardwareInterfaceException {
        
        /* From Fx2 tech ref guide, chapter 2 "endpoint 0"
         *
         *The USB endpoint-zero protocol provides a mechanism for mixing
         vendor-specific requests with standard device requests. Bits 6:5 of the bmRequestType
         field are set to 00 for a standard device request and to 10 for a vendor request.
         **/
        // need to perform the following steps:
        //
        //	1) reset the Cypress (write 0x01 into CPUCS register)
        //	2) send the firmware to Control Endpoint 0
        //	3) pull the Cypress out of reset (write 0x00 into the CPUCS register)
        
        // this is achieved by using the vendor request VENDOR_REQUEST_FIRMWARE, where the Value of the request is the
        // address to write to and the buffer passed to USBIO_CLASS_OR_VENDOR_REQUEST defines data to be written
        // starting at this address and the number of bytes to be written.
        // thus the same vendor request can reset the 8051 (one byte written to CPUCS) and download successive chunks
        // of code. finally the request can unreset the 8051.
        
        int result;
        USBIO_CLASS_OR_VENDOR_REQUEST vendorRequest=new USBIO_CLASS_OR_VENDOR_REQUEST();
        USBIO_DATA_BUFFER dataBuffer;
        int fwIndex;
        int numChunks;
        
        vendorRequest.Flags=UsbIoInterface.USBIO_SHORT_TRANSFER_OK;
        vendorRequest.Type=UsbIoInterface.RequestTypeVendor;  // this is a vendor, not generic USB, request
        vendorRequest.Recipient=UsbIoInterface.RecipientDevice; // device (not endpoint, interface, etc) receives it
        vendorRequest.RequestTypeReservedBits=0;    // set these bits to zero for Cypress-specific 'vendor request' rather that user defined
        vendorRequest.Request=VENDOR_REQUEST_FIRMWARE; // this is download/upload firmware request. really it is just a 'fill RAM request'
        vendorRequest.Index=0;
        
        //	2) send the firmware to Control Endpoint 0
        // when sending firmware, we need to break up the loaded fimware
        //		into MAX_CONTROL_XFER_SIZE blocks
        //
        // this means:
        //	a) the address to load it to needs to be changed (VendorRequest.Value)
        //	b) need a pointer that moves through FWbuffer (pBuffer)
        //	c) keep track of remaining bytes to transfer (FWsize_left);
        
        
        //send all but last chunk
        vendorRequest.Value = 0;			//address of firmware location
        dataBuffer=new USBIO_DATA_BUFFER(MAX_CONTROL_XFER_SIZE);
        dataBuffer.setNumberOfBytesToTransfer(dataBuffer.Buffer().length);
        fwIndex=0;
        numChunks=FWBuffer.length/MAX_CONTROL_XFER_SIZE;  // this is number of full chunks to send
        for(int i=0;i<numChunks;i++){
            System.arraycopy(FWBuffer, i*MAX_CONTROL_XFER_SIZE, dataBuffer.Buffer(), 0, MAX_CONTROL_XFER_SIZE);
            result=gUsbIo.classOrVendorOutRequest(dataBuffer,vendorRequest);
            if(result!=USBIO_ERR_SUCCESS){
                close();
                throw new HardwareInterfaceException("Error on downloading segment number "+i+" of 8051 firmware: "+UsbIo.errorText(result));
            }
            vendorRequest.Value += MAX_CONTROL_XFER_SIZE;			//change address of firmware location
        }
        
        // now send final (short) chunk
        int numBytesLeft=FWBuffer.length%MAX_CONTROL_XFER_SIZE;  // remainder
        if(numBytesLeft>0){
            dataBuffer=new USBIO_DATA_BUFFER(numBytesLeft);
            dataBuffer.setNumberOfBytesToTransfer(dataBuffer.Buffer().length);
            System.arraycopy(FWBuffer, numChunks*MAX_CONTROL_XFER_SIZE, dataBuffer.Buffer(), 0, numBytesLeft);
            
            // send remaining part of firmware
            result=gUsbIo.classOrVendorOutRequest(dataBuffer,vendorRequest);
            if(result!=USBIO_ERR_SUCCESS){
                close();
                throw new HardwareInterfaceException("Error on downloading final segment of 8051 firmware: "+UsbIo.errorText(result));
            }
        }
        
    }
    
    /**
     * sends vendor request to CPUCS register to set 8051 in CPU reset (or not)
     *@param value true to reset, false to run
     *@see #download8051RAM
     */
    protected void set8051Reset(boolean value) throws HardwareInterfaceException {
        
        log.info("setting 8051 reset="+value);
        
        int result;
        USBIO_DATA_BUFFER dataBuffer;
        USBIO_CLASS_OR_VENDOR_REQUEST vendorRequest;
        // make vendor request structure and populate it
        vendorRequest=new USBIO_CLASS_OR_VENDOR_REQUEST();
        
        vendorRequest.Flags=UsbIoInterface.USBIO_SHORT_TRANSFER_OK;
        vendorRequest.Type=UsbIoInterface.RequestTypeVendor;  // this is a vendor, not generic USB, request
        vendorRequest.Recipient=UsbIoInterface.RecipientDevice; // device (not endpoint, interface, etc) receives it
        vendorRequest.RequestTypeReservedBits=0;    // set these bits to zero for Cypress-specific 'vendor request' rather that user defined
        vendorRequest.Request=VENDOR_REQUEST_FIRMWARE; // this is download/upload firmware request. really it is just a 'fill RAM request'
        vendorRequest.Index=0;
        
        //	1) reset the Cypress (write 0x01 into CPUCS register)
        
        vendorRequest.Value=CPUCS; // we're writing to this RAM address, which is actually the only register that the host can write to
        dataBuffer=new USBIO_DATA_BUFFER(1); // make a new buffer to define the length of the request data correctly
        dataBuffer.Buffer()[0]= (byte)(value?1:0);            // 1 to reset, 0 to run
        dataBuffer.setNumberOfBytesToTransfer(dataBuffer.Buffer().length);
        result=gUsbIo.classOrVendorOutRequest(dataBuffer,vendorRequest);
        if(result!=USBIO_ERR_SUCCESS){
            close();
            throw new HardwareInterfaceException("Unable to reset 8051 for firmware download: "+UsbIo.errorText(result));
        }
        
    }
    
    
    /** @return timestamp tick in us
     * NOTE: DOES NOT RETURN THE TICK OF THE USBAERmini2 board*/
    final public int getTimestampTickUs() {
        return TICK_US;
    }
    
    /** returns last events from {@link #acquireAvailableEventsFromDriver}
     *@return the event packet
     */
    public AEPacketRaw getEvents() {
        return this.lastEventsAcquired;
    }
    
    /** sends a vender request without data, value and index are set to zero.
     *@param request the vendor request byte, identifies the request on the device
     */
    synchronized public void sendVendorRequest(byte request) throws HardwareInterfaceException {
        sendVendorRequest(request, (short)0, (short)0, null);
    }
    
    /** sends a vender request without any data.
     *@param request the vendor request byte, identifies the request on the device
     *@param value the value of the request (bValue USB field)
     *@param index the "index" of the request (bIndex USB field)
     */
    synchronized public void sendVendorRequest(byte request, short value, short index) throws HardwareInterfaceException {
        sendVendorRequest(request, value, index, null);
    }
    
    /** sends a vender request with data.
     *@param request the vendor request byte, identifies the request on the device
     *@param value the value of the request (bValue USB field)
     *@param index the "index" of the request (bIndex USB field)
     *@param dataBuffer the data which is to be transmitted to the device
     */
    synchronized public void sendVendorRequest(byte request, short value, short index, USBIO_DATA_BUFFER dataBuffer) throws HardwareInterfaceException {
        if (!isOpen()) {
            open();
        }
        
        // make vendor request structure and populate it
        USBIO_CLASS_OR_VENDOR_REQUEST VendorRequest=new USBIO_CLASS_OR_VENDOR_REQUEST();
        int status;
        
        VendorRequest.Flags=UsbIoInterface.USBIO_SHORT_TRANSFER_OK;
        VendorRequest.Type=UsbIoInterface.RequestTypeVendor;
        VendorRequest.Recipient=UsbIoInterface.RecipientDevice;
        VendorRequest.RequestTypeReservedBits=0;
        VendorRequest.Request= request;
        VendorRequest.Index= index;
        VendorRequest.Value= value;
        
        //System.out.println("request= " + request + " value: " + value);
        
        if (dataBuffer==null) {
            dataBuffer=new USBIO_DATA_BUFFER(1);
            dataBuffer.setNumberOfBytesToTransfer(dataBuffer.Buffer().length);
        } else {
            dataBuffer.setNumberOfBytesToTransfer(dataBuffer.Buffer().length);
        }
        
        status=gUsbIo.classOrVendorOutRequest(dataBuffer,VendorRequest);
        
        if(status!=USBIO_ERR_SUCCESS){
            throw new HardwareInterfaceException("Unable to send vendor request "+ request + ": " + UsbIo.errorText(status));
        }
        
        HardwareInterfaceException.clearException();
    }
    
    public AEReader getAeReader() {
        return aeReader;
    }
    
    public void setAeReader(AEReader aeReader) {
        this.aeReader = aeReader;
    }
    
    public int getFifoSize() {
        if(aeReader==null) return 0; else return aeReader.getFifoSize();
    }
    
    public void setFifoSize(int fifoSize) {
        if(aeReader==null) return;
        aeReader.shutdownThread();
        aeReader.setFifoSize(fifoSize);
        aeReader.startThread(3);
    }
    
    public int getNumBuffers() {
        if(aeReader==null) return 0; else return aeReader.getNumBuffers();
    }
    
    public void setNumBuffers(int numBuffers) {
        if(aeReader==null) return;
        aeReader.shutdownThread();
        aeReader.setNumBuffers(numBuffers);
        aeReader.startThread(3);
    }
    
//    /** adds a filter that operates on the data as it is captured in the AEReader thread
//     @param f the filter
//     */
//    public void addRealTimeFilter(EventFilter2D f) {
////        realTimeFilterChain.add(f);
//    }
//
//    /** removes a filter that operates on the data as it is captured in the AEReader thread
//     @param f the filter
//     */
//    public void removeRealTimeFilter(EventFilter2D f) {
////        realTimeFilterChain.remove(f);
//    }
    
//    /** @return filters that are applied to the events as they are captured */
//    public FilterChain getRealTimeFilterChain() {
//        return null;
////        return realTimeFilterChain;
//    }
    
    public void setChip(AEChip chip) {
        this.chip=chip;
    }
    
    public AEChip getChip() {
        return chip;
    }
    
} //CypressFX2

