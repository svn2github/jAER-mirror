/*
 * USBAEMon.java
 * 
 * Created on February 17, 2005, 7:54 AM
 */
package net.sf.jaer.hardwareinterface.usb.cypressfx2libusb;

import java.awt.Component;
import java.beans.PropertyChangeEvent;
import java.beans.PropertyChangeSupport;
import java.io.File;
import java.io.FileInputStream;
import java.io.FileNotFoundException;
import java.io.IOException;
import java.io.InputStream;
import java.nio.ByteBuffer;
import java.nio.CharBuffer;
import java.nio.IntBuffer;
import java.nio.charset.Charset;
import java.nio.charset.CharsetEncoder;
import java.util.ArrayList;
import java.util.logging.Level;
import java.util.logging.Logger;
import java.util.prefs.Preferences;

import javax.swing.ProgressMonitor;

import jp.ac.osakau.eng.eei.IVS128HardwareInterface;
import li.longi.USBTransferThread.RestrictedTransfer;
import li.longi.USBTransferThread.RestrictedTransferCallback;
import li.longi.USBTransferThread.USBTransferThread;
import net.sf.jaer.aemonitor.AEListener;
import net.sf.jaer.aemonitor.AEMonitorInterface;
import net.sf.jaer.aemonitor.AEPacketRaw;
import net.sf.jaer.aemonitor.AEPacketRawPool;
import net.sf.jaer.chip.AEChip;
import net.sf.jaer.event.EventPacket;
import net.sf.jaer.eventprocessing.EventFilter;
import net.sf.jaer.eventprocessing.FilterChain;
import net.sf.jaer.hardwareinterface.BlankDeviceException;
import net.sf.jaer.hardwareinterface.HardwareInterfaceException;
import net.sf.jaer.hardwareinterface.usb.ReaderBufferControl;
import net.sf.jaer.hardwareinterface.usb.USBInterface;
import net.sf.jaer.stereopsis.StereoPairHardwareInterface;
import net.sf.jaer.util.HexFileParser;
import net.sf.jaer.util.HexString;
import de.ailis.usb4java.libusb.Device;
import de.ailis.usb4java.libusb.DeviceDescriptor;
import de.ailis.usb4java.libusb.DeviceHandle;
import de.ailis.usb4java.libusb.LibUsb;
import de.ailis.usb4java.utils.BufferUtils;

/**
 * Devices that use the CypressFX2 and the USBIO driver, e.g. the DVS retinas, the USBAERmini2. This class should not
 * normally be constructed but rather a subclass that overrides
 * the AEReader should be used.
 * <p>
 * In this class, you can also set the size of the host buffer with {@link #setAEBufferSize}, giving you more time
 * between calls to process the events.
 * <p>
 * On the device, a timer sends all available events approximately every 10ms -- you don't need to wait for a fixed size
 * buffer to be captured to be available to the host. But if events come quickly enough, new events can be available
 * much faster than this.
 * <p>
 * You can also request at any time an early transfer of events with {@link #requestEarlyTransfer}. This will send a
 * vendor request to the device to immediately transfer available events, but they won't be available to the host for a
 * little while, depending on USBIOInterface and driver latency.
 * <p>
 * See the main() method for an example of use.
 * <p>
 * Fires PropertyChangeEvent on the following
 * <ul>
 * <li>NEW_EVENTS_PROPERTY_CHANGE - on new events from driver
 * <li>"readerStarted" - when the reader thread is started
 * </ul>
 * 
 * 
 * @author tobi delbruck/raphael berner
 */
public class CypressFX2 implements AEMonitorInterface, ReaderBufferControl, USBInterface {

	/** Used to store preferences, e.g. buffer sizes and number of buffers. */
	protected static Preferences prefs = Preferences.userNodeForPackage(CypressFX2.class);

	protected static final Logger log = Logger.getLogger("CypressFX2");
	protected AEChip chip;
	// A .bix file format is needed for RAM download.
	// The binary file format .iic (i2c) format are image files for the EEPROM. IIC files will not
	// correctly download to RAM. Therefore they cannot be used to bootstrap a blank device.
	// The bootstrap code is necessary in order to write the Cypress EEPROM.
	// An Intel .hex file should also be OK for RAM download but it does not include the device descriptor TODO could be
	// wrong
	/** filename of FX2 binary executable, generated by uVision project and associated script that runs hex2bix */
	public final static String FIRMWARE_FILENAME_TMPDIFF128_BIX = "/net/sf/jaer/hardwareinterface/usb/cypressfx2/USBAER_FX2LP_Retina.bix"; // "USBAEMonFirware.bin";
	/** filename of FX2 binary executable, generated by uVision project and associated script that runs hex2bix */
	public final static String FIRMWARE_FILENAME_TMPDIFF128_HEX = "/net/sf/jaer/hardwareinterface/usb/cypressfx2/USBAER_FX2LP_Retina.hex"; // "USBAEMonFirware.bin";
	/** filename of FX2 binary executable, generated by uVision project and associated script that runs hex2bix */
	public final static String FIRMWARE_FILENAME_MONITOR_SEQUENCER = "/net/sf/jaer/hardwareinterface/usb/cypressfx2/USBAERmini2.bix";
	/** filename of FX2 binary executable, generated by uVision project and associated script that runs hex2bix */
	public final static String FIRMWARE_FILENAME_MONITOR_SEQUENCER_HEX = "/net/sf/jaer/hardwareinterface/usb/cypressfx2/USBAERmini2.hex";
	/** filename of FX2 binary executable, generated by uVision project and associated script that runs hex2bix */
	public final static String FIRMWARE_FILENAME_MONITOR_SEQUENCER_IIC = "/net/sf/jaer/hardwareinterface/usb/cypressfx2/USBAERmini2.iic";
	public final static String FIRMWARE_FILENAME_MONITOR_SEQUENCER_JTAG_IIC = "/net/sf/jaer/hardwareinterface/usb/cypressfx2/USBAERmini2_JTAG.iic";
	public final static String FIRMWARE_FILENAME_MAPPER_IIC = "/net/sf/jaer/hardwareinterface/usb/cypressfx2/USB2AERmapper.iic";
	public final static String FIRMWARE_FILENAME_STEREO_IIC = "/net/sf/jaer/hardwareinterface/usb/cypressfx2/TMPdiffStereo.iic";// public
	// final
	// static
	// String
	// FIRMWARE_FILENAME_TCVS320_IIC="/net/sf/jaer/hardwareinterface/usb/cypressfx2/USBAERTCVS320.iic";
	public final static String FIRMWARE_FILENAME_TCVS320_HEX = "/net/sf/jaer/hardwareinterface/usb/cypressfx2/USBAERTCVS320.hex";
	public final static String FIRMWARE_FILENAME_TCVS320_BIX = "/net/sf/jaer/hardwareinterface/usb/cypressfx2/USBAERTCVS320.bix";
	public final static String FIRMWARE_FILENAME_DVS128_IIC = "/net/sf/jaer/hardwareinterface/usb/cypressfx2/firmwareFX2_DVS128.iic";
	public final static String FIRMWARE_FILENAME_COCHLEAAMS_BIX = "/net/sf/jaer/hardwareinterface/usb/cypressfx2/firmwareFX2_Cochleaams1b.bix";
	/**
	 * Driver GUID (Globally unique ID, for this USB driver instance. This GUID is how this class of USBIO devices is
	 * enumerated by the factory.
	 */
	public final static String GUID = "{7794C79A-40A7-4A6C-8A29-DA141C20D78C}"; // see guid.txt at root of
	// CypressFX2USB2, generated by tobi for
	// CypressFX2RetinaBiasgen
	/**
	 * A blank Cypress FX2 has VID/PID of 0x04b4/0x8613. This VID/PID pair is used to indicate a blank device that needs
	 * programming.
	 */
	static final public short VID_BLANK = (short) 0x04b4, PID_BLANK = (short) 0x8613;
	/** All the devices here have vendor ID VID which has been allocated to jAER by Thesycon */
	static public final short VID = USBInterface.VID_THESYCON;
	static public final short PID_DVS128_REV0 = (short) 0x8400;
	/** For CochleaAMS devices */
	static public final short PID_COCHLEAAMS = (short) 0x8405;
	static public final short PID_TMPDIFF128_RETINA = (short) 0x8700;
	// static public final short PID_TMPDIFF128_FX2_SMALL_BOARD=(short)0x8701; not used anymore, replace with new
	// VID/PID from thesycon
	static public final short PID_USBAERmini2 = (short) 0x8801;
	static public final short PID_USBAERmini2_without_firmware = (short) 0x8800;
	static public final short PID_USB2AERmapper = (short) 0x8900;
	static public final short DID_STEREOBOARD = (short) 0x2007;
	static public final short PID_TCVS320_RETINA = (short) 0x8702;
	// The yagi lab IVS
	static public final short PID_IVS128 = (short) IVS128HardwareInterface.PID;
	/**
	 * event supplied to listeners when new events are collected. this is final because it is just a marker for the
	 * listeners that new events are available
	 */
	public final PropertyChangeEvent NEW_EVENTS_PROPERTY_CHANGE = new PropertyChangeEvent(this, "NewEvents", null, null);

	/** This support can be used to register this interface for property change events */
	public PropertyChangeSupport support = new PropertyChangeSupport(this); // consts
	final static byte AE_MONITOR_ENDPOINT_ADDRESS = (byte) 0x86; // this is endpoint of AE fifo on Cypress FX2, 0x86
	// means IN endpoint EP6.
	final static byte STATUS_ENDPOINT_ADDRESS = (byte) 0x81; // this is endpoint 1 IN for device to report status
	// changes asynchronously
	final short CPUCS = (short) 0xE600; // address of the CPUCS register, using for resetting 8051 and downloading
	// firmware
	// vendor requests.
	public final static byte VENDOR_REQUEST_START_TRANSFER = (byte) 0xb3; // this is request to start sending events
	// from FIFO endpoint
	public final static byte VENDOR_REQUEST_STOP_TRANSFER = (byte) 0xb4; // this is request to stop sending events from
	// FIFO endpoint
	public final static byte VENDOR_REQUEST_EARLY_TRANFER = (byte) 0xb7; // this is request to transfer whatever you
	// have now
	public static final byte VENDOR_REQUEST_SEND_BIAS_BYTES = (byte) 0xb8; // vendor command to send bias bytes out on
	// SPI interface
	public final byte VENDOR_REQUEST_POWERDOWN = (byte) 0xb9; // vendor command to send bias bytes out on SPI interface
	public final byte VENDOR_REQUEST_FLASH_BIASES = (byte) 0xba; // vendor command to flash the bias values to EEPROM
	public final byte VENDOR_REQUEST_RESET_TIMESTAMPS = (byte) 0xbb; // vendor command to reset timestamps
	public final byte VENDOR_REQUEST_SET_ARRAY_RESET = (byte) 0xbc; // vendor command to set array reset of retina
	public final byte VENDOR_REQUEST_DO_ARRAY_RESET = (byte) 0xbd; // vendor command to do an array reset (toggle
	// arrayReset for a fixed time)
	public final byte VENDOR_REQUEST_SET_SYNC_ENABLED = (byte) 0xbe; // vendor command to set whether sync input
	// generates sync events
	// final byte VENDOR_REQUEST_WRITE_EEPROM=(byte)0xbe; // vendor command to write EEPROM
	public final byte VENDOR_REQUEST_SET_LED = (byte) 0xbf; // vendor command to set the board's LED
	public static final byte VR_DOWNLOAD_FIRMWARE = (byte) 0xC5; // vendor request to program CPLD or FPGA
	public static final byte VR_SET_DEVICE_NAME = (byte) 0xC2; // set serial number string

	public static final byte VENDOR_REQUEST_WRITE_CPLD_SR = (byte) 0xCF; // write CPLD shift register (configuration
	// data); also stops ADC if running
	public static final byte VENDOR_REQUEST_RUN_ADC = (byte) 0xCE; // start and stop aquisition of ADC data
	// final byte VENDOR_REQUEST_READ_EEPROM=(byte)0xca; // vendor command to write EEPROM
	// #define VR_EEPROM 0xa2 // loads (uploads) EEPROM
	public final byte VR_EEPROM = (byte) 0xa2;
	// #define VR_RAM 0xa3 // loads (uploads) external ram
	public final byte VR_RAM = (byte) 0xa3; // this is special hw vendor request for reading and writing RAM, used for
	// firmware download
	public static final byte VENDOR_REQUEST_FIRMWARE = (byte) 0xA0; // download/upload firmware -- builtin FX2 feature
	protected final static short CONFIG_INDEX = 0;
	protected final static short CONFIG_NB_OF_INTERFACES = 1;
	protected final static short CONFIG_INTERFACE = 0;
	protected final static short CONFIG_ALT_SETTING = 0;
	protected final static int CONFIG_TRAN_SIZE = 512;
	// following are to support realtime filtering
	// the AEPacketRaw is used only within this class. Each packet is extracted using the chip extractor object from the
	// first filter in the
	// realTimeFilterChain to a reused EventPacket.
	AEPacketRaw realTimeRawPacket = null; // used to hold raw events that are extracted for real time procesing
	EventPacket<?> realTimePacket = null; // used to hold extracted real time events for processing
	/** start of events that have been captured but not yet processed by the realTimeFilters */
	private int realTimeEventCounterStart = 0;
	/**
	 * timeout in ms to reopen driver (reloading firmware) if no events are received for this time. This timeout will
	 * restart AE transmission if
	 * another process (e.g. Biasgen) reloads the firmware. This timer is checked on every attempt to acquire events.
	 */
	public static long NO_AE_REOPEN_TIMEOUT = 3000;
	/** Time in us of each timestamp count here on host, could be different on board. */
	public final short TICK_US = 1;
	short TICK_US_BOARD = 10; // time in us of timestamp tick on USB board. raphael: should not be final, i need to
	// overwrite it and set it to 1
	/**
	 * default size of AE buffer for user processes. This is the buffer that is written by the hardware capture thread
	 * that holds events
	 * that have not yet been transferred via {@link #acquireAvailableEventsFromDriver} to another thread
	 * 
	 * @see #acquireAvailableEventsFromDriver
	 * @see AEReader
	 * @see #setAEBufferSize
	 */
	public static final int AE_BUFFER_SIZE = 100000; // should handle 5Meps at 30FPS
	/**
	 * this is the size of the AEPacketRaw that are part of AEPacketRawPool that double buffer the translated events
	 * between rendering and capture threads
	 */
	protected int aeBufferSize = CypressFX2.prefs.getInt("CypressFX2.aeBufferSize", CypressFX2.AE_BUFFER_SIZE);
	/** the event reader - a buffer pool thread from USBIO subclassing */
	protected AEReader aeReader = null;
	/** the thread that reads device status messages on EP1 */
	protected AsyncStatusThread asyncStatusThread = null;
	/** The pool of raw AE packets, used for data transfer */
	protected AEPacketRawPool aePacketRawPool = new AEPacketRawPool(this);
	private String stringDescription = "CypressFX2"; // default which is modified by opening

	/**
	 * Populates the device descriptor and the string descriptors and builds the String for toString().
	 * 
	 * @param gUsbIo
	 *            the handle to the UsbIo object.
	 */
	private void populateDescriptors() {
		try {
			int status;

			// getString device descriptor
			if (deviceDescriptor == null) {
				deviceDescriptor = new DeviceDescriptor();
				status = LibUsb.getDeviceDescriptor(device, deviceDescriptor);
				if (status != LibUsb.SUCCESS) {
					throw new HardwareInterfaceException("CypressFX2.openLibUsb(): getDeviceDescriptor: "
						+ LibUsb.errorName(status));
				}
			}

			if (deviceDescriptor.iSerialNumber() != 0) {
				numberOfStringDescriptors = 3; // SN also defined.
			}
			else {
				numberOfStringDescriptors = 2;
			}

			stringDescriptor1 = LibUsb.getStringDescriptor(deviceHandle, (byte) 1);
			if (stringDescriptor1 == null) {
				throw new HardwareInterfaceException("CypressFX2.openLibUsb(): getStringDescriptor1");
			}

			stringDescriptor2 = LibUsb.getStringDescriptor(deviceHandle, (byte) 2);
			if (stringDescriptor2 == null) {
				throw new HardwareInterfaceException("CypressFX2.openLibUsb(): getStringDescriptor2");
			}

			if (numberOfStringDescriptors == 3) {
				stringDescriptor3 = LibUsb.getStringDescriptor(deviceHandle, (byte) 3);
				if (stringDescriptor3 == null) {
					throw new HardwareInterfaceException("CypressFX2.openLibUsb(): getStringDescriptor3");
				}
			}

			// build toString string
			if (numberOfStringDescriptors == 3) {
				stringDescription = (getStringDescriptors()[1] + " " + getStringDescriptors()[2]);
			}
			else if (numberOfStringDescriptors == 2) {
				stringDescription = (getStringDescriptors()[1] + ": Interface " + device);
			}
		}
		catch (final BlankDeviceException bd) {
			stringDescription = "Blank Cypress FX2 : Interface " + device;
		}
		catch (final Exception e) {
			stringDescription = (getClass().getSimpleName() + ": Interface " + device);
		}
	}

	/** The count of events acquired but not yet passed to user via acquireAvailableEventsFromDriver */
	protected int eventCounter = 0; // counts events acquired but not yet passed to user
	/** the last events from {@link #acquireAvailableEventsFromDriver}, This packet is reused. */
	protected AEPacketRaw lastEventsAcquired = new AEPacketRaw();
	protected boolean inEndpointEnabled = false; // raphael: changed from private to protected, because i need to access
	// this member
	/** device open status */
	protected boolean isOpened = false;
	/** the device number, out of all potential compatible devices that could be opened */
	protected Device device = null;
	protected DeviceHandle deviceHandle = null;

	/**
	 * This constructor is protected because these instances should be constructed by the CypressFX2Factory.
	 * Creates a new instance of USBAEMonitor. Note that it is possible to construct several instances
	 * and use each of them to open and read from the same device.
	 * 
	 * @param devNumber
	 *            the desired device number, in range returned by CypressFX2Factory.getNumInterfacesAvailable
	 */
	protected CypressFX2(final Device device) {
		this.device = device;
	}

	/**
	 * acquire a device for exclusive use, other processes can't open the device anymore
	 * used for example for continuous sequencing in matlab
	 */
	public void acquireDevice() throws HardwareInterfaceException {
		CypressFX2.log.log(Level.INFO, "{0} acquiring device for exclusive access", this);

		final int status = LibUsb.claimInterface(deviceHandle, 0);
		if (status != LibUsb.SUCCESS) {
			throw new HardwareInterfaceException("Unable to acquire device for exclusive use: "
				+ LibUsb.errorName(status));
		}
	}

	/** release the device from exclusive use */
	public void releaseDevice() throws HardwareInterfaceException {
		CypressFX2.log.log(Level.INFO, "{0} releasing device", this);

		final int status = LibUsb.releaseInterface(deviceHandle, 0);
		if (status != LibUsb.SUCCESS) {
			throw new HardwareInterfaceException("Unable to release device from exclusive use: "
				+ LibUsb.errorName(status));
		}
	}

	public PropertyChangeSupport getSupport() {
		return support;
	}

	/**
	 * Returns string description of device including the
	 * USB vendor/project IDs. If the device has not been
	 * opened then it is minimally opened to populate the deviceDescriptor and then closed.
	 * 
	 * @return the string description of the device.
	 */
	@Override
	public String toString() {
		if (numberOfStringDescriptors == 0) {
			try {
				openLibUsb_minimal(); // populates stringDescription and sets numberOfStringDescriptors!=0
			}
			catch (final HardwareInterfaceException e) {
			}
		}
		return stringDescription;
	}

	/**
	 * Writes the serial number string to the device EEPROM
	 * 
	 * @param name
	 *            the string. This string has very limited length, e.g. 4 bytes.
	 * @throws net.sf.jaer.hardwareinterface.HardwareInterfaceException
	 */
	public void setSerialNumber(final String name) throws HardwareInterfaceException {
		if (!isOpen()) {
			open();
		}

		final CharsetEncoder encoder = Charset.forName("US-ASCII").newEncoder();
		final ByteBuffer buffer = BufferUtils.allocateByteBuffer(name.length());

		encoder.encode(CharBuffer.wrap(name), buffer, true);
		encoder.flush(buffer);

		sendVendorRequest(CypressFX2.VR_SET_DEVICE_NAME, (short) 0, (short) 0, buffer);

		stringDescriptor3 = LibUsb.getStringDescriptor(deviceHandle, (byte) 3);
		if (stringDescriptor3 == null) {
			CypressFX2.log.warning("Could not get new device name!");
		}
		else {
			CypressFX2.log.info("New Devicename set, close and reopen the device to see the change");
		}
	}

	/** the size in bytes of the EEPROM atttached to the CypressFX2LP */
	public int EEPROM_SIZE = 0x8000;// 32k;
	/**
	 * size of control transfer data packets. Actually vendor request allows for larger data buffer, but windows limits
	 * largest xfer to 4096. Here we limit largest
	 * to size of buffer for control xfers.
	 */
	public final int MAX_CONTROL_XFER_SIZE = 64; // max control xfer size

	/**
	 * Returns a new ProgressMonitor with the AEViewer of this chip as the parent component.
	 * 
	 * @param message
	 *            message at top of monitor
	 * @param start
	 *            start value
	 * @param end
	 *            value
	 * @return the ProgressMonitor
	 */
	protected ProgressMonitor makeProgressMonitor(final String message, final int start, final int end) {
		Component c = null;
		if ((getChip() != null) && (getChip().getAeViewer() != null)) {
			c = getChip().getAeViewer();
		}
		return new ProgressMonitor(c, message, "", start, end);

	}

	/**
	 * This is a BLOCKING write call to write the Cypress EEPROM.
	 * Max number of bytes is defined by {@link #EEPROM_SIZE}.
	 * Thread-safe.
	 * 
	 * @param addr
	 *            the starting address
	 * @param bytes
	 *            the bytes to write
	 */
	synchronized public void writeEEPROM(int addr, final byte[] bytes) throws HardwareInterfaceException {
		CypressFX2.log.info("writing EEPROM to addr=" + addr + " with " + bytes.length + " bytes");

		if (bytes.length > EEPROM_SIZE) {
			throw new RuntimeException(bytes.length + " is too many bytes for EEPROM to hold (" + EEPROM_SIZE + ")");
		}
		if ((addr < 0) || ((addr + bytes.length) > EEPROM_SIZE)) {
			throw new RuntimeException(bytes.length + " is too many bytes for EEPROM to hold (" + EEPROM_SIZE
				+ ") starting at address " + addr);
		}

		final int numChunks = bytes.length / MAX_CONTROL_XFER_SIZE; // this is number of full chunks to send

		ProgressMonitor progressMonitor = makeProgressMonitor("Writing " + numChunks + " " + MAX_CONTROL_XFER_SIZE
			+ " byte chunks FX2 firmware - do not unplug!", 0, numChunks);

		for (int i = 0; i < numChunks; i++) {
			sendVendorRequest(VR_EEPROM, (short) addr, (short) 0, bytes, i * MAX_CONTROL_XFER_SIZE,
				MAX_CONTROL_XFER_SIZE);

			addr += MAX_CONTROL_XFER_SIZE; // change address of EEPROM write location

			// can't cancel
			if (progressMonitor.isCanceled()) {
				progressMonitor = makeProgressMonitor("Writing FX2 firmware - do not unplug!", 0, numChunks);
				progressMonitor.setMillisToDecideToPopup(0);
			}

			progressMonitor.setProgress(i);
			progressMonitor.setNote(String.format("wrote %d of %d chunks of FX2 firmware", i, numChunks));
		}

		// now send final (short) chunk
		final int numBytesLeft = bytes.length % MAX_CONTROL_XFER_SIZE; // remainder
		if (numBytesLeft > 0) {
			// send remaining part of firmware
			sendVendorRequest(VR_EEPROM, (short) addr, (short) 0, bytes, numChunks * MAX_CONTROL_XFER_SIZE,
				numBytesLeft);
		}

		progressMonitor.close();
	}

	/** erases the VID/PID/DID and device identifier strings */
	synchronized protected void eraseEEPROM() throws HardwareInterfaceException {
		CypressFX2.log.info("erasing EEPROM of size " + (EEPROM_SIZE / 1024) + " kB by writing all zeros to it");
		writeEEPROM(0, new byte[EEPROM_SIZE]);
	}

	/**
	 * Read the EEPROM contents.
	 * 
	 * @param addr
	 *            the starting address
	 * @param length
	 *            the number of bytes to read
	 */
	synchronized protected byte[] readEEPROM(final int addr, final int length) throws HardwareInterfaceException {
		if (length > EEPROM_SIZE) {
			throw new RuntimeException(length + " is more bytes than EEPROM can hold (" + EEPROM_SIZE + ")");
		}
		if ((addr < 0) || ((addr + length) > EEPROM_SIZE)) {
			throw new RuntimeException(length + " is too many bytes to read from EEPROM which holds " + EEPROM_SIZE
				+ " bytes, if you start at address " + addr);
		}

		final ByteBuffer dataBuffer = sendVendorRequestIN(VR_EEPROM, (short) addr, (short) 0, length);

		final byte[] uploadBuffer = new byte[length];

		dataBuffer.get(uploadBuffer, 0, length);

		return uploadBuffer;
	}

	/**
	 * writes the Cypress "C0" load to the EEPROM that makes the Cypress FX2 have a Vender, Product, and Device ID on
	 * powerup.
	 * 
	 * @param VID
	 *            vendor ID
	 * @param PID
	 *            product ID
	 * @param DID
	 *            the 'device' ID, can be used to individualize devices. This is not the same as the serial number,
	 *            which by convention is the third string ID.
	 */
	synchronized public void writeVIDPIDDID(final short VID, final short PID, final short DID)
		throws HardwareInterfaceException {
		final byte[] b = new byte[8];
		b[0] = (byte) 0xC0;
		b[1] = (byte) (VID & 0xFF); // vid LSB
		b[2] = (byte) ((VID & 0xFF00) >>> 8); // vid MSB
		b[3] = (byte) (PID & 0xFF);
		b[4] = (byte) ((PID & 0xFF00) >>> 8);
		b[5] = (byte) (DID & 0xFF);
		b[6] = (byte) ((DID & 0xFF00) >>> 8);
		b[7] = (byte) (0); // configuration byte, DISCON=0 (not disconnected after reset), 400kHz=0 (100kHz I2C bus)

		writeEEPROM(0, b);
	}

	// private class WriteC2LoadFromHexFileTask extends SwingWorker{
	//
	// protected Object doInBackground() throws Exception {
	// }
	//
	// }

	/**
	 * writes the Cypress "C2" load to the EEPROM that makes the Cypress have full EEPROM firmware, including VID, PID,
	 * DID.
	 * On reset the Cypress will load its RAM from the EEPROM.
	 * 
	 * @param firmwareFilename
	 *            a File containing the binary format .iic file
	 *            firmware as output from hex2bix. This is a flat firmware format that starts at address 0.
	 *            It does not include the VID/PID written for the C2 load.
	 * @param VID
	 *            vendor ID
	 * @param PID
	 *            product ID
	 * @param DID
	 *            the 'device' ID, can be used to individualize devices
	 */
	public void writeC2Load(final String firmwareFilename, final short VID, final short PID, final short DID)
		throws HardwareInterfaceException {
		byte[] fw = null;

		try {
			fw = loadBinaryFirmwareFile(firmwareFilename);
		}
		catch (final IOException e) {
			throw new HardwareInterfaceException(e.getMessage());
		}

		final byte[] b = new byte[12];
		b[0] = (byte) 0xC2;
		b[1] = (byte) (VID & 0xFF); // vid LSB
		b[2] = (byte) ((VID & 0xFF00) >>> 8); // vid MSB
		b[3] = (byte) (PID & 0xFF);
		b[4] = (byte) ((PID & 0xFF00) >>> 8);
		b[5] = (byte) (DID & 0xFF);
		b[6] = (byte) ((DID & 0xFF00) >>> 8);
		b[7] = (byte) (0); // configuration byte, DISCON=0 (not disconnected after reset), 400kHz=0 (100kHz I2C bus)

		b[8] = (byte) ((fw.length & 0xFF00) >>> 8);
		b[9] = (byte) ((fw.length & 0xFF)); // length of firmware in these bytes
		b[10] = 0;
		b[11] = 0;

		final byte[] end = new byte[5];
		end[0] = (byte) 0x80;
		end[1] = (byte) 0x01;
		end[2] = (byte) 0xe6;
		end[4] = 0;

		final byte[] w = new byte[b.length + fw.length + end.length];
		System.arraycopy(b, 0, w, 0, b.length);
		System.arraycopy(fw, 0, w, b.length, fw.length);
		System.arraycopy(end, 0, w, b.length + fw.length, end.length);

		writeEEPROM(0, w);
	}

	/**
	 * writes the Cypress "C2" load to the EEPROM that makes the Cypress have EEPROM firmware, including VID, PID, DID.
	 * 
	 * @param VID
	 * @param PID
	 * @param DID
	 *            the 'device' ID, can be used to individualize devices
	 * @param hexFileResourcePath
	 *            a full path pointing to a resource containing the firmware as output from compiler in Intel hex
	 *            format. This resource is a file that is somewhere in the classpath, i.e. it is a file
	 *            that is included in the project jar. For example:
	 *            "/net/sf/jaer/hardwareinterface/usb/cypressfx2/USBAER_FX2LP_Retina.hex"
	 * @see #FIRMWARE_FILENAME_TMPDIFF128_HEX
	 * @see #FIRMWARE_FILENAME_MONITOR_SEQUENCER_HEX
	 */
	synchronized public void writeHexFileToEEPROM(final String hexFileResourcePath, final short VID, final short PID,
		final short DID) throws HardwareInterfaceException {

		CypressFX2.log.info("writing retina EEPROM firmware file " + hexFileResourcePath + " with VID="
			+ HexString.toString(VID) + " PID=" + HexString.toString(PID) + " DID=" + HexString.toString(DID));
		HexFileParser parser;
		try {
			parser = new HexFileParser(hexFileResourcePath);
		}
		catch (final IOException e2) {
			throw new HardwareInterfaceException(e2.getMessage() + ": cannot open resource " + hexFileResourcePath);
		}
		final ArrayList<HexFileParser.Record> records = parser.getRecords();
		int index = 0;
		byte[] b;

		CypressFX2.log.info("writing " + records.size() + " records");

		// JFrame frame=new JFrame("EEPROM progress");
		// JProgressBar progressBar;
		// progressBar = new JProgressBar(0, records.size());
		// progressBar.setName("EEPROM programming");
		// progressBar.setValue(0);
		// progressBar.setStringPainted(true);
		// frame.getContentPane().add(progressBar);
		// frame.pack();
		// frame.setDefaultCloseOperation(JFrame.HIDE_ON_CLOSE);
		// frame.setVisible(true);

		b = new byte[12];
		b[0] = (byte) 0xC2; // write C2 load format header
		b[1] = (byte) (VID & 0xFF); // vid LSB
		b[2] = (byte) ((VID & 0xFF00) >>> 8); // vid MSB
		b[3] = (byte) (PID & 0xFF);
		b[4] = (byte) ((PID & 0xFF00) >>> 8);
		b[5] = (byte) (DID & 0xFF);
		b[6] = (byte) ((DID & 0xFF00) >>> 8);
		b[7] = (byte) (0); // configuration byte, DISCON=0 (not disconnected after reset), 400kHz=0 (100kHz I2C bus)

		writeEEPROM(0, b); // write VID/PID etc header starting at addr 0

		index += b.length;
		// now for each hex file record, we must write this record, contiguous with the last one, and each record
		// written to
		// flash must contain the starting address of how many bytes there are (up to 1023) and where the memory should
		// go in the FX2 RAM.
		// now write hex file records, one by one
		for (final HexFileParser.Record r : records) {
			b = new byte[4];
			b[0] = (byte) ((r.data.length & 0xFF00) >>> 8);
			b[1] = (byte) ((r.data.length & 0xFF));
			b[2] = (byte) ((r.address & 0xFF00) >>> 8);
			b[3] = (byte) ((r.address & 0xFF));
			writeEEPROM(index, b);
			index += b.length;
			writeEEPROM(index, r.data);
			index += r.data.length;
			// progressBar.setValue(recNum++);
		}

		// now write footer

		b = new byte[5];
		b[0] = (byte) 0x80;
		b[1] = (byte) 0x01;
		b[2] = (byte) 0xe6;
		b[3] = (byte) 0;
		b[4] = 0;

		writeEEPROM(index, b);
		index += b.length;
		CypressFX2.log.info("done writing " + records.size() + " records to EEPROM");
		// frame.dispose();

	}

	/**
	 * downloads firmware to the FX2 RAM from a hex file.
	 * 
	 * @param hexFileResourcePath
	 *            a full path pointing to a resource containing the firmware as output from compiler in Intel hex
	 *            format. This resource is a file that is somewhere in the classpath, i.e. it is a file
	 *            that is included in the project jar. For example:
	 *            "/net/sf/jaer/hardwareinterface/usb/cypressfx2/USBAER_FX2LP_Retina.hex"
	 * @see #FIRMWARE_FILENAME_TMPDIFF128_HEX
	 * @see #FIRMWARE_FILENAME_MONITOR_SEQUENCER_HEX
	 */
	synchronized public void downloadFirmwareHex(final String hexFileResourcePath) throws HardwareInterfaceException {

		CypressFX2.log.info("downloading to RAM firmware file " + hexFileResourcePath);

		// b = new byte[12];
		// b[0] = (byte) 0xC2; // write C2 load format header
		// b[1] = (byte) (VID & 0xFF); // vid LSB
		// b[2] = (byte) ((VID & 0xFF00) >>> 8); // vid MSB
		// b[3] = (byte) (PID & 0xFF);
		// b[4] = (byte) ((PID & 0xFF00) >>> 8);
		// b[5] = (byte) (DID & 0xFF);
		// b[6] = (byte) ((DID & 0xFF00) >>> 8);
		// b[7] = (byte) (0); // configuration byte, DISCON=0 (not disconnected after reset), 400kHz=0 (100kHz I2C bus)

		HexFileParser parser;
		try {
			parser = new HexFileParser(hexFileResourcePath);
		}
		catch (final FileNotFoundException e) {
			throw new HardwareInterfaceException(e.getMessage() + ": cannot open resource " + hexFileResourcePath);
		}
		catch (final IOException e2) {
			throw new HardwareInterfaceException(e2.getMessage() + ": cannot open resource " + hexFileResourcePath);

		}
		final ArrayList<HexFileParser.Record> records = parser.getRecords();

		CypressFX2.log.info("Hex file has " + records.size() + " records");
		set8051Reset(true);

		// now for each hex file record, we must write this record, contiguous with the last one, and each record
		// written to
		// flash must contain the starting address of how many bytes there are (up to 1023) and where the memory should
		// go.
		// now write hex file records, one by one
		for (final HexFileParser.Record r : records) {
			download8051RAM(r.address, r.data);
		}

		CypressFX2.log.info("done writing hex file to RAM");

		set8051Reset(false);
	}

	/**
	 * adds a listener for new events captured from the device.
	 * Actually gets called whenever someone looks for new events and there are some using
	 * acquireAvailableEventsFromDriver, not when data is actually captured by AEReader.
	 * Thus it will be limited to the users sampling rate, e.g. the game loop rendering rate.
	 * 
	 * @param listener
	 *            the listener. It is called with a PropertyChangeEvent when new events
	 *            are received by a call to {@link #acquireAvailableEventsFromDriver}.
	 *            These events may be accessed by calling {@link #getEvents}.
	 */
	@Override
	public void addAEListener(final AEListener listener) {
		support.addPropertyChangeListener(listener);
	}

	@Override
	public void removeAEListener(final AEListener listener) {
		support.removePropertyChangeListener(listener);
	}

	/**
	 * starts reader buffer pool thread and enables in endpoints for AEs. Subclasses *MUST* override this method to
	 * start their own customized reader
	 * with their own translateEvents method.
	 */
	public void startAEReader() throws HardwareInterfaceException {
		throw new HardwareInterfaceException(
			"This method should not be called - the CypressFX2 subclass should override startAEReader. Probably this is a blank device that requires programming.");
	}

	long lastTimeEventCaptured = System.currentTimeMillis(); // used for timer to restart IN transfers, in case another

	// connection, e.g. biasgen, has disabled them

	/**
	 * Gets available events from driver. {@link HardwareInterfaceException} is thrown if there is an error.
	 * {@link #overrunOccurred} will be reset after this call.
	 * <p>
	 * This method also starts event acquisition if it is not running already.
	 * 
	 * Not thread safe but does use the thread-safe swap() method of AEPacketRawPool to swap data with the acquisition
	 * thread.
	 * 
	 * @return number of events acquired. If this is zero there is no point in getting the events, because there are
	 *         none.
	 * @throws HardwareInterfaceException
	 * @see #setEventAcquisitionEnabled
	 * 
	 *      .
	 */
	@Override
	public AEPacketRaw acquireAvailableEventsFromDriver() throws HardwareInterfaceException {
		if (!isOpened) {
			open();
		}

		// make sure event acquisition is running
		if (!inEndpointEnabled) {
			setEventAcquisitionEnabled(true);
		}

		// HardwareInterfaceException.clearException();

		// make sure that event translation from driver is allowed to run if need be, to avoid holding up event sender
		// Thread.currentThread().yield();

		// short[] addresses;
		// int[] timestamps;
		int nEvents;

		// getString the 'active' buffer for events (the one that has just been written by the hardware thread)
		// synchronized(aePacketRawPool){ // synchronize on aeReader so that we don't try to access the events at the
		// same time
		aePacketRawPool.swap();
		lastEventsAcquired = aePacketRawPool.readBuffer();
		// log.info(this+" acquired "+lastEventsAcquired);
		// addresses=events.getAddresses();
		// timestamps=events.getTimestamps();
		nEvents = lastEventsAcquired.getNumEvents();
		eventCounter = 0;
		realTimeEventCounterStart = 0;

		computeEstimatedEventRate(lastEventsAcquired);
		if (nEvents != 0) {
			support.firePropertyChange(NEW_EVENTS_PROPERTY_CHANGE); // call listeners
			// }
		}
		return lastEventsAcquired;

		// events=new AEPacketRaw(nEvents);
		// // reuse same packet to avoid constant new'ing
		// events.allocate(nEvents);
		// if(nEvents==0){
		// // log.warning("got zero events from "+this);
		// computeEstimatedEventRate(null);
		// events.clear();
		// return events;
		// }else{
		// System.arraycopy(addresses, 0, events.getAddresses(), 0, nEvents);
		// System.arraycopy(timestamps, 0, events.getTimestamps(), 0, nEvents);
		// events.setNumEvents(nEvents);
		// computeEstimatedEventRate(events);
		// support.firePropertyChaNEW_EVENTS_PROPERTY_CHANGEY_CHANGE); // call listeners
		// return events;
		// }
	}

	/**
	 * the max capacity of this USB2 bus interface is 24MB/sec/4 bytes/event
	 */
	@Override
	public int getMaxCapacity() {
		return 6000000;
	}

	private int estimatedEventRate = 0;

	/**
	 * @return event rate in events/sec as computed from last acquisition.
	 * 
	 */
	@Override
	public int getEstimatedEventRate() {
		return estimatedEventRate;
	}

	/** computes the estimated event rate for a packet of events */
	void computeEstimatedEventRate(final AEPacketRaw events) {
		if ((events == null) || (events.getNumEvents() < 2)) {
			estimatedEventRate = 0;
		}
		else {
			final int[] ts = events.getTimestamps();
			final int n = events.getNumEvents();
			final int dt = ts[n - 1] - ts[0];
			estimatedEventRate = (int) ((1e6f * n) / dt);
		}
	}

	/**
	 * Returns the number of events acquired by the last call to {@link #acquireAvailableEventsFromDriver }
	 * 
	 * @return number of events acquired
	 */
	@Override
	public int getNumEventsAcquired() {
		return aePacketRawPool.readBuffer().getNumEvents();
	}

	/**
	 * Reset the timestamps to zero. This has two effects. First it sends a vendor request down the control endpoint
	 * to tell the device to reset its own internal timestamp counters. Second, it tells the AEReader object to reset
	 * its
	 * timestamps, meaning to reset its unwrap counter.
	 */
	@Override
	synchronized public void resetTimestamps() {
		CypressFX2.log.info(this + ".resetTimestamps(): zeroing timestamps");
		dontwrap = true; // this is a flag that is reset in translateEvents method

		// send vendor request for device to reset timestamps
		if (deviceHandle == null) {
			throw new RuntimeException("device must be opened before sending this vendor request");
		}

		try {
			sendVendorRequest(VENDOR_REQUEST_RESET_TIMESTAMPS, (short) 0, (short) 0);
		}
		catch (final HardwareInterfaceException e) {
			CypressFX2.log.warning("CypressFX2.resetTimestamps: couldn't send vendor request to reset timestamps");
		}

		if (getAeReader() != null) {
			getAeReader().resetTimestamps(); // reset wrap counter and flush buffers
		}
		else {
			CypressFX2.log.warning("CypressFX2.resetTimestamps(): reader not yet started, can't reset timestamps");
		}
	}

	/**
	 * Reset the entire pixel array. Some interfaces may not support this functionality; they may not implement this
	 * vendor request.
	 * No exceptions are thrown but a warning mesasge is printed.
	 */
	public void resetPixelArray() {
		// send vendor request for device to reset array
		if (deviceHandle == null) {
			throw new RuntimeException("device must be opened before sending this vendor request");
		}

		try {
			sendVendorRequest(VENDOR_REQUEST_DO_ARRAY_RESET, (short) 0, (short) 0);
		}
		catch (final HardwareInterfaceException e) {
			CypressFX2.log.warning("CypressFX2.resetPixelArray: couldn't send vendor request to reset array");
		}
	}

	protected boolean arrayResetEnabled = false;

	/**
	 * set the board LED state. Useful for debugging. Not available for CypressFX2MonitorSequencer
	 * 
	 * @param value
	 *            true to turn it on, false to turn it off.
	 */
	synchronized public void setLed(final boolean value) {
		// send vendor request for device to reset array
		if (deviceHandle == null) {
			throw new RuntimeException("device must be opened before sending this vendor request");
		}

		try {
			sendVendorRequest(VENDOR_REQUEST_SET_LED, (short) ((value) ? (0) : (1)), (short) 0);
		}
		catch (final HardwareInterfaceException e) {
			CypressFX2.log.warning("CypressFX2.setLed: couldn't send vendor request to set LED");
		}
	}

	/**
	 * Is true if an overrun occured in the driver (><code> AE_BUFFER_SIZE</code> events) during the period before the
	 * last time {@link #acquireAvailableEventsFromDriver } was called. This flag is cleared by
	 * {@link #acquireAvailableEventsFromDriver}, so you need to
	 * check it before you acquire the events.
	 * <p>
	 * If there is an overrun, the events grabbed are the most ancient; events after the overrun are discarded. The
	 * timestamps continue on but will probably be lagged behind what they should be.
	 * 
	 * @return true if there was an overrun.
	 */
	@Override
	public boolean overrunOccurred() {
		return aePacketRawPool.readBuffer().overrunOccuredFlag;
	}

	/**
	 * Closes the device. Never throws an exception.
	 */
	@Override
	public void close() {
		if (!isOpen()) {
			return;
		}

		try {
			setEventAcquisitionEnabled(false);

			if (asyncStatusThread != null) {
				asyncStatusThread.stopThread();
			}
		}
		catch (final HardwareInterfaceException e) {
			e.printStackTrace();
		}

		LibUsb.releaseInterface(deviceHandle, 0);
		LibUsb.close(deviceHandle);

		deviceHandle = null;

		LibUsb.freeDeviceDescriptor(deviceDescriptor);

		deviceDescriptor = null;

		inEndpointEnabled = false;
		isOpened = false;
	}

	// not really necessary to stop this thread, i believe, because close will unbind already according to usbio docs

	public void stopAEReader() {
		final AEReader reader = getAeReader();

		if (reader != null) {
			reader.stopThread();

			setAeReader(null);
		}
		else {
			CypressFX2.log.warning("null reader, nothing to stop");
		}
	}

	/**
	 * sends vendor request to trigger an immediate commit of whatever is in the endpoint fifo immediately.
	 * next call to <@link #acquireAvailableEventsFromDriver} will getString these events if you wait a bit.
	 */
	synchronized public void requestEarlyTransfer() throws HardwareInterfaceException {
		// start getting events by sending vendor request 0xb3 to control endpoint 0
		// documented in firmware FX2_to_extFIFO.c
		final ByteBuffer dataBuffer = BufferUtils.allocateByteBuffer(1);

		dataBuffer.put(0, (byte) 1);

		sendVendorRequest(CypressFX2.VENDOR_REQUEST_EARLY_TRANFER, (short) 0, (short) 0, dataBuffer);
	}

	/**
	 * @return true if inEndpoint was enabled.
	 *         However, some other connection (e.g. biasgen) could have disabled the in transfers.
	 */
	public boolean isInEndpointEnabled() {
		return inEndpointEnabled;
	}

	/**
	 * sends a vendor request to enable or disable in transfers of AEs
	 * 
	 * @param inEndpointEnabled
	 *            true to send vendor request to enable, false to send request to disable
	 */
	public void setInEndpointEnabled(final boolean inEndpointEnabled) throws HardwareInterfaceException {
		CypressFX2.log.info("Setting IN endpoint enabled=" + inEndpointEnabled);
		if (inEndpointEnabled) {
			enableINEndpoint();
		}
		else {
			disableINEndpoint();
		}
	}

	protected synchronized void enableINEndpoint() throws HardwareInterfaceException {
		// start getting events by sending vendor request 0xb3 to control endpoint 0
		// documented in firmware FX2_to_extFIFO.c
		// System.out.println("USBAEMonitor.enableINEndpoint()");
		// make vendor request structure and populate it
		if (deviceHandle == null) {
			CypressFX2.log.warning("CypressFX2.enableINEndpoint(): null USBIO device");
			return;
		}

		sendVendorRequest(CypressFX2.VENDOR_REQUEST_START_TRANSFER, (short) 0, (short) 0);

		inEndpointEnabled = true;
	}

	/**
	 * // stop endpoint sending events by sending vendor request 0xb4 to control endpoint 0
	 * // these requests are documented in firmware file FX2_to_extFIFO.c
	 */
	protected synchronized void disableINEndpoint() {
		try {
			sendVendorRequest(CypressFX2.VENDOR_REQUEST_STOP_TRANSFER, (short) 0, (short) 0);
		}
		catch (final HardwareInterfaceException e) {
			CypressFX2.log
			.info("disableINEndpoint: couldn't send vendor request to disable IN transfers--it could be that device is gone or sendor is OFF and and completing GPIF cycle");
		}

		inEndpointEnabled = false;
	}

	@Override
	public PropertyChangeSupport getReaderSupport() {
		return support;
	}

	private class AsyncStatusThread {
		USBTransferThread usbTransfer;
		CypressFX2 monitor;

		AsyncStatusThread(final CypressFX2 monitor) {
			this.monitor = monitor;
		}

		public void startThread() {
			if (!isOpen()) {
				try {
					open();
				}
				catch (final HardwareInterfaceException e) {
					// TODO Auto-generated catch block
					e.printStackTrace();
				}
			}

			usbTransfer = new USBTransferThread(monitor.deviceHandle, CypressFX2.STATUS_ENDPOINT_ADDRESS,
				LibUsb.TRANSFER_TYPE_BULK, new ProcessStatusMessages(), 2, 128);
			usbTransfer.setName("AsyncStatusThread");
			usbTransfer.start();
		}

		public void stopThread() {
			usbTransfer.interrupt();

			try {
				usbTransfer.join();
			}
			catch (final InterruptedException e) {
				CypressFX2.log.severe("Failed to join AsyncStatusThread");
			}
		}

		private class ProcessStatusMessages implements RestrictedTransferCallback {
			@Override
			public void prepareTransfer(final RestrictedTransfer transfer) {
				// Nothing to do here.
			}

			@Override
			public void processTransfer(final RestrictedTransfer transfer) {
				if (transfer.status() != LibUsb.TRANSFER_COMPLETED) {
					if (transfer.status() != LibUsb.TRANSFER_CANCELLED) {
						CypressFX2.log.warning("Error waiting for completion of read on status pipe: "
							+ LibUsb.errorName(transfer.status()));
					}

					return;
				}

				if (transfer.actualLength() > 0) {
					final byte msg = transfer.buffer().get(0);

					if (msg == 1) {
						final AEReader reader = getAeReader();

						if (reader != null) {
							CypressFX2.log.info("********** CypressFX2.AsyncStatusThread: timestamps externally reset");
							reader.resetTimestamps();
						}
						else {
							CypressFX2.log
							.info("Received timestamp external reset message, but monitor is not running");
						}
					}
				}
			}
		}
	}

	volatile boolean dontwrap = false; // used for resetTimestamps

	private int aeReaderFifoSize = CypressFX2.prefs.getInt("CypressFX2.AEReader.fifoSize", 8192);

	/**
	 * sets the buffer size for the aereader thread. optimal size depends on event rate, for high event
	 * rates, at least 8k or 16k bytes should be chosen, and low event rates need smaller
	 * buffer size to produce suitable frame rates
	 */
	public void setAEReaderFifoSize(final int size) {
		aeReaderFifoSize = size;
		CypressFX2.prefs.putInt("CypressFX2.AEReader.fifoSize", size);
	}

	private int aeReaderNumBuffers = CypressFX2.prefs.getInt("CypressFX2.AEReader.numBuffers", 4);

	/** sets the number of buffers for the aereader thread. */
	public void setAEReaderNumBuffers(final int number) {
		aeReaderNumBuffers = number;
		CypressFX2.prefs.putInt("CypressFX2.AEReader.numBuffers", number);
	}

	/**
	 * AE reader class. the thread continually reads events into buffers. when a buffer is read, ProcessData transfers
	 * and transforms the buffer data to AE address
	 * and timestamps information and puts it in the addresses and timestamps arrays. a call to
	 * acquireAvailableEventsFromDriver copies the events to enw user
	 * arrays that can be accessed by getEvents() (this packet is also returned by
	 * {@link #acquireAvailableEventsFromDriver}). The relevant methods are synchronized so are thread safe.
	 */
	public class AEReader implements ReaderBufferControl {
		public final int MAX_NONMONOTONIC_TIME_EXCEPTIONS_TO_PRINT = 10;
		private int resetTimestampWarningCount = 0;
		int cycleCounter = 0;
		volatile boolean timestampsReset = false; // used to tell processData that another thread has reset timestamps
		final int BAD_WRAP_PRINT_INTERVAL = 100; // only print a warning every this many to avoid slowing down

		/**
		 * the priority for this monitor acquisition thread. This should be set high (e.g. Thread.MAX_PRIORITY) so that
		 * the thread can
		 * start new buffer reads in a timely manner so that the sender does not getString blocked
		 * */
		public static final int MONITOR_PRIORITY = Thread.MAX_PRIORITY; // Thread.NORM_PRIORITY+2

		/**
		 * the number of capture buffers for the buffer pool for the translated address-events.
		 * These buffers allow for smoother access to buffer space by the event capture thread
		 */
		private int numBuffers;
		/**
		 * size of FIFOs in bytes used in AEReader for event capture from device.
		 * This does not have to be the same size as the FIFOs in the CypressFX2 (512 bytes). If it is too small, then
		 * there
		 * are frequent thread context switches that can greatly slow down rendering loops.
		 */
		private int fifoSize;

		private final int RESET_TIMESTAMPS_INITIAL_PRINTING_LIMIT = 10;
		private final int RESET_TIMESTAMPS_WARNING_INTERVAL = 100000;

		USBTransferThread usbTransfer;
		CypressFX2 monitor;

		public AEReader(final CypressFX2 m) throws HardwareInterfaceException {
			monitor = m;
			fifoSize = monitor.aeReaderFifoSize;
			numBuffers = monitor.aeReaderNumBuffers;
		}

		public void startThread() {
			if (!isOpen()) {
				try {
					open();
				}
				catch (final HardwareInterfaceException e) {
					// TODO Auto-generated catch block
					e.printStackTrace();
				}
			}

			usbTransfer = new USBTransferThread(monitor.deviceHandle, (byte) 0x86, LibUsb.TRANSFER_TYPE_BULK,
				new ProcessAEData(), getNumBuffers(), getFifoSize());
			usbTransfer.setPriority(AEReader.MONITOR_PRIORITY);
			usbTransfer.setName("AEReaderThread");
			usbTransfer.start();

			getSupport().firePropertyChange("readerStarted", false, true);
		}

		public void stopThread() {
			usbTransfer.interrupt();

			try {
				usbTransfer.join();
			}
			catch (final InterruptedException e) {
				CypressFX2.log.severe("Failed to join AEReaderThread");
			}
		}

		@Override
		public String toString() {
			return "AEReader for " + CypressFX2.this;
		}

		/**
		 * Subclasses must override this method to process the raw data to write to the raw event packet buffers.
		 * 
		 * @param buf
		 *            the raw byte buffers
		 */
		protected void translateEvents(final ByteBuffer buffer) {
			CypressFX2.log.severe("Error: This method should never be called, it must be overridden!");
		}

		/**
		 * Resets the timestamp unwrap value, resets the USBIO pipe, and resets the AEPacketRawPool.
		 */
		synchronized public void resetTimestamps() {
			if ((resetTimestampWarningCount < RESET_TIMESTAMPS_INITIAL_PRINTING_LIMIT)
				|| ((resetTimestampWarningCount % RESET_TIMESTAMPS_WARNING_INTERVAL) == 0)) {
				CypressFX2.log.info(CypressFX2.this + ": wrapAdd=" + wrapAdd + ", zeroing it");
			}
			if (resetTimestampWarningCount == RESET_TIMESTAMPS_INITIAL_PRINTING_LIMIT) {
				CypressFX2.log
				.warning("will only print reset timestamps message every "
					+ RESET_TIMESTAMPS_WARNING_INTERVAL
					+ " times now\nCould it be that you are trying to inject sync events using the DVS128 IN pin?\nIf so, select the  \"Enable sync events output\"  option in the DVS128 menu");
			}
			resetTimestampWarningCount++;

			wrapAdd = WRAP_START;
			timestampsReset = true; // will inform reader thread that timestamps are reset
		}

		class ProcessAEData implements RestrictedTransferCallback {
			@Override
			public void prepareTransfer(final RestrictedTransfer transfer) {
				// Nothing to do here.
			}

			/**
			 * Called on completion of read on a data buffer is received from USBIO driver.
			 * 
			 * @param Buf
			 *            the data buffer with raw data
			 */
			@Override
			public void processTransfer(final RestrictedTransfer transfer) {
				cycleCounter++;

				synchronized (aePacketRawPool) {
					if ((transfer.status() == LibUsb.TRANSFER_COMPLETED)
						|| (transfer.status() == LibUsb.TRANSFER_CANCELLED)) {
						translateEvents(transfer.buffer());

						if ((chip != null) && (chip.getFilterChain() != null)
							&& (chip.getFilterChain().getProcessingMode() == FilterChain.ProcessingMode.ACQUISITION)) {
							// here we do the realTimeFiltering. We finished capturing this buffer's worth of events,
							// now process them apply realtime filters and realtime (packet level) mapping

							// synchronize here so that rendering thread doesn't swap the buffer out from under us while
							// we process these events aePacketRawPool.writeBuffer is also synchronized so we getString
							// the same lock twice which is ok
							final AEPacketRaw buffer = aePacketRawPool.writeBuffer();
							final int[] addresses = buffer.getAddresses();
							final int[] timestamps = buffer.getTimestamps();
							realTimeFilter(addresses, timestamps);
						}
					}
					else {
						CypressFX2.log.warning("ProcessAEData: Bytes transferred: " + transfer.actualLength()
							+ "  Status: " + LibUsb.errorName(transfer.status()));

						monitor.close(); // watch out, this can call synchronized method
					}

					if (timestampsReset) {
						// don't flush, just let the old data through since it is still data
						timestampsReset = false;
					}
				}
			}
		}

		// sync so that we don't try to copy events while buffer is being translated
		final int WRAP_START = 0;
		/** wrapAdd is the time to add to short timestamp to unwrap it */
		protected int wrapAdd = WRAP_START; // 0;
		protected int lastWrapAdd = 0;
		/** used to indicate a 32 bit timestamp wrap */
		protected boolean wrappedBig = false;
		// indicates that wrapAdd has just wrapped itself, so that we should allow overridden to change priority

		/** size of CypressFX2 USB fifo's in bytes. */
		public static final int CYPRESS_FIFO_SIZE = 512;
		/** the default number of USB read buffers used in the reader */
		public static final int CYPRESS_NUM_BUFFERS = 2;

		@Override
		public int getFifoSize() {
			return fifoSize;
		}

		@Override
		public void setFifoSize(int fifoSize) {
			if (fifoSize < AEReader.CYPRESS_FIFO_SIZE) {
				CypressFX2.log
				.warning("CypressFX2 fifo size clipped to device FIFO size " + AEReader.CYPRESS_FIFO_SIZE);
				fifoSize = AEReader.CYPRESS_FIFO_SIZE;
			}

			this.fifoSize = fifoSize;

			usbTransfer.setBufferSize(fifoSize);

			CypressFX2.prefs.putInt("CypressFX2.AEReader.fifoSize", fifoSize);
		}

		@Override
		public int getNumBuffers() {
			return numBuffers;
		}

		@Override
		public void setNumBuffers(final int numBuffers) {
			this.numBuffers = numBuffers;

			usbTransfer.setBufferNumber(numBuffers);

			CypressFX2.prefs.putInt("CypressFX2.AEReader.numBuffers", numBuffers);
		}

		/**
		 * Applies the filterChain processing on the most recently captured data. The processing is done
		 * by extracting the events just captured and then applying the filter chain.
		 * <strong>The filter outputs are discarded and
		 * will not be visble in the rendering of the chip output, but may be used for motor control or other purposes.
		 * </strong>
		 * <p>
		 * TODO: at present this processing is redundant in that the most recently captured events are copied to a
		 * different AEPacketRaw, extracted to an EventPacket, and then processed. This effort is duplicated later in
		 * rendering. This should be fixed somehow.
		 * 
		 * @param addresses
		 *            the raw input addresses; these are filtered in place
		 * @param timestamps
		 *            the input timestamps
		 */
		private void realTimeFilter(final int[] addresses, final int[] timestamps) {

			if (!chip.getFilterChain().isAnyFilterEnabled()) {
				return;
			}
			final int nevents = getNumRealTimeEvents();

			// initialize packets
			if (realTimeRawPacket == null) {
				realTimeRawPacket = new AEPacketRaw(nevents); // TODO: expensive
			}
			else {
				realTimeRawPacket.ensureCapacity(nevents);// // copy data to real time raw packet
				// if(addresses==null || timestamps==null){
				// log.warning("realTimeFilter: addresses or timestamp array became null");
				// }else{
			}
			try {
				System.arraycopy(addresses, realTimeEventCounterStart, realTimeRawPacket.getAddresses(), 0, nevents);
				System.arraycopy(timestamps, realTimeEventCounterStart, realTimeRawPacket.getTimestamps(), 0, nevents);
			}
			catch (final IndexOutOfBoundsException e) {
				e.printStackTrace();
			}
			realTimeEventCounterStart = eventCounter;
			// System.out.println("RealTimeEventCounterStart: " + realTimeEventCounterStart + " nevents " + nevents +
			// " eventCounter " + eventCounter);
			realTimeRawPacket.setNumEvents(nevents);
			// init extracted packet
			// if(realTimePacket==null)
			// realTimePacket=new EventPacket(chip.getEventClass());
			// extract events for this filter. This duplicates later effort during rendering and should be fixed for
			// later.
			// at present this may mess up everything else because the output packet is reused.

			// hack for stereo hardware interfaces - for real time processing we must label the eye bit here based on
			// which eye our hardware
			// interface is. note the events are labeled here and the real time processing method is called for each low
			// level hardware interface.
			// But each call will only getString events from one eye. it is important that the filterPacket method be
			// sychronized (thread safe) because the
			// filter object may getString called by both AEReader threads at the "same time"
			if (chip.getHardwareInterface() instanceof StereoPairHardwareInterface) {
				final StereoPairHardwareInterface stereoInterface = (StereoPairHardwareInterface) chip
					.getHardwareInterface();
				if (stereoInterface.getAemonLeft() == CypressFX2.this) {
					stereoInterface.labelLeftEye(realTimeRawPacket);
				}
				else {
					stereoInterface.labelRightEye(realTimeRawPacket);
				}
			}
			// regardless, we now extract to typed events for example and process
			realTimePacket = chip.getEventExtractor().extractPacket(realTimeRawPacket); // ,realTimePacket);
			realTimePacket.setRawPacket(realTimeRawPacket);

			try {
				getChip().getFilterChain().filterPacket(realTimePacket);
			}
			catch (final Exception e) {
				CypressFX2.log.warning(e.toString() + ": disabling all filters");
				e.printStackTrace();
				for (final EventFilter f : getChip().getFilterChain()) {
					f.setFilterEnabled(false);
				}
			}
			// we don't do following because the results are an AEPacketRaw that still needs to be written to
			// addresses/timestamps
			// and this is not done yet. at present results of realtime filtering are just not rendered at all.
			// that means that user will see raw events, e.g. if BackgroundActivityFilter is used, then user will still
			// see all
			// events because the filters are not applied for normal rendering. (If they were applied, then the filters
			// would
			// be in a funny state becaues they would process the same data more than once and out of order, resulting
			// in all kinds
			// of problems.)
			// However, the graphical annotations (like the boxes drawn around clusters in RectangularClusterTracker)
			// done by the real time processing are still shown when the rendering thread calls the
			// annotate methods.

			// chip.getEventExtractor().reconstructRawPacket(realTimePacket);
		}

		@Override
		public PropertyChangeSupport getReaderSupport() {
			return support;
		}
	}

	private int getNumRealTimeEvents() {
		return eventCounter - realTimeEventCounterStart;
	}

	/** Allocates internal memory for transferring data from reader to consumer, e.g. rendering. */
	protected void allocateAEBuffers() {
		synchronized (aePacketRawPool) {
			aePacketRawPool.allocateMemory();
		}
	}

	/** @return the size of the double buffer raw packet for AEs */
	@Override
	public int getAEBufferSize() {
		return aeBufferSize; // aePacketRawPool.writeBuffer().getCapacity();
	}

	/**
	 * set the size of the raw event packet buffer. Default is AE_BUFFER_SIZE. You can set this larger if you
	 * have overruns because your host processing (e.g. rendering) is taking too long.
	 * <p>
	 * This call discards collected events.
	 * 
	 * @param size
	 *            of buffer in events
	 */
	@Override
	public void setAEBufferSize(final int size) {
		if ((size < 1000) || (size > 1000000)) {
			CypressFX2.log.warning("ignoring unreasonable aeBufferSize of " + size
				+ ", choose a more reasonable size between 1000 and 1000000");
			return;
		}
		aeBufferSize = size;
		CypressFX2.prefs.putInt("CypressFX2.aeBufferSize", aeBufferSize);
		allocateAEBuffers();
	}

	/**
	 * start or stops the event acquisition. sends appropriate vendor request to
	 * device and starts or stops the AEReader.
	 * Thread-safe on hardware interface.
	 * 
	 * @param enable
	 *            boolean to enable or disable event acquisition
	 */
	@Override
	public synchronized void setEventAcquisitionEnabled(final boolean enable) throws HardwareInterfaceException {
		/*
		 * tobi commented synchronized but "deadlock" occurs only in debug mode, to try to solve problem of locking in
		 * exit menu because AEViewer waits on Thread.join but hardware interface is owned by AWT-EventQueue
		 * synchronized
		 */
		// log.info("setting event acquisition="+enable);
		setInEndpointEnabled(enable);
		if (enable) {
			startAEReader();
		}
		else {
			stopAEReader();
		}
	}

	@Override
	public boolean isEventAcquisitionEnabled() {
		return isInEndpointEnabled();
	}

	@Override
	public String getTypeName() {
		return "CypressFX2";
	}

	/** the first USB string descriptor (Vendor name) (if available) */
	protected String stringDescriptor1 = null;
	/** the second USB string descriptor (Product name) (if available) */
	protected String stringDescriptor2 = null;
	/** the third USB string descriptor (Serial number) (if available) */
	protected String stringDescriptor3 = null;
	/**
	 * The number of string desriptors - all devices have at least two (Vendor and Product strings) but some may have in
	 * addition
	 * a third serial number string. Default value is 2. Initialized to zero until device descriptors have been
	 * obtained.
	 */
	protected int numberOfStringDescriptors = 0;

	/**
	 * returns number of string descriptors
	 * 
	 * @return number of string descriptors: 2 for TmpDiff128, 3 for MonitorSequencer
	 */
	public int getNumberOfStringDescriptors() {
		return numberOfStringDescriptors;
	}

	/** the USBIO device descriptor */
	protected DeviceDescriptor deviceDescriptor = null;

	/**
	 * checks if device has a string identifier that is a non-empty string
	 * 
	 * @return false if not, true if there is one
	 */
	protected boolean hasStringIdentifier() {
		// getString string descriptor
		final String stringDescriptor1 = LibUsb.getStringDescriptor(deviceHandle, (byte) 1);

		if (stringDescriptor1 == null) {
			return false;
		}
		else if (stringDescriptor1.length() > 0) {
			return true;
		}

		return false;
	}

	/**
	 * Constructs a new USB connection and opens it. Does NOT start event acquisition.
	 * 
	 * @see #setEventAcquisitionEnabled
	 * @throws HardwareInterfaceException
	 *             if there is an error opening device
	 * @see #openLibUsb_minimal()
	 */
	@Override
	public void open() throws HardwareInterfaceException {
		openLibUsb();
	}

	/**
	 * This method does the hard work of opening the device, downloading the firmware, making sure everything is OK.
	 * <p>
	 * This method is synchronized to prevent multiple threads from trying to open at the same time, e.g. a GUI thread
	 * and the main thread.
	 * <p>
	 * Opening the device after it has already been opened has no effect.
	 * 
	 * @see #close
	 * @throws HardwareInterfaceException
	 *             if there is a problem. Diagnostics are printed to stderr.
	 */
	synchronized protected void openLibUsb() throws HardwareInterfaceException {
		// device has already been UsbIo Opened by now, in factory

		// opens the USBIOInterface device, configures it, binds a reader thread with buffer pool to read from the
		// device and starts the thread reading events.
		// we got a UsbIo object when enumerating all devices and we also made a device list. the device has already
		// been
		// opened from the UsbIo viewpoint, but it still needs firmware download, setting up pipes, etc.

		if (isOpen()) {
			return;
		}

		int status;

		// Open device.
		if (deviceHandle == null) {
			deviceHandle = new DeviceHandle();
			status = LibUsb.open(device, deviceHandle);
			if (status != LibUsb.SUCCESS) {
				throw new HardwareInterfaceException("openLibUsb(): failed to open device: " + LibUsb.errorName(status));
			}
		}

		// Check for blank devices (must first get device descriptor).
		if (deviceDescriptor == null) {
			deviceDescriptor = new DeviceDescriptor();
			LibUsb.getDeviceDescriptor(device, deviceDescriptor);
		}

		if (isBlankDevice()) {
			CypressFX2.log.warning("openLibUsb(): blank device detected, downloading preferred firmware");

			downloadFirmwareBinaryToBlankDevice();

			boolean success = false;
			int triesLeft = 10;
			status = 0;

			while (!success && (triesLeft > 0)) {
				try {
					Thread.sleep(1000);
				}
				catch (final InterruptedException e) {
				}

				LibUsb.close(deviceHandle);

				status = LibUsb.open(device, deviceHandle);
				if (status != LibUsb.SUCCESS) {
					triesLeft--;
				}
				else {
					success = true;
				}
			}

			if (!success) {
				throw new HardwareInterfaceException(
					"openLibUsb(): couldn't reopen device after firmware download and re-enumeration: "
						+ LibUsb.errorName(status));
			}
			else {
				throw new HardwareInterfaceException(
					"openLibUsb(): device firmware downloaded successfully, a new instance must be constructed by the factory using the new VID/PID settings");
			}
		}

		// Initialize device.
		if (deviceDescriptor.bNumConfigurations() != 1) {
			throw new HardwareInterfaceException("number of configurations=" + deviceDescriptor.bNumConfigurations()
				+ " is not 1 like it should be");
		}

		final IntBuffer activeConfig = BufferUtils.allocateIntBuffer();
		LibUsb.getConfiguration(deviceHandle, activeConfig);

		if (activeConfig.get() != 1) {
			LibUsb.setConfiguration(deviceHandle, 1);
		}

		LibUsb.claimInterface(deviceHandle, 0);

		populateDescriptors();

		isOpened = true;

		CypressFX2.log.info("openLibUsb(): device opened");

		if (LibUsb.getDeviceSpeed(device) != LibUsb.SPEED_HIGH) {
			CypressFX2.log
			.warning("Device is not operating at USB 2.0 High Speed, performance will be limited to about 300 keps");
		}

		// start the thread that listens for device status information (e.g. timestamp reset)
		asyncStatusThread = new AsyncStatusThread(this);
		asyncStatusThread.startThread();
	}

	/**
	 * Opens the device just enough to read the device descriptor but does not start the reader or writer
	 * thread. If the device does not have a string descriptor it is assumed that firmware must be downloaded to
	 * device RAM and this is done automatically. The device is <strong>not configured by this method. Vendor requests
	 * and
	 * probably other functionality will not be available.</strong>. The device is left open this method returns.
	 * 
	 * @throws net.sf.jaer.hardwareinterface.HardwareInterfaceException
	 * @see #open()
	 */
	synchronized protected void openLibUsb_minimal() throws HardwareInterfaceException {
		// device has already been UsbIo Opened by now, in factory

		// opens the USBIOInterface device, configures it, binds a reader thread with buffer pool to read from the
		// device and starts the thread reading events.
		// we got a UsbIo object when enumerating all devices and we also made a device list. the device has already
		// been
		// opened from the UsbIo viewpoint, but it still needs firmware download, setting up pipes, etc.

		if (isOpen()) {
			return;
		}

		int status;

		// Open device.
		if (deviceHandle == null) {
			deviceHandle = new DeviceHandle();
			status = LibUsb.open(device, deviceHandle);
			if (status != LibUsb.SUCCESS) {
				throw new HardwareInterfaceException("openLibUsb(): failed to open device: " + LibUsb.errorName(status));
			}
		}

		// Check for blank devices (must first get device descriptor).
		if (deviceDescriptor == null) {
			deviceDescriptor = new DeviceDescriptor();
			LibUsb.getDeviceDescriptor(device, deviceDescriptor);
		}

		if (isBlankDevice()) {
			throw new BlankDeviceException("Blank Cypress FX2");
		}

		if (!hasStringIdentifier()) { // TODO: does this really ever happen, a non-blank device with invalid fw?
			CypressFX2.log.warning("openLibUsb(): blank device detected, downloading preferred firmware");

			downloadFirmwareBinaryToBlankDevice();

			boolean success = false;
			int triesLeft = 10;
			status = 0;

			while (!success && (triesLeft > 0)) {
				try {
					Thread.sleep(1000);
				}
				catch (final InterruptedException e) {
				}

				LibUsb.close(deviceHandle);

				status = LibUsb.open(device, deviceHandle);
				if (status != LibUsb.SUCCESS) {
					triesLeft--;
				}
				else {
					success = true;
				}
			}

			if (!success) {
				throw new HardwareInterfaceException(
					"openLibUsb(): couldn't reopen device after firmware download and re-enumeration: "
						+ LibUsb.errorName(status));
			}
			else {
				throw new HardwareInterfaceException(
					"openLibUsb(): device firmware downloaded successfully, a new instance must be constructed by the factory using the new VID/PID settings");
			}
		}

		populateDescriptors();
	}

	/**
	 * return the string USB descriptors for the device
	 * 
	 * @return String[] of length 2 or 3 of USB descriptor strings.
	 */
	@Override
	public String[] getStringDescriptors() {
		if (stringDescriptor1 == null) {
			CypressFX2.log.warning("USBAEMonitor: getStringDescriptors called but device has not been opened");

			final String[] s = new String[numberOfStringDescriptors];

			for (int i = 0; i < numberOfStringDescriptors; i++) {
				s[i] = "";
			}

			return s;
		}

		final String[] s = new String[numberOfStringDescriptors];

		s[0] = (stringDescriptor1 == null) ? ("") : (stringDescriptor1);
		s[1] = (stringDescriptor2 == null) ? ("") : (stringDescriptor2);
		if (numberOfStringDescriptors == 3) {
			s[2] = (stringDescriptor3 == null) ? ("") : (stringDescriptor3);
		}

		return s;
	}

	/**
	 * return the USB VID/PID of the interface
	 * 
	 * @return int[] of length 2 containing the Vendor ID (VID) and Product ID (PID) of the device. First element is
	 *         VID, second element is PID.
	 */
	@Override
	public int[] getVIDPID() {
		if (deviceDescriptor == null) {
			CypressFX2.log.warning("USBAEMonitor: getVIDPID called but device has not been opened");
			return new int[2];
		}
		final int[] n = new int[2];
		n[0] = deviceDescriptor.idVendor();
		n[1] = deviceDescriptor.iProduct();
		return n;
	}

	@Override
	public short getVID() {
		if (deviceDescriptor == null) {
			CypressFX2.log.warning("USBAEMonitor: getVIDPID called but device has not been opened");
			return 0;
		}
		// int[] n=new int[2]; n is never used
		return deviceDescriptor.idVendor();
	}

	@Override
	public short getPID() {
		if (deviceDescriptor == null) {
			CypressFX2.log.warning("USBAEMonitor: getVIDPID called but device has not been opened");
			return 0;
		}
		return deviceDescriptor.idProduct();
	}

	/** @return bcdDevice (the binary coded decimel device version */
	@Override
	public short getDID() { // this is not part of USB spec in device descriptor.
		return deviceDescriptor.bcdDevice();
	}

	/**
	 * reports if interface is {@link #open}.
	 * 
	 * @return true if already open
	 */
	@Override
	public boolean isOpen() {
		return isOpened;
	}

	/**
	 * Loads a binary firmware file into memory.
	 * The filename is used to search the resource path (i.e. the jar archives on the classpath).
	 * If the file is not found in the resources (jars or classes on classpath) then the file system is checked.
	 * 
	 * @param firmwareFilename
	 *            the resource path
	 **/
	public byte[] loadBinaryFirmwareFile(final String firmwareFilename) throws IOException {
		CypressFX2.log.info("loading to memory firmware file " + firmwareFilename);
		InputStream firmwareFileStream;
		byte[] fwBuffer;
		// load firmware file (this is binary file of 8051 firmware)
		try {
			firmwareFileStream = getClass().getResourceAsStream(firmwareFilename);
			if (firmwareFileStream != null) {
				final int len = firmwareFileStream.available(); // we must loop available() according to
				// http://bugs.sun.com/bugdatabase/view_bug.do?bug_id=6278051
				// log.info("firmare length: " + len);
				fwBuffer = new byte[firmwareFileStream.available()];
				int numBytesRead = firmwareFileStream.read(fwBuffer);
				// log.info("bytes read: "+ numBytesRead);

				int ki = 1;
				final int maxtries = 5;
				while (numBytesRead < len) {
					CypressFX2.log.info("Could only read " + numBytesRead + " of " + len + ", trying " + ki + "/"
						+ maxtries + " more times.");

					final int rd = firmwareFileStream.read(fwBuffer, numBytesRead, len - numBytesRead);
					numBytesRead += rd;
					ki++;
					if (ki > 5) {
						throw new IOException("could not read binary firmware file");
					}
				}
				firmwareFileStream.close();
			}
			else {
				CypressFX2.log.info("could not get resource as stream");
				fwBuffer = loadBinaryFirmwareFileSystemFile(firmwareFilename);
			}
		}
		catch (final IOException e) {
			close();
			CypressFX2.log.warning(e.getMessage());
			throw new IOException("can't load binary Cypress FX2 firmware file " + firmwareFilename);
		}
		return fwBuffer;
	}

	/**
	 * Loads a binary firmware file into memory from a file system path (as opposed to resource path).
	 * 
	 * @param firmwareFilename
	 *            the file path
	 **/
	public byte[] loadBinaryFirmwareFileSystemFile(final String firmwareFilename) throws IOException {
		CypressFX2.log.info("reading firmware file " + firmwareFilename);
		InputStream firmwareFileStream;
		byte[] fwBuffer;
		// load firmware file (this is binary file of 8051 firmware)
		try {
			final File f = new File(firmwareFilename);
			firmwareFileStream = new FileInputStream(f);
			fwBuffer = new byte[firmwareFileStream.available()];
			firmwareFileStream.read(fwBuffer);
			firmwareFileStream.close();
		}
		catch (final IOException e) {
			close();
			CypressFX2.log.warning(e.getMessage());
			throw new IOException(
				"can't load binary Cypress FX2 firmware file "
					+ firmwareFilename
					+ "\nYou may need to choose a new default firmware file if you moved your jAER installation since setting this file.");
		}
		return fwBuffer;
	}

	/**
	 * downloads firmware to FX2 RAM. adapted from John Arthur's example, which comes from Cypress example.
	 * Firmware file is a binary file produced by uVision2 (Keil) from source code for firmware.
	 * <p>
	 * Firmware that is actually downloaded depends on discovered PID of device. If the PID is discovered to be a bare
	 * CypressFX2, then a dialog is shown that user can use to program the VID/PID of the device.
	 * <p>
	 * In addition, there is a problem if firmware is downloaded more than once to an FX2LP device between hard resets.
	 * Therefore if this method detects that the device has string identitifers, it assumes the firmware has already
	 * been downloaded.
	 * 
	 * 
	 * Firmware file is loaded as a resource from the jar archive.
	 */
	synchronized public void downloadFirmwareBinary(final String firmwareFilename) throws HardwareInterfaceException {

		byte[] fwBuffer; // buffer to hold contents of firmware file (binary 8051 code)

		try {
			fwBuffer = loadBinaryFirmwareFile(firmwareFilename);
		}
		catch (final IOException e) {
			close();
			CypressFX2.log.warning(e.getMessage());
			throw new HardwareInterfaceException("can't load binary Cypress FX2 firmware file " + firmwareFilename);
		}

		set8051Reset(true);
		download8051RAM(0, fwBuffer);
		set8051Reset(false);
	}

	/**
	 * Downloads firmware to FX2 RAM. adapted from John Arthur's example in Kwabena Boahen's lab at Stanford, which
	 * comes from Cypress example.
	 * Firmware file is a binary file produced by uVision2 (Keil) from source code for firmware.
	 * <p>
	 * Firmware that is actually downloaded depends on discovered PID of device. If the PID is discovered to be a bare
	 * CypressFX2, then a dialog is shown that user can use to program the VID/PID of the device.
	 * <p>
	 * In addition, there is a problem if firmware is downloaded more than once to an FX2LP device between hard resets.
	 * Therefore if this method detects that the device has string identifiers, it assumes the firmware has already been
	 * downloaded.
	 * 
	 * <p>
	 * Firmware file is loaded either from the file system or as a resource from the jar archive.
	 * 
	 * @throws BlankDeviceException
	 *             if device is blank or firmware file is not found.
	 * @throws HardwareInterfaceException
	 *             if there is an error during download
	 */
	public synchronized void downloadFirmwareBinaryToBlankDevice() throws HardwareInterfaceException {

		// firmware load variables
		byte[] fwBuffer; // buffer to hold contents of firmware file (binary 8051 code)

		// String firmwareFilename = getFirmwareFilenameBinaryFromVIDPID();

		final String firmwareFilename = getChip() == null ? null : getChip().getDefaultFirmwareBixFileForBlankDevice();
		if (firmwareFilename == null) {
			// log.warning("firmwareFilename=null, please set a default binary firmware file for RAM download");
			throw new BlankDeviceException(
				"firmwareFilename=null, please set a default binary firmware file for RAM download");
		}

		CypressFX2.log.info("downloading binary firmware " + firmwareFilename
			+ " to CypressFX2 RAM (volatile, on-chip) memory");
		try {
			fwBuffer = loadBinaryFirmwareFile(firmwareFilename);
		}
		catch (final IOException e) {
			close();
			CypressFX2.log.warning(e.getMessage());
			throw new BlankDeviceException("can't load binary Cypress FX2 firmware file " + firmwareFilename);
		}

		set8051Reset(true);
		download8051RAM(0, fwBuffer);
		set8051Reset(false);

	}

	/**
	 * Returns the firmware filenmae corresponding to a VID/PID pair.
	 * This filename is a full path to a resource on the classpath which is in the project jar jAER.jar.
	 * 
	 * @deprecated not used anymore - user chooses firmware file via AEViewer/CypressFX2 menu item
	 */
	@Deprecated
	protected String getFirmwareFilenameBinaryFromVIDPID() {
		String firmwareFilename = null;
		if (getPID() == CypressFX2.PID_USBAERmini2_without_firmware) {
			firmwareFilename = CypressFX2.FIRMWARE_FILENAME_MONITOR_SEQUENCER;
		}
		else if (getPID() == CypressFX2.PID_USBAERmini2) {
			firmwareFilename = CypressFX2.FIRMWARE_FILENAME_MONITOR_SEQUENCER;
		}
		else if (getPID() == CypressFX2.PID_TCVS320_RETINA) {
			firmwareFilename = CypressFX2.FIRMWARE_FILENAME_TCVS320_BIX;
		}
		else if (getPID() == CypressFX2.PID_TMPDIFF128_RETINA) {
			firmwareFilename = CypressFX2.FIRMWARE_FILENAME_TMPDIFF128_BIX;
		}
		else {
			CypressFX2.log.warning("unknown device product ID (PID)=" + HexString.toString(getPID()));
			firmwareFilename = CypressFX2.FIRMWARE_FILENAME_MONITOR_SEQUENCER;
			// firmwareFilename=showFirmwareFilenameDialog();
		}
		return firmwareFilename;
	}

	/**
	 * Shows a dialog to let user choose a firmware file for download to the device
	 * 
	 * @return full path to chosen file
	 */
	public String showFirmwareFilenameDialog() {
		String filename = null;
		final CypressFX2FirmwareFilennameChooserOkCancelDialog dialog = new CypressFX2FirmwareFilennameChooserOkCancelDialog(
			chip != null ? chip.getAeViewer() : null, true, chip);
		dialog.setVisible(true);
		final int ret = dialog.getReturnStatus();
		if (ret == CypressFX2FirmwareFilennameChooserOkCancelDialog.RET_OK) {
			filename = dialog.getChosenFile();
		}
		else {
			filename = null;
		}
		return filename;
		// FilenameGetter filenameGetter = new FilenameGetter();
		// try {
		// SwingUtilities.invokeAndWait(filenameGetter);
		// } catch (Exception e){
		// log.warning(e.toString());
		// return null;
		// }
		// return filenameGetter.filename;
	}

	// private class FilenameGetter implements Runnable {
	//
	// String filename = null;
	//
	// public void run() {
	// CypressFX2FirmwareFilennameChooserOkCancelDialog dialog = new
	// CypressFX2FirmwareFilennameChooserOkCancelDialog(chip != null ? chip.getAeViewer() : null, true);
	// dialog.setVisible(true);
	// int ret = dialog.getReturnStatus();
	// if (ret == CypressFX2FirmwareFilennameChooserOkCancelDialog.RET_OK) {
	// filename = dialog.getChosenFile();
	// } else {
	// filename = null;
	// }
	// }
	// }
	// returns the firmware filenmae corresponding to a VID/PID pair
	// this filename is actually a full path to a resource on the classpath
	protected String getFirmwareFilenameHexFromVIDPID() {
		String firmwareFilename = null;
		if (getPID() == CypressFX2.PID_USBAERmini2_without_firmware) {
			firmwareFilename = CypressFX2.FIRMWARE_FILENAME_MONITOR_SEQUENCER_HEX;
		}
		else {
			firmwareFilename = CypressFX2.FIRMWARE_FILENAME_TMPDIFF128_HEX;
		}
		return firmwareFilename;
	}

	/**
	 * Downloads to RAM on FX2 using built-in vendor request to CPUCS.
	 * Remember to set8051Reset() before and after calling this method.
	 * 
	 * @param address
	 *            the starting address in the 8051 RAM
	 * @param FWBuffer
	 *            the data
	 * @see #set8051Reset
	 */
	protected void download8051RAM(final int address, final byte[] FWBuffer) throws HardwareInterfaceException {
		CypressFX2.log.info("downloading " + FWBuffer.length + " bytes to CypressFX2 RAM starting at " + address);
		/*
		 * From Fx2 tech ref guide, chapter 2 "endpoint 0"
		 * 
		 * The USB endpoint-zero protocol provides a mechanism for mixing
		 * vendor-specific requests with standard device requests. Bits 6:5 of the bmRequestType
		 * field are set to 00 for a standard device request and to 10 for a vendor request.
		 */
		// need to perform the following steps:
		//
		// 1) reset the Cypress (write 0x01 into CPUCS register)
		// 2) send the firmware to Control Endpoint 0
		// 3) pull the Cypress out of reset (write 0x00 into the CPUCS register)

		// this is achieved by using the vendor request VENDOR_REQUEST_FIRMWARE, where the Value of the request is the
		// address to write to and the buffer passed to USBIO_CLASS_OR_VENDOR_REQUEST defines data to be written
		// starting at this address and the number of bytes to be written.
		// thus the same vendor request can reset the 8051 (one byte written to CPUCS) and download successive chunks
		// of code. finally the request can unreset the 8051.
		// 2) send the firmware to Control Endpoint 0
		// when sending firmware, we need to break up the loaded fimware
		// into MAX_CONTROL_XFER_SIZE blocks
		//
		// this means:
		// a) the address to load it to needs to be changed (VendorRequest.Value)
		// b) need a pointer that moves through FWbuffer (pBuffer)
		// c) keep track of remaining bytes to transfer (FWsize_left);

		// send all but last chunk
		final int numChunks = FWBuffer.length / MAX_CONTROL_XFER_SIZE; // this is number of full chunks to send

		for (int i = 0; i < numChunks; i++) {
			sendVendorRequest(CypressFX2.VENDOR_REQUEST_FIRMWARE, (short) (i * MAX_CONTROL_XFER_SIZE), (short) 0,
				FWBuffer, i * MAX_CONTROL_XFER_SIZE, MAX_CONTROL_XFER_SIZE);
		}

		// now send final (short) chunk
		final int numBytesLeft = FWBuffer.length % MAX_CONTROL_XFER_SIZE; // remainder

		if (numBytesLeft > 0) {
			// send remaining part of firmware
			sendVendorRequest(CypressFX2.VENDOR_REQUEST_FIRMWARE, (short) (numChunks * MAX_CONTROL_XFER_SIZE),
				(short) 0, FWBuffer, numChunks * MAX_CONTROL_XFER_SIZE, numBytesLeft);
		}

		CypressFX2.log.info("done downloading RAM");
	}

	/**
	 * sends vendor request to CPUCS register to set 8051 in CPU reset (or not)
	 * 
	 * @param value
	 *            true to reset, false to run
	 * @see #download8051RAM
	 */
	protected void set8051Reset(final boolean value) throws HardwareInterfaceException {
		final ByteBuffer dataBuffer = BufferUtils.allocateByteBuffer(1);
		dataBuffer.put(0, (byte) (value ? 1 : 0));

		sendVendorRequest(CypressFX2.VENDOR_REQUEST_FIRMWARE, CPUCS, (short) 0, dataBuffer);
	}

	/**
	 * @return timestamp tick in us
	 *         NOTE: DOES NOT RETURN THE TICK OF THE USBAERmini2 board
	 */
	@Override
	final public int getTimestampTickUs() {
		return TICK_US;
	}

	/**
	 * returns last events from {@link #acquireAvailableEventsFromDriver}
	 * 
	 * @return the event packet
	 */
	@Override
	public AEPacketRaw getEvents() {
		return lastEventsAcquired;
	}

	/**
	 * Sends a vendor request without any data packet, value and index are set to zero. This is a blocking method.
	 * 
	 * @param request
	 *            the vendor request byte, identifies the request on the device
	 */
	synchronized public void sendVendorRequest(final byte request) throws HardwareInterfaceException {
		sendVendorRequest(request, (short) 0, (short) 0);
	}

	/**
	 * Sends a vendor request without any data packet but with request, value and index. This is a blocking method.
	 * 
	 * @param request
	 *            the vendor request byte, identifies the request on the device
	 * @param value
	 *            the value of the request (bValue USB field)
	 * @param index
	 *            the "index" of the request (bIndex USB field)
	 */
	synchronized public void sendVendorRequest(final byte request, final short value, final short index)
		throws HardwareInterfaceException {
		sendVendorRequest(request, value, index, (ByteBuffer) null);
	}

	/**
	 * Sends a vendor request with a given byte[] as data. This is a blocking method.
	 * 
	 * @param request
	 *            the vendor request byte, identifies the request on the device
	 * @param value
	 *            the value of the request (bValue USB field)
	 * @param index
	 *            the "index" of the request (bIndex USB field)
	 * @param bytes
	 *            the data which is to be transmitted to the device
	 */
	synchronized public void sendVendorRequest(final byte request, final short value, final short index,
		final byte[] bytes) throws HardwareInterfaceException {
		sendVendorRequest(request, value, index, bytes, 0, bytes.length);
	}

	/**
	 * Sends a vendor request with a given byte[] as data. This is a blocking method.
	 * 
	 * @param request
	 *            the vendor request byte, identifies the request on the device
	 * @param value
	 *            the value of the request (bValue USB field)
	 * @param index
	 *            the "index" of the request (bIndex USB field)
	 * @param bytes
	 *            the data which is to be transmitted to the device
	 * @param pos
	 *            position at which to start consuming the bytes array
	 * @param length
	 *            number of bytes to copy, starting at position pos
	 */
	synchronized public void sendVendorRequest(final byte request, final short value, final short index,
		final byte[] bytes, final int pos, final int length) throws HardwareInterfaceException {
		final ByteBuffer dataBuffer = BufferUtils.allocateByteBuffer(length);

		dataBuffer.put(bytes, pos, length);

		sendVendorRequest(request, value, index, dataBuffer);
	}

	/**
	 * Sends a vendor request with data (including special bits). This is a blocking method.
	 * 
	 * @param requestType
	 *            the vendor requestType byte (used for special cases, usually 0)
	 * @param request
	 *            the vendor request byte, identifies the request on the device
	 * @param value
	 *            the value of the request (bValue USB field)
	 * @param index
	 *            the "index" of the request (bIndex USB field)
	 * @param dataBuffer
	 *            the data which is to be transmitted to the device (null means no data)
	 */
	synchronized public void sendVendorRequest(final byte request, final short value, final short index,
		ByteBuffer dataBuffer) throws HardwareInterfaceException {
		if (!isOpen()) {
			open();
		}

		if (dataBuffer == null) {
			dataBuffer = BufferUtils.allocateByteBuffer(0);
		}

		final byte bmRequestType = (byte) (LibUsb.ENDPOINT_OUT | LibUsb.REQUEST_TYPE_VENDOR | LibUsb.RECIPIENT_DEVICE);

		final int status = LibUsb.controlTransfer(deviceHandle, bmRequestType, request, value, index, dataBuffer, 0);
		if (status < LibUsb.SUCCESS) {
			throw new HardwareInterfaceException("Unable to send vendor OUT request " + String.format("0x%x", request)
				+ ": " + LibUsb.errorName(status));
		}

		if (status != dataBuffer.capacity()) {
			throw new HardwareInterfaceException("Wrong number of bytes transferred, wanted: " + dataBuffer.capacity()
				+ ", got: " + status);
		}
	}

	/**
	 * Sends a vendor request to receive (IN direction) data. This is a blocking method.
	 * 
	 * @param request
	 *            the vendor request byte, identifies the request on the device
	 * @param value
	 *            the value of the request (bValue USB field)
	 * @param index
	 *            the "index" of the request (bIndex USB field)
	 * @param dataLength
	 *            amount of data to receive, determines size of returned buffer (must be greater than 0)
	 * @return a buffer containing the data requested from the device
	 */
	synchronized public ByteBuffer sendVendorRequestIN(final byte request, final short value, final short index,
		final int dataLength) throws HardwareInterfaceException {
		if (dataLength == 0) {
			throw new HardwareInterfaceException("Unable to send vendor IN request with dataLength of zero!");
		}

		if (!isOpen()) {
			open();
		}

		final ByteBuffer dataBuffer = BufferUtils.allocateByteBuffer(dataLength);

		final byte bmRequestType = (byte) (LibUsb.ENDPOINT_IN | LibUsb.REQUEST_TYPE_VENDOR | LibUsb.RECIPIENT_DEVICE);

		final int status = LibUsb.controlTransfer(deviceHandle, bmRequestType, request, value, index, dataBuffer, 0);
		if (status < LibUsb.SUCCESS) {
			throw new HardwareInterfaceException("Unable to send vendor IN request " + String.format("0x%x", request)
				+ ": " + LibUsb.errorName(status));
		}

		if (status != dataLength) {
			throw new HardwareInterfaceException("Wrong number of bytes transferred, wanted: " + dataLength + ", got: "
				+ status);
		}

		// Update ByteBuffer internal limit to show how much was successfully read.
		// usb4java never touches the ByteBuffer's internals by design, so we do it here.
		dataBuffer.limit(dataLength);

		return (dataBuffer);
	}

	/* encodings of xsvf instructions */
	private static final byte XCOMPLETE = (byte) 0;
	private static final byte XTDOMASK = (byte) 1;
	private static final byte XSIR = (byte) 2;
	private static final byte XSDR = (byte) 3;
	private static final byte XRUNTEST = (byte) 4;
	/* Reserved 5 */
	/* Reserved 6 */
	private static final byte XREPEAT = (byte) 7;
	private static final byte XSDRSIZE = (byte) 8;
	private static final byte XSDRTDO = (byte) 9;
	private static final byte XSDRB = (byte) 12;
	private static final byte XSDRC = (byte) 13;
	private static final byte XSDRE = (byte) 14;
	private static final byte XSDRTDOB = (byte) 15;
	private static final byte XSDRTDOC = (byte) 16;
	private static final byte XSDRTDOE = (byte) 17;
	private static final byte XSTATE = (byte) 18; /* 4.00 */

	private static final byte XENDIR = (byte) 19; /* 4.04 */

	private static final byte XENDDR = (byte) 20; /* 4.04 */

	private static final byte XSIR2 = (byte) 21; /* 4.10 */

	private static final byte XCOMMENT = (byte) 22; /* 4.14 */

	private static final byte XWAIT = (byte) 23; /* 5.00 */

	/**
	 * Writes the CPLD configuration from an SVF file. Thread-safe.
	 * 
	 * @param svfFile
	 * @throws net.sf.jaer.hardwareinterface.HardwareInterfaceException
	 */
	synchronized public void writeCPLDfirmware(final String svfFile) throws HardwareInterfaceException {
		byte[] bytearray;
		byte command;
		int commandlength = 1, index = 0, length = 0;
		ByteBuffer dataBuffer = null;

		try {
			bytearray = loadBinaryFirmwareFile(svfFile);
		}
		catch (final Exception e) {
			e.printStackTrace();
			return;
		}
		ProgressMonitor progressMonitor = makeProgressMonitor("Writing CPLD configuration - do not unplug", 0,
			bytearray.length);

		if ((bytearray == null) || (bytearray.length == 0)) {
			throw new NullPointerException(
				"xsvf file seems to be empty. Did ISE compile it and did you generate the XSVF file?");
		}
		command = bytearray[index];

		while (command != 0x00) {
			commandlength = 1;
			switch (command) {
				case XTDOMASK:
					commandlength = length + 1;
					break;
				case XREPEAT:
					commandlength = 2;
					break;
				case XRUNTEST:
					commandlength = 5;
					break;
				case XSIR:
					commandlength = ((bytearray[index + 1] + 7) / 8) + 2;
					break;
				case XSIR2:
					commandlength = ((((bytearray[index + 1] << 8) | bytearray[index + 2]) + 7) / 8) + 3;
					break;
				case XSDR:
					commandlength = length + 1;
					break;
				case XSDRSIZE:
					commandlength = 5;
					length = ((bytearray[index + 1] << 24) | (bytearray[index + 2] << 16) | (bytearray[index + 3] << 8) | ((bytearray[index + 4]) + 7)) / 8;
					break;
				case XSDRTDO:
					commandlength = (2 * length) + 1;
					break;
				case XSDRB:

					commandlength = length + 1;
					break;
				case XSDRC:

					commandlength = length + 1;
					break;
				case XSDRE:

					commandlength = length + 1;
					break;
				case XSDRTDOB:

					commandlength = (2 * length) + 1;
					break;
				case XSDRTDOC:

					commandlength = (2 * length) + 1;
					break;
				case XSDRTDOE:

					commandlength = (2 * length) + 1;
					break;
				case XSTATE:

					commandlength = 2;
					break;
				case XENDIR:

					commandlength = 2;
					break;
				case XENDDR:

					commandlength = 2;
					break;
				case XCOMMENT:

					commandlength = 2;
					while (bytearray[(index + commandlength) - 1] != 0x00) {
						commandlength += 1;
					}
					CypressFX2.log.info("found comment");
					break;
				case XWAIT:

					commandlength = 7;
					break;
				default:
					sendVendorRequest(CypressFX2.VR_DOWNLOAD_FIRMWARE, (short) 0, (short) 0);
					throw new HardwareInterfaceException("Unable to program CPLD, unknown xsfv command: " + command);
			}

			sendVendorRequest(CypressFX2.VR_DOWNLOAD_FIRMWARE, command, (short) 0, bytearray, index, commandlength);

			try {
				dataBuffer = sendVendorRequestIN(CypressFX2.VR_DOWNLOAD_FIRMWARE, (short) 0, (short) 0, 2);
			}
			catch (final HardwareInterfaceException e) {
				this.sendVendorRequest(CypressFX2.VR_DOWNLOAD_FIRMWARE, (short) 0, (short) 0);
				throw new HardwareInterfaceException("Unable to program CPLD, could not get xsvf Error code");
			}

			if (dataBuffer.get(1) == 10) {
				this.sendVendorRequest(CypressFX2.VR_DOWNLOAD_FIRMWARE, (short) 0, (short) 0);
				throw new HardwareInterfaceException(
					"Unable to program CPLD, command too long, please report to raphael@ini.ch, command: " + command
					+ " index: " + index + " commandlength " + commandlength);
			}
			else if (dataBuffer.get(1) > 0) {
				this.sendVendorRequest(CypressFX2.VR_DOWNLOAD_FIRMWARE, (short) 0, (short) 0);
				throw new HardwareInterfaceException("Unable to program CPLD, error code: " + dataBuffer.get(1)
					+ ", at command: " + command + " index: " + index + " commandlength " + commandlength);
			}

			index += commandlength;
			command = bytearray[index];

			// can't cancel
			if (progressMonitor.isCanceled()) {
				progressMonitor = makeProgressMonitor("Writing CPLD configuration - do not unplug", 0, bytearray.length);
			}

			progressMonitor.setProgress(index);
			progressMonitor
			.setNote(String.format("sent %d of %d bytes of CPLD configuration", index, bytearray.length));
		}

		// complete
		CypressFX2.log.info("sending XCOMPLETE");
		this.sendVendorRequest(CypressFX2.VR_DOWNLOAD_FIRMWARE, CypressFX2.XCOMPLETE, (short) 0);
		progressMonitor.close();
	}

	public AEReader getAeReader() {
		return aeReader;
	}

	public void setAeReader(final AEReader aeReader) {
		this.aeReader = aeReader;
	}

	@Override
	public int getFifoSize() {
		if (aeReader == null) {
			return -1;
		}
		else {
			return aeReader.getFifoSize();
		}
	}

	@Override
	public void setFifoSize(final int fifoSize) {
		if (aeReader == null) {
			return;
		}

		aeReader.setFifoSize(fifoSize);
	}

	@Override
	public int getNumBuffers() {
		if (aeReader == null) {
			return 0;
		}
		else {
			return aeReader.getNumBuffers();
		}
	}

	@Override
	public void setNumBuffers(final int numBuffers) {
		if (aeReader == null) {
			return;
		}

		aeReader.setNumBuffers(numBuffers);
	}

	@Override
	public void setChip(final AEChip chip) {
		this.chip = chip;
	}

	@Override
	public AEChip getChip() {
		return chip;
	}

	/** Resets the USB device using USBIO resetDevice */
	public void resetUSB() {
		if (deviceHandle == null) {
			return;
		}

		final int status = LibUsb.resetDevice(deviceHandle);
		if (status != LibUsb.SUCCESS) {
			CypressFX2.log.warning("Error resetting device: " + LibUsb.errorName(status));
		}
	}

	/**
	 * Checks for blank cypress VID/PID.
	 * Device deviceDescriptor must be populated before calling this method.
	 * 
	 * @return true if blank
	 */
	protected boolean isBlankDevice() {
		if ((deviceDescriptor.idVendor() == CypressFX2.VID_BLANK)
			&& (deviceDescriptor.idProduct() == CypressFX2.PID_BLANK)) {
			// log.warning("blank CypressFX2 detected");
			return true;
		}
		return false;
	}
}
